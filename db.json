{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":0,"renderable":0},{"_id":"themes/MyFairLady/source/CNAME","path":"CNAME","modified":0,"renderable":1},{"_id":"themes/MyFairLady/source/fonts/cathsgbr.eot","path":"fonts/cathsgbr.eot","modified":0,"renderable":1},{"_id":"themes/MyFairLady/source/fonts/cathsgbr.svg","path":"fonts/cathsgbr.svg","modified":0,"renderable":1},{"_id":"themes/MyFairLady/source/fonts/cathsgbr.woff","path":"fonts/cathsgbr.woff","modified":0,"renderable":1},{"_id":"themes/MyFairLady/source/fonts/cathsgbr.ttf","path":"fonts/cathsgbr.ttf","modified":0,"renderable":1},{"_id":"themes/MyFairLady/source/fonts/cathsgbr.woff2","path":"fonts/cathsgbr.woff2","modified":0,"renderable":1},{"_id":"themes/MyFairLady/source/images/menu.png","path":"images/menu.png","modified":0,"renderable":1},{"_id":"themes/MyFairLady/source/js/bookmark.js","path":"js/bookmark.js","modified":0,"renderable":1},{"_id":"themes/MyFairLady/source/js/sidebar.js","path":"js/sidebar.js","modified":0,"renderable":1},{"_id":"themes/MyFairLady/source/js/toTop.js","path":"js/toTop.js","modified":0,"renderable":1},{"_id":"themes/MyFairLady/source/sass/main.scss","path":"sass/main.scss","modified":0,"renderable":1}],"Cache":[{"_id":"source/CNAME","hash":"ea64e352436f16dad5198ef69326e86e57b9ae14","modified":1509102153000},{"_id":"themes/MyFairLady/.gitignore","hash":"7cbd0665c9f95674b6f3179ce3d49bd270282ffe","modified":1509360831000},{"_id":"themes/MyFairLady/README.md","hash":"176d576b33e8fd6bb855cc2da04b1b5b50714634","modified":1509360831000},{"_id":"themes/MyFairLady/_config.yml","hash":"ec6108595c054b7b736abced62f367a77f141aee","modified":1509360831000},{"_id":"source/_posts/CSS-盒模型和视觉格式化上下文.md","hash":"4350bc2c2c2de121b10de17bf839d95d7a4238ff","modified":1509360831000},{"_id":"source/_posts/CSS定位那些事儿.md","hash":"0e0cd87e8e529ace3f94d8be24c4dc20fd3ce753","modified":1509360831000},{"_id":"source/_posts/CSS的BFC.md","hash":"ec60b981094f0bea5442b9be536fce2db26c15a8","modified":1509360831000},{"_id":"source/_posts/React中的样式处理.md","hash":"45771228db704232758546191dff72e9e4231ab3","modified":1509360831000},{"_id":"source/_posts/angularJS初体验.md","hash":"c457cab03ab588c6aa319ae6a9748862539c0bb9","modified":1509360831000},{"_id":"source/_posts/bower入门.md","hash":"1593e8167fec4103b1f4dfbf43ab08bd00531a5a","modified":1509360831000},{"_id":"source/_posts/javascript设计模式-单例模式.md","hash":"5b79f687cad048b541e571ac9f64cd30436ccd26","modified":1509360831000},{"_id":"source/_posts/javascript设计模式-原型模式.md","hash":"a79a9f7ec16e298579f01ccb5dcfd33d4aedef64","modified":1509360831000},{"_id":"source/_posts/优化webpack.md","hash":"809fd6ebbb176d9cd3fc4e890f56e61fa2d35692","modified":1509360831000},{"_id":"source/_posts/关于时间管理.md","hash":"43fe76f73dd5dd60ecc40d6ef653d21422a8c695","modified":1509360831000},{"_id":"source/_posts/前端工程化-gulp应用篇1.md","hash":"5f1acfcc02a49b553991366146f22f8ea67702f0","modified":1509360831000},{"_id":"source/_posts/原来除了box-shadow,还有drop-shadow.md","hash":"231b8b4df2ee92f3ea1afb4e07431c05286f1871","modified":1509360831000},{"_id":"source/_posts/前端工程化-gulp应用篇2.md","hash":"02bd32ca353e379cfbf29f44c1a195b7a182c58c","modified":1509360831000},{"_id":"source/_posts/在创业公司实习的三个月.md","hash":"05e69a3b89590702226a594c94217dc514821ede","modified":1509360831000},{"_id":"source/_posts/微信支付踩过的坑.md","hash":"f886cf61a4601b77a174d8edc75b381112090d4e","modified":1509360831000},{"_id":"source/_posts/浏览器渲染性能分析与优化.md","hash":"06d92e6d193f5d20d8adc6f182b70956dc9b0469","modified":1509360831000},{"_id":"source/_posts/浏览器渲染过程学习总结.md","hash":"ad9f3deb70b5f55d40f995855eee2f51e2ac38db","modified":1509360831000},{"_id":"source/_posts/状态模式.md","hash":"288bf94fe8a8c5bcd773d86c3ed4399ad7a2d4d6","modified":1509360831000},{"_id":"source/_posts/用Yeoman来创建我的web应用.md","hash":"940a83f082dcaa09e9dc9317cc2c52b872bcca63","modified":1509360831000},{"_id":"source/_posts/策略模式.md","hash":"80dd907df0d4af0c11f18f3b30f31fa7e693a226","modified":1509360831000},{"_id":"source/_posts/走在人生的夜路上.md","hash":"e091cd7fc7d3b8bb5816ce1ea635597249b6db6d","modified":1509360831000},{"_id":"source/_posts/面向对象编程的SOLID原则.md","hash":"9d31d186300600b92bc909d367a50c77775fa8a5","modified":1509360831000},{"_id":"source/_posts/项目总结-wps.md","hash":"fde27317cf122779c9c7abeafcb9935acdddd181","modified":1509360831000},{"_id":"themes/MyFairLady/doc/README-en.md","hash":"5212bc748e8d88003ec7bf948f63466388cc33b9","modified":1509360831000},{"_id":"themes/MyFairLady/doc/README-zh.md","hash":"a829f4435c4ab94295dd6506daeec43a1e8dfd58","modified":1509360831000},{"_id":"themes/MyFairLady/source/CNAME","hash":"64b9e73555e0c77313d196dbb3a674e97b3abc4a","modified":1509360831000},{"_id":"themes/MyFairLady/layout/archive.ejs","hash":"2f4ca17044c12de6e22c78b64bc57c70acc2e8f7","modified":1509360831000},{"_id":"themes/MyFairLady/layout/category.ejs","hash":"547bbb0d2d4ca74a8425e3372fa5a501f53e98e9","modified":1509360831000},{"_id":"themes/MyFairLady/layout/index.ejs","hash":"f291cdad238d06a87d1d0d8245921604b2089d63","modified":1509360831000},{"_id":"themes/MyFairLady/layout/layout.ejs","hash":"2a811076fa88dfaa1fa1bbdb21ffa5582e0b79fe","modified":1509360831000},{"_id":"themes/MyFairLady/layout/page.ejs","hash":"c1383d011895d9743f5967898e2ecefb1cfa386f","modified":1509360831000},{"_id":"themes/MyFairLady/layout/post.ejs","hash":"5e8b48d19ce47b716ffc41febf5340ed72614336","modified":1509360831000},{"_id":"themes/MyFairLady/source/fonts/cathsgbr.eot","hash":"f8a4f4f444e5bc1f5b74e8f09ee071aee6434afc","modified":1509360831000},{"_id":"themes/MyFairLady/source/fonts/cathsgbr.svg","hash":"196688f0dcbb0f916090b9fd70760ba97ce38ed0","modified":1509360831000},{"_id":"themes/MyFairLady/source/fonts/cathsgbr.woff","hash":"153895a2d97e40a8010f30374cc0acfe73377bcd","modified":1509360831000},{"_id":"themes/MyFairLady/source/fonts/cathsgbr.ttf","hash":"b075dcfcca53f2a29a97e0a975ecbc118f5a180f","modified":1509360831000},{"_id":"themes/MyFairLady/source/fonts/cathsgbr.woff2","hash":"40245d50670ca73e00fb80856a37306988421db6","modified":1509360831000},{"_id":"themes/MyFairLady/source/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1509360831000},{"_id":"themes/MyFairLady/source/js/bookmark.js","hash":"fb1dd042753a9cebd8dbc2bfab258a62dd44cea2","modified":1509360831000},{"_id":"themes/MyFairLady/source/js/sidebar.js","hash":"aae4af964c94bd4a6e117426173082eb90f59a38","modified":1509360831000},{"_id":"themes/MyFairLady/source/js/toTop.js","hash":"8d933dbf44e7a705d68e66e20db991eeb964ead4","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/main.scss","hash":"79654cf5dfd705f87745ccb48641fc2bad1b75de","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/article.ejs","hash":"37d23d277f98664d83c1b68f6bb4ac13cd01d460","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/categories.ejs","hash":"48058ea4984637e7774307ad913ecf69fc315e5d","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/footer.ejs","hash":"0b9d3690e64efa6e084561d3bf58014b1c23011c","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/head.ejs","hash":"5ce90903492659dccbf0a22e93e88936f06cf66f","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/header.ejs","hash":"467515881a8296231599e7c6029e71f926ccc7c7","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/index.ejs","hash":"74f2dbfa32e7a97b27e9905dcd66760cb5ef29f4","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_common/animation.scss","hash":"274f428b2b5a232321ec0263707ff736770618d5","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_common/code.scss","hash":"0905d12faae592bf784356345bd69f83c1849b69","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_common/color.scss","hash":"6b32785053f01e6ea226dcf7b60e71b90b04fbca","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_common/font.scss","hash":"92dbc2247fd7f3ae007339ee56f95a36bb43993b","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_common/global.scss","hash":"51003b2aab1c7569a591b240d38239d5afc2c9e8","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_common/media.scss","hash":"8c031796dbf44ea4d27655f0bdf56c049fe7c93b","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_common/highlight.scss","hash":"57f6a47ca038d8f47a953cd336779b4b4fb64ebf","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_common/mixin.scss","hash":"afa394ccb395cf931d34484aaf9080d0e32891bb","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/about.scss","hash":"cf270dac5ca72c2f45d7654d518b5419c8bc392f","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/archives.scss","hash":"a146ffedcfa4871c07fd92b0687019a360448693","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/footer.scss","hash":"7964e84dc63769da5b02a4ca8f5b9694a2eb43b9","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/article.scss","hash":"3132f64acffda4c3f0bffb318360f98a2bb0e264","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/header.scss","hash":"543bfe040886556b9dbae6112934bc7c1fc64d68","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/index.scss","hash":"ecac5430524c8c1c14ae994102f2411b0351c845","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/mobileBar.scss","hash":"5a666656ba4ce330f310a352a2313dd1b0236b2d","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/tags.scss","hash":"a8b4aa8a98a97fc87df6e30e8c6821780c6a5ab3","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/comments/disqus.ejs","hash":"b0a84143fb86000d595af09c5c850d0890850097","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/comments/duoshuo.ejs","hash":"fc398d369815b2096632e61968a572b2370a9c4d","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/post/bookmark.ejs","hash":"b28021498f39cbb2822b528c8c95031ab7fb7a83","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/post/date.ejs","hash":"c417d063777c13a2a94afc1f97cc8f5345bdf647","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/post/nav.ejs","hash":"a0efaa07e1cbc11e76acb279ccc0c6810dec972a","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/post/paginator.ejs","hash":"1312976a675d419f60fa2d2dc5fa0b7f1f0eb011","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/post/scroll-button.ejs","hash":"dd87d0386daee5e4a7d2c88d68573f9c815d6610","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/post/sidebar.ejs","hash":"c116dfd5d7d66f3a9f601c536807c8668d69bd1f","modified":1509360831000},{"_id":"themes/MyFairLady/layout/_partial/post/tag.ejs","hash":"7246aa223c761473a423b06feeb6166e7e98f50b","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/post/bookmark.scss","hash":"cf152aa566effac830924cf3c08346a758c292b9","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/post/date.scss","hash":"02e60187b90087d6253cb153926ec45b9f41db58","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/post/heart.scss","hash":"062292d2941d13b627a8f638ab5f64961d99b462","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/post/morelink.scss","hash":"73c92461eea21ae37f7ae6300af3119ada131e99","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/post/nav.scss","hash":"578620100a0e18634b5bd3d8556fff1d353a87ef","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/post/sidebar.scss","hash":"0c1743a25f7f864554ed333d36ec948a203d1e68","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/post/paginator.scss","hash":"796364b315b156ae8e2dc3b22d3639a36edc1ae9","modified":1509360831000},{"_id":"themes/MyFairLady/source/sass/_partial/post/title.scss","hash":"e9a5e555e1c064731ec1843a3e76fd0ab55eebeb","modified":1509360831000},{"_id":"public/2017/07/08/面向对象编程的SOLID原则/index.html","hash":"b9e9362a469cc1f9e07ef6f39f3bb416d08011c6","modified":1509361047416},{"_id":"public/2017/06/23/javascript设计模式-单例模式/index.html","hash":"d276e301d8e9bd01285dd7258949ea4bbd7cad88","modified":1509361047417},{"_id":"public/2017/06/01/原来除了box-shadow,还有drop-shadow/index.html","hash":"4bc1ee032978f69ee87174ff9c5d1d0a0c22920a","modified":1509361047417},{"_id":"public/2017/06/20/React中的样式处理/index.html","hash":"1c288bdb7c0d4f4d2ee551ddc363fa7165a68509","modified":1509361047417},{"_id":"public/2017/05/20/优化webpack/index.html","hash":"73eaa537403ecc64fa6e0f20794806a994bb8b91","modified":1509361047417},{"_id":"public/2017/01/02/关于时间管理/index.html","hash":"92dc3e7a93c3bb7f77ef91c00de76ee3f4f9e366","modified":1509361047417},{"_id":"public/2016/12/01/浏览器渲染性能分析与优化/index.html","hash":"78ce62855fc1ee2eae74c1f4ae47a3868b1e2156","modified":1509361047417},{"_id":"public/2016/10/01/在创业公司实习的三个月/index.html","hash":"9e93042fb397e9593b0efce1d46e399dbfe7111c","modified":1509361047417},{"_id":"public/2016/09/30/走在人生的夜路上/index.html","hash":"6264a1fc37c79d6b25c571e31b3bd72e8fe635ba","modified":1509361047417},{"_id":"public/2016/09/10/微信支付踩过的坑/index.html","hash":"af6fa8ab9812af17db60a059e7d5926cd0af96c5","modified":1509361047417},{"_id":"public/2016/08/10/CSS的BFC/index.html","hash":"fdc3051dc989c82d62b55da8d936bf264c95fa70","modified":1509361047417},{"_id":"public/2015/08/11/用Yeoman来创建我的web应用/index.html","hash":"090112cfaa3eb96a3bee8387b8ea7395c840785c","modified":1509361047417},{"_id":"public/2015/08/11/bower入门/index.html","hash":"b4a552d34e02b5c662b481f0894a0d5ed605503f","modified":1509361047417},{"_id":"public/archives/index.html","hash":"27ed773d3d95c35c37c6c898eec5b1f4fae77293","modified":1509361047417},{"_id":"public/archives/page/2/index.html","hash":"a0b2762f4ee25ad81163d2ff53c9d7cc6ca1b966","modified":1509361047417},{"_id":"public/archives/page/3/index.html","hash":"ad462082b633869718d7d836919a4a1509fbc102","modified":1509361047417},{"_id":"public/archives/2015/index.html","hash":"f6b25cfe996b640f31c2d3196742b3bd58781b85","modified":1509361047417},{"_id":"public/archives/2015/08/index.html","hash":"738340db439df3bc3d60c91d6ee3bd36e508f99e","modified":1509361047417},{"_id":"public/archives/2016/index.html","hash":"007d53956696cd2fc80042830c560ff84646fb85","modified":1509361047418},{"_id":"public/archives/2016/page/2/index.html","hash":"eebd7e9cc5b242056510160f805e3c6a3c42a07e","modified":1509361047418},{"_id":"public/archives/2016/08/index.html","hash":"e94cf94813028c427124f5e61469994874485ca7","modified":1509361047418},{"_id":"public/archives/2016/09/index.html","hash":"0538f127977790a8874b60b24324cef669e44769","modified":1509361047418},{"_id":"public/archives/2016/10/index.html","hash":"32da7b312e41a468c41162e6ee5ea89dc6a6304b","modified":1509361047418},{"_id":"public/archives/2016/12/index.html","hash":"ae605b7f25711ddc500bd528260be936e1ea87f6","modified":1509361047418},{"_id":"public/archives/2017/index.html","hash":"c056fabb22d8b579eead487a19157f5efdb39812","modified":1509361047419},{"_id":"public/archives/2017/01/index.html","hash":"85fa79d06c6822f1dd3a8fa459a5dadd29c8c79f","modified":1509361047419},{"_id":"public/archives/2017/04/index.html","hash":"3209d425da291a63c1085d531b5bfa0b0b83d635","modified":1509361047419},{"_id":"public/archives/2017/05/index.html","hash":"df226b6530ece77b547dfd491e3f294780f50687","modified":1509361047419},{"_id":"public/archives/2017/06/index.html","hash":"fa2ef8f48b5d1d265e41a1e06fed3dffaeb9bc0f","modified":1509361047419},{"_id":"public/archives/2017/07/index.html","hash":"c3d90956e793d5c65c7c6d598119945058ad15ec","modified":1509361047419},{"_id":"public/index.html","hash":"c89425c9d1a53bbc42dab03c2519513154cdc412","modified":1509361047419},{"_id":"public/page/2/index.html","hash":"e7458c3945bb92515537d491de5344460d0b40de","modified":1509361047419},{"_id":"public/page/3/index.html","hash":"b14a5f92de1c705ec74f5d36898057a1a5038842","modified":1509361047419},{"_id":"public/tags/CSS/index.html","hash":"7207bb68f74925aabe763c6b73926629d4bbf794","modified":1509361047419},{"_id":"public/tags/前端框架/index.html","hash":"558f02bac03b44e07b103f3ae2d7e8a2fb3d6b4c","modified":1509361047420},{"_id":"public/tags/前端工具/index.html","hash":"0ec49ec9f2de31c3fff5f8d327b7f971f36cd938","modified":1509361047420},{"_id":"public/tags/设计模式/index.html","hash":"ba174e0039fca5d31d090741c51ba6f4366d0ca4","modified":1509361047420},{"_id":"public/tags/杂谈/index.html","hash":"3d5ce1f221413c52928b964a1b7c250297dd294f","modified":1509361047420},{"_id":"public/tags/实战总结/index.html","hash":"c6115386071f42bf7ebc1154fd43c789bb17d549","modified":1509361047420},{"_id":"public/tags/前端性能/index.html","hash":"b47a9bd5ce8d4bb64a3cf396bbaf139ae9f04cb5","modified":1509361047420},{"_id":"public/2017/07/10/策略模式/index.html","hash":"a8e576831353e88b019c11ff8b96e9ba006d5842","modified":1509361047420},{"_id":"public/2017/06/23/状态模式/index.html","hash":"039f362ca6aef49a3ad9841ddcc7d21f80b3dbb7","modified":1509361047420},{"_id":"public/2017/06/23/javascript设计模式-原型模式/index.html","hash":"40ae3ce0678c15bb4968e42ff5ed27ad37a4227b","modified":1509361047420},{"_id":"public/2017/04/01/项目总结-wps/index.html","hash":"c067fb713e3eddcb548b1cb794a1956db27dfd66","modified":1509361047420},{"_id":"public/2016/12/01/浏览器渲染过程学习总结/index.html","hash":"53b583b720d8b9531fc6f8b25b28c01f138c8493","modified":1509361047420},{"_id":"public/2016/09/11/angularJS初体验/index.html","hash":"7d3152a908d2758e84ea88a6f961e2b91a2acd33","modified":1509361047421},{"_id":"public/2016/08/24/前端工程化-gulp应用篇2/index.html","hash":"75f7e3b1bd444553d96e53be8f02598fcffb7480","modified":1509361047421},{"_id":"public/2016/08/23/前端工程化-gulp应用篇1/index.html","hash":"9cfa481e37c7c03dada1e7af7a04ebead6a23fdf","modified":1509361047421},{"_id":"public/2016/08/11/CSS-盒模型和视觉格式化上下文/index.html","hash":"8e27bfe48faa7500eff69a1eff1c95e1a3ea37bf","modified":1509361047421},{"_id":"public/2016/08/11/CSS定位那些事儿/index.html","hash":"5c616e27ef930b365961f5a58f828d6932b79f85","modified":1509361047421},{"_id":"public/fonts/cathsgbr.eot","hash":"f8a4f4f444e5bc1f5b74e8f09ee071aee6434afc","modified":1509361047426},{"_id":"public/CNAME","hash":"64b9e73555e0c77313d196dbb3a674e97b3abc4a","modified":1509361047426},{"_id":"public/fonts/cathsgbr.svg","hash":"196688f0dcbb0f916090b9fd70760ba97ce38ed0","modified":1509361047426},{"_id":"public/fonts/cathsgbr.woff","hash":"153895a2d97e40a8010f30374cc0acfe73377bcd","modified":1509361047427},{"_id":"public/fonts/cathsgbr.ttf","hash":"b075dcfcca53f2a29a97e0a975ecbc118f5a180f","modified":1509361047427},{"_id":"public/fonts/cathsgbr.woff2","hash":"40245d50670ca73e00fb80856a37306988421db6","modified":1509361047427},{"_id":"public/images/menu.png","hash":"bdaa35eb1ed119caeb934e15a05b9f4a5396d957","modified":1509361047427},{"_id":"public/js/sidebar.js","hash":"bc9b46f65ae230c3bff7885f15170ebbd86c5f1e","modified":1509361047442},{"_id":"public/js/bookmark.js","hash":"fb1dd042753a9cebd8dbc2bfab258a62dd44cea2","modified":1509361047442},{"_id":"public/js/toTop.js","hash":"8d933dbf44e7a705d68e66e20db991eeb964ead4","modified":1509361047442},{"_id":"public/sass/main.css","hash":"cf811fec96c7270bb593653dff7c7ea85a58c568","modified":1509361047527},{"_id":"source/.DS_Store","hash":"e8095c500ca8c26ac3de3e1d47fef94960455496","modified":1509361016000}],"Category":[],"Data":[],"Page":[],"Post":[{"title":"CSS-盒模型和视觉格式化上下文","date":"2016-08-11T15:13:58.000Z","_content":"\n我知道好多人，包括以前的自己，都对CSS侧目以待。不就是选择器和一些样式嘛，给我半天的时间就能学会啦。对于css的使用，的确看看W3Cschool可能一下子就会了。但是当实际做项目的时候，你不知道为什么有时候给一些元素设置了宽，高值却不生效；不知道为什么两个inline-block的元素在并排在一起，它们却不是从同一高度开始渲染；不知道给一些设置了vertical-align：middle却不能实现垂直居中…此时此刻，才发现要精通CSS，并没有想象中的那么容易。所以，回到原点，一切从头开始吧!\n\n## CSS基础概念一：CSS盒模型\n\n> 浏览器展示一个元素时，这个元素会占据一定的空间。这个空间就是CSS的盒模型，它由四部分组成：呈现内容的content，内边距，边框和外边距。\n\n[![img](http://w3help.org/zh-cn/kb/006/006/boxdim.png)](http://w3help.org/zh-cn/kb/006/006/boxdim.png)\n\n上图所示的就是一个盒子模型（也称框模型）的庐山真面目。其中padding，border和margin都有top、right、left和bottom四部分。\n\n#### 与之相关的CSS特性：\n\n##### margin\n\n1. margin可以应用到的元素有非table类型的元素，以及table类型中的table-caption，table和inline-table这三类的元素。对于td，tr，th，margin是不适用的，并且，对于行内非替换元素（如span），垂直的margin不起作用。\n2. 垂直方向上的不同元素的相邻的margin在某些情况下，会发生折叠现象。（外边距折叠也是一个可以说来话长的故事）\n3. margin可以为负。（这个特性的作用不小呢）\n\n##### padding\n\n1. 可以应用到的元素：除display的值是‘table-row-group’,’table-header-group’,’table-footer-group’, ‘table-row’， ‘table-column-group’ 和 ’table-column’ 的所有元素。\n\n##### border\n\nborder可以设置其border-width，border-color和border-style。它适用于任何元素。\n\n##### 容易被忽略的坑\n\n在CSS中，设置的wdith和height指的是内容区域（即content）的宽度和高度。增加内边距、边框和外边距不影响内容区域的尺寸，但是会增加元素框的尺寸。在进行页面布局的时候，我们考虑的应该是元素框的尺寸。\n\n盒子模型有两种标准。第一种是我们正常渲染模式下采用的W3C标准盒子模型。第二种是怪异模式下采用的IE盒子模型。它们的区别如下：\n[![img](https://segmentfault.com/img/bVtyKC)](https://segmentfault.com/img/bVtyKC)\n[![img](https://segmentfault.com/img/bVtyKz)](https://segmentfault.com/img/bVtyKz)\nIE盒子模型会把padding和border算入元素的width和height。于是会导致元素框的大小看起来比实际的要小。（在使用IE盒子模型下试试给固定宽高的元素增加padding值，你就知道是怎么一回事了）\n\nCSS3的box-sizing属性，让我们可以自行决定采用哪种盒子。\n\n> box-sizing:content-box|border-box|inherit\n> content-box——默认值，采用Standard box model\n> border-box——采用IE box model\n> inherit——继承父元素属性值\n\n## CSS基本概念二：视觉格式化模型（visual formatiing modal）\n\n上面所说的盒子模型是CSS的基础，之所以这么说是因为html里面的标签被浏览器解析后会生成元素，各元素被添加到docuemnt dom tree，但是CSS作用的不是元素，而是盒子，在页面渲染的过程，css在document dom tree的基础上会生成render tree，盒子模型就是render tree的节点。\n\n> CSS 视觉格式化模型(visual formatting model)是用来处理文档并将它显示在视觉媒体上的机制。这是 CSS 的一个基础概念。 视觉格式化模型根据 CSS 盒模型为文档的每个元素生成 0，1 或多个盒。它也是 CSS 布局的核心，通过它，框( box )可以获得应有的尺寸，放到需要的位置。\n\n咦？！还存在一个元素生成多个盒的情况？\n有的，**li** 除了生成主要块级盒外还会生成一个额外的盒来放置它的项目符号。但是其实大多数元素都只生成一个盒子。\n\n#### 影响布局的因素\n\n- **盒子的类型和尺寸**：元素的display属性决定了盒子的类型，下面会详讲。\n- **定位体系**：盒子在布局时，会根据三种定位体系（定位方案）定位（常规流/浮动/绝对定位）\n- **文档树中元素之间的关系**：比如，一个块元素包含两个互为兄弟节点的浮动元素，后面那个浮动元素的布局，会受前面元素以及它包含块3的影响。\n- **外部信息**：可视窗口的大小对布局有影响、图片的固有尺寸会影响行内替换元素的尺寸进而影响布局\n\n### 包含块（Containing block）\n\n> 在 CSS2.1 中，很多框的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )。\n\n一个盒子相对于它的包含块的边界来渲染。但是盒子并不受它的包含块的限制，当它的布局跑到包含块的外面称为溢出（overflow）.\n\n通常盒为它的后代元素建立包含块。但父元素就是子元素的包含块吗？答案是否地的。包含块有一个判断标准，因为说来话长，只能上一张包含块判定的总流程图了（希望伙伴们不要被吓到）：\n[![img](http://w3help.org/zh-cn/kb/008/008/CB4.png)](http://w3help.org/zh-cn/kb/008/008/CB4.png)\n\n- 根元素存在的包含块，被叫做初始包含块 (initial containing block)。具体，跟用户端有关。\n- 如果元素的定位（position）为 “relative” （相对定位）或者 “static”（静态定位），它的包含块由它最近的块级、单元格（table cell）或者行内块（inline-block）祖先元素的 内容框1创建。\n  *如果元素是固定定位 (“position:fixed”) 元素，那么它的包含块是当前可视窗口\n- 绝对定位（”position: absolute”）元素的包含块由离它最近的 ‘position’ 属性为 ‘absolute’、’relative’ 或者 ‘fixed’ 的祖先元素创建。如果其祖先元素是行内元素，则包含块取决于其祖先元素的 ‘direction’ 特性：\n  - 如果 ‘direction’ 是 ‘ltr’，包含块的顶、左边是祖先元素生成的第一个框的顶、左内边距边界(padding edges) ，右、下边是祖先元素生成的最后一个框的右、下内边距边界(padding edges)\n  - 如果 ‘direction’ 是 ‘rtl’，包含块的顶、右边是祖先元素生成的第一个框的顶、右内边距边界 (padding edges) ，左、下边是祖先元素生成的最后一个框的左、下内边距边界 (padding edges)\n\n详细的说明可以看[W3help关于包含块的这篇文章](http://w3help.org/zh-cn/kb/008/)\n\n### 盒子的生成\n\n从文档元素生成盒子是CSS视觉格式化模型的一部分工作。display属性决定了生成盒的类型，不同类型的盒子，视觉格式化模型对它的处理也不同。\n\n#### 块级元素与块盒\n\n- display为block，list-item或table的元素是块级元素，它们在视觉呈现为独占一行的块，竖直排列。每个块级元素至少生成一个主要块级盒，且这个盒子可以参与任一一种定位方案。\n- 块级盒会参与BFC(块级格式化上下文)。\n- 除了table盒子和替换元素，一个块级盒子一般也是一个块容器盒。\n- 块容器盒要么只包含块级盒，要么只包含创建了IFC（行内格式化上下文）的行内级盒。\n- 块级盒不一定是块容器盒（如table），块容器盒也不一定是块级盒（如非替换的inline blocks和非替换的table cells）。既是块级盒又是块容器盒的称为块盒。\n- （块级盒侧重描述了元素和它的父元素及兄弟元素之间的表现，块容器盒侧重描述元素跟它的后代元素之间的影响）\n  [![img](http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/block-box.png)](http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/block-box.png)\n\n**匿名块盒**\n\n```\n<div>Some inline text \n<p>followed by a paragraph</p> \n    followed by more inline text.\n</div>\n\n```\n\n其中`Some inline text`和`followed by more inline text.`会各自被匿名块盒所包含。匿名块盒不能被CSS 选择符选中（即所有可继承的 CSS 属性值为 inherit ，所有非继承的 CSS 属性值为 initial）。\n\n创建匿名块盒的情况有两种：\n\n1. 块容器盒同时包含行内级盒和块级盒时，将创建匿名块盒来包含毗邻的行内级盒。即上面的例子。\n\n2. 一个行内盒包含了一个或者几个块盒，包含块盒的盒将拆分为两个行内盒放置于块盒前后，然后分别由两个匿名块盒包含。\n\n   ```\n   <p style=\"display:inline;border=1px solid gray\">\n   This is anonymous text before the SPAN。\n   <span style=\"display:block\">This is the content of SPAN.</span>\n   This is anonymous text after the SPAN。\n   </p>\n\n   ```\n\n效果：\n[![img](https://github.com/dolymood/blog/raw/master/pics/001.png)](https://github.com/dolymood/blog/raw/master/pics/001.png)\n\n### 行内级元素和行内盒\n\n- display为inline，inline-block和inline-table的元素为行内级元素。视觉上它与其它行内级元素水平排列，比如input，img等。\n- 行内级元素生成行内级盒，参与IFC（行内格式化上下文）。\n- 参与生成IFC的行内级盒为行内盒。而不参与生成IFC的行内级盒为原子行内级盒。\n- 所有display为inline的非替换元素生成的盒都是行内盒。\n- 可替换行内元素或display为inline-block或inline-table的元素生成的是原子行内级盒。原子行内级盒在行内格式化上下文里不能分成多行。\n  [![img](http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/inline-box.png)](http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/inline-box.png)\n\n**匿名行盒**\n类似于块盒，CSS 引擎有时自动生成行内盒。\n产生匿名行内盒的情况是块盒直接包含文本，文本将包含在匿名行内盒中。空白如果使用white-space 去掉，则不会生成匿名行内盒。\n\n**行盒**\n行盒由行内格式化上下文(inline formatting context)产生的盒，用于表示一行。\n\n最后附上一个display属性：不妨结合上面的知识思考一下不同值的display可以生成什么盒子？\n\n> display\n> 值： inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit\n\n一旦盒生成了， CSS 引擎要指定它们的位置，这时会用到不同的定位方案。\n定位方案就留到下一篇文章再谈吧。因为我..好饿..咕..感谢能够耐心看到最后的人。\n\n参考文献：\n[MDN-视觉格式化上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model)\n[css可视化模型-dolymood的博客](http://blog.aijc.net/css/2014/08/06/CSS%20%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B%EF%BC%88Visual%20formatting%20model%EF%BC%89/)\n[CSS魔法堂-重新认识Box Model..](https://segmentfault.com/a/1190000004625635#articleHeader11)\n[KB007：可视化格式化模型](http://w3help.org/zh-cn/kb/007/)\n[KB006: CSS 框模型( Box module )](http://w3help.org/zh-cn/kb/006/)\n[KB008: 包含块( Containing block )](http://w3help.org/zh-cn/kb/008/)\n[CSS2 BFC模型和IFC模型](http://www.yangyong.me/css2-bfc%E6%A8%A1%E5%9E%8B%E5%92%8Cifc%E6%A8%A1%E5%9E%8B/)","source":"_posts/CSS-盒模型和视觉格式化上下文.md","raw":"---\ntitle: CSS-盒模型和视觉格式化上下文\ndate: 2016-08-11 23:13:58\ntags: CSS\n---\n\n我知道好多人，包括以前的自己，都对CSS侧目以待。不就是选择器和一些样式嘛，给我半天的时间就能学会啦。对于css的使用，的确看看W3Cschool可能一下子就会了。但是当实际做项目的时候，你不知道为什么有时候给一些元素设置了宽，高值却不生效；不知道为什么两个inline-block的元素在并排在一起，它们却不是从同一高度开始渲染；不知道给一些设置了vertical-align：middle却不能实现垂直居中…此时此刻，才发现要精通CSS，并没有想象中的那么容易。所以，回到原点，一切从头开始吧!\n\n## CSS基础概念一：CSS盒模型\n\n> 浏览器展示一个元素时，这个元素会占据一定的空间。这个空间就是CSS的盒模型，它由四部分组成：呈现内容的content，内边距，边框和外边距。\n\n[![img](http://w3help.org/zh-cn/kb/006/006/boxdim.png)](http://w3help.org/zh-cn/kb/006/006/boxdim.png)\n\n上图所示的就是一个盒子模型（也称框模型）的庐山真面目。其中padding，border和margin都有top、right、left和bottom四部分。\n\n#### 与之相关的CSS特性：\n\n##### margin\n\n1. margin可以应用到的元素有非table类型的元素，以及table类型中的table-caption，table和inline-table这三类的元素。对于td，tr，th，margin是不适用的，并且，对于行内非替换元素（如span），垂直的margin不起作用。\n2. 垂直方向上的不同元素的相邻的margin在某些情况下，会发生折叠现象。（外边距折叠也是一个可以说来话长的故事）\n3. margin可以为负。（这个特性的作用不小呢）\n\n##### padding\n\n1. 可以应用到的元素：除display的值是‘table-row-group’,’table-header-group’,’table-footer-group’, ‘table-row’， ‘table-column-group’ 和 ’table-column’ 的所有元素。\n\n##### border\n\nborder可以设置其border-width，border-color和border-style。它适用于任何元素。\n\n##### 容易被忽略的坑\n\n在CSS中，设置的wdith和height指的是内容区域（即content）的宽度和高度。增加内边距、边框和外边距不影响内容区域的尺寸，但是会增加元素框的尺寸。在进行页面布局的时候，我们考虑的应该是元素框的尺寸。\n\n盒子模型有两种标准。第一种是我们正常渲染模式下采用的W3C标准盒子模型。第二种是怪异模式下采用的IE盒子模型。它们的区别如下：\n[![img](https://segmentfault.com/img/bVtyKC)](https://segmentfault.com/img/bVtyKC)\n[![img](https://segmentfault.com/img/bVtyKz)](https://segmentfault.com/img/bVtyKz)\nIE盒子模型会把padding和border算入元素的width和height。于是会导致元素框的大小看起来比实际的要小。（在使用IE盒子模型下试试给固定宽高的元素增加padding值，你就知道是怎么一回事了）\n\nCSS3的box-sizing属性，让我们可以自行决定采用哪种盒子。\n\n> box-sizing:content-box|border-box|inherit\n> content-box——默认值，采用Standard box model\n> border-box——采用IE box model\n> inherit——继承父元素属性值\n\n## CSS基本概念二：视觉格式化模型（visual formatiing modal）\n\n上面所说的盒子模型是CSS的基础，之所以这么说是因为html里面的标签被浏览器解析后会生成元素，各元素被添加到docuemnt dom tree，但是CSS作用的不是元素，而是盒子，在页面渲染的过程，css在document dom tree的基础上会生成render tree，盒子模型就是render tree的节点。\n\n> CSS 视觉格式化模型(visual formatting model)是用来处理文档并将它显示在视觉媒体上的机制。这是 CSS 的一个基础概念。 视觉格式化模型根据 CSS 盒模型为文档的每个元素生成 0，1 或多个盒。它也是 CSS 布局的核心，通过它，框( box )可以获得应有的尺寸，放到需要的位置。\n\n咦？！还存在一个元素生成多个盒的情况？\n有的，**li** 除了生成主要块级盒外还会生成一个额外的盒来放置它的项目符号。但是其实大多数元素都只生成一个盒子。\n\n#### 影响布局的因素\n\n- **盒子的类型和尺寸**：元素的display属性决定了盒子的类型，下面会详讲。\n- **定位体系**：盒子在布局时，会根据三种定位体系（定位方案）定位（常规流/浮动/绝对定位）\n- **文档树中元素之间的关系**：比如，一个块元素包含两个互为兄弟节点的浮动元素，后面那个浮动元素的布局，会受前面元素以及它包含块3的影响。\n- **外部信息**：可视窗口的大小对布局有影响、图片的固有尺寸会影响行内替换元素的尺寸进而影响布局\n\n### 包含块（Containing block）\n\n> 在 CSS2.1 中，很多框的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )。\n\n一个盒子相对于它的包含块的边界来渲染。但是盒子并不受它的包含块的限制，当它的布局跑到包含块的外面称为溢出（overflow）.\n\n通常盒为它的后代元素建立包含块。但父元素就是子元素的包含块吗？答案是否地的。包含块有一个判断标准，因为说来话长，只能上一张包含块判定的总流程图了（希望伙伴们不要被吓到）：\n[![img](http://w3help.org/zh-cn/kb/008/008/CB4.png)](http://w3help.org/zh-cn/kb/008/008/CB4.png)\n\n- 根元素存在的包含块，被叫做初始包含块 (initial containing block)。具体，跟用户端有关。\n- 如果元素的定位（position）为 “relative” （相对定位）或者 “static”（静态定位），它的包含块由它最近的块级、单元格（table cell）或者行内块（inline-block）祖先元素的 内容框1创建。\n  *如果元素是固定定位 (“position:fixed”) 元素，那么它的包含块是当前可视窗口\n- 绝对定位（”position: absolute”）元素的包含块由离它最近的 ‘position’ 属性为 ‘absolute’、’relative’ 或者 ‘fixed’ 的祖先元素创建。如果其祖先元素是行内元素，则包含块取决于其祖先元素的 ‘direction’ 特性：\n  - 如果 ‘direction’ 是 ‘ltr’，包含块的顶、左边是祖先元素生成的第一个框的顶、左内边距边界(padding edges) ，右、下边是祖先元素生成的最后一个框的右、下内边距边界(padding edges)\n  - 如果 ‘direction’ 是 ‘rtl’，包含块的顶、右边是祖先元素生成的第一个框的顶、右内边距边界 (padding edges) ，左、下边是祖先元素生成的最后一个框的左、下内边距边界 (padding edges)\n\n详细的说明可以看[W3help关于包含块的这篇文章](http://w3help.org/zh-cn/kb/008/)\n\n### 盒子的生成\n\n从文档元素生成盒子是CSS视觉格式化模型的一部分工作。display属性决定了生成盒的类型，不同类型的盒子，视觉格式化模型对它的处理也不同。\n\n#### 块级元素与块盒\n\n- display为block，list-item或table的元素是块级元素，它们在视觉呈现为独占一行的块，竖直排列。每个块级元素至少生成一个主要块级盒，且这个盒子可以参与任一一种定位方案。\n- 块级盒会参与BFC(块级格式化上下文)。\n- 除了table盒子和替换元素，一个块级盒子一般也是一个块容器盒。\n- 块容器盒要么只包含块级盒，要么只包含创建了IFC（行内格式化上下文）的行内级盒。\n- 块级盒不一定是块容器盒（如table），块容器盒也不一定是块级盒（如非替换的inline blocks和非替换的table cells）。既是块级盒又是块容器盒的称为块盒。\n- （块级盒侧重描述了元素和它的父元素及兄弟元素之间的表现，块容器盒侧重描述元素跟它的后代元素之间的影响）\n  [![img](http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/block-box.png)](http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/block-box.png)\n\n**匿名块盒**\n\n```\n<div>Some inline text \n<p>followed by a paragraph</p> \n    followed by more inline text.\n</div>\n\n```\n\n其中`Some inline text`和`followed by more inline text.`会各自被匿名块盒所包含。匿名块盒不能被CSS 选择符选中（即所有可继承的 CSS 属性值为 inherit ，所有非继承的 CSS 属性值为 initial）。\n\n创建匿名块盒的情况有两种：\n\n1. 块容器盒同时包含行内级盒和块级盒时，将创建匿名块盒来包含毗邻的行内级盒。即上面的例子。\n\n2. 一个行内盒包含了一个或者几个块盒，包含块盒的盒将拆分为两个行内盒放置于块盒前后，然后分别由两个匿名块盒包含。\n\n   ```\n   <p style=\"display:inline;border=1px solid gray\">\n   This is anonymous text before the SPAN。\n   <span style=\"display:block\">This is the content of SPAN.</span>\n   This is anonymous text after the SPAN。\n   </p>\n\n   ```\n\n效果：\n[![img](https://github.com/dolymood/blog/raw/master/pics/001.png)](https://github.com/dolymood/blog/raw/master/pics/001.png)\n\n### 行内级元素和行内盒\n\n- display为inline，inline-block和inline-table的元素为行内级元素。视觉上它与其它行内级元素水平排列，比如input，img等。\n- 行内级元素生成行内级盒，参与IFC（行内格式化上下文）。\n- 参与生成IFC的行内级盒为行内盒。而不参与生成IFC的行内级盒为原子行内级盒。\n- 所有display为inline的非替换元素生成的盒都是行内盒。\n- 可替换行内元素或display为inline-block或inline-table的元素生成的是原子行内级盒。原子行内级盒在行内格式化上下文里不能分成多行。\n  [![img](http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/inline-box.png)](http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/inline-box.png)\n\n**匿名行盒**\n类似于块盒，CSS 引擎有时自动生成行内盒。\n产生匿名行内盒的情况是块盒直接包含文本，文本将包含在匿名行内盒中。空白如果使用white-space 去掉，则不会生成匿名行内盒。\n\n**行盒**\n行盒由行内格式化上下文(inline formatting context)产生的盒，用于表示一行。\n\n最后附上一个display属性：不妨结合上面的知识思考一下不同值的display可以生成什么盒子？\n\n> display\n> 值： inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit\n\n一旦盒生成了， CSS 引擎要指定它们的位置，这时会用到不同的定位方案。\n定位方案就留到下一篇文章再谈吧。因为我..好饿..咕..感谢能够耐心看到最后的人。\n\n参考文献：\n[MDN-视觉格式化上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model)\n[css可视化模型-dolymood的博客](http://blog.aijc.net/css/2014/08/06/CSS%20%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B%EF%BC%88Visual%20formatting%20model%EF%BC%89/)\n[CSS魔法堂-重新认识Box Model..](https://segmentfault.com/a/1190000004625635#articleHeader11)\n[KB007：可视化格式化模型](http://w3help.org/zh-cn/kb/007/)\n[KB006: CSS 框模型( Box module )](http://w3help.org/zh-cn/kb/006/)\n[KB008: 包含块( Containing block )](http://w3help.org/zh-cn/kb/008/)\n[CSS2 BFC模型和IFC模型](http://www.yangyong.me/css2-bfc%E6%A8%A1%E5%9E%8B%E5%92%8Cifc%E6%A8%A1%E5%9E%8B/)","slug":"CSS-盒模型和视觉格式化上下文","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwme0000cgespnmuvpxs","content":"<p>我知道好多人，包括以前的自己，都对CSS侧目以待。不就是选择器和一些样式嘛，给我半天的时间就能学会啦。对于css的使用，的确看看W3Cschool可能一下子就会了。但是当实际做项目的时候，你不知道为什么有时候给一些元素设置了宽，高值却不生效；不知道为什么两个inline-block的元素在并排在一起，它们却不是从同一高度开始渲染；不知道给一些设置了vertical-align：middle却不能实现垂直居中…此时此刻，才发现要精通CSS，并没有想象中的那么容易。所以，回到原点，一切从头开始吧!</p>\n<h2 id=\"CSS基础概念一：CSS盒模型\"><a href=\"#CSS基础概念一：CSS盒模型\" class=\"headerlink\" title=\"CSS基础概念一：CSS盒模型\"></a>CSS基础概念一：CSS盒模型</h2><blockquote>\n<p>浏览器展示一个元素时，这个元素会占据一定的空间。这个空间就是CSS的盒模型，它由四部分组成：呈现内容的content，内边距，边框和外边距。</p>\n</blockquote>\n<p><a href=\"http://w3help.org/zh-cn/kb/006/006/boxdim.png\" target=\"_blank\" rel=\"external\"><img src=\"http://w3help.org/zh-cn/kb/006/006/boxdim.png\" alt=\"img\"></a></p>\n<p>上图所示的就是一个盒子模型（也称框模型）的庐山真面目。其中padding，border和margin都有top、right、left和bottom四部分。</p>\n<h4 id=\"与之相关的CSS特性：\"><a href=\"#与之相关的CSS特性：\" class=\"headerlink\" title=\"与之相关的CSS特性：\"></a>与之相关的CSS特性：</h4><h5 id=\"margin\"><a href=\"#margin\" class=\"headerlink\" title=\"margin\"></a>margin</h5><ol>\n<li>margin可以应用到的元素有非table类型的元素，以及table类型中的table-caption，table和inline-table这三类的元素。对于td，tr，th，margin是不适用的，并且，对于行内非替换元素（如span），垂直的margin不起作用。</li>\n<li>垂直方向上的不同元素的相邻的margin在某些情况下，会发生折叠现象。（外边距折叠也是一个可以说来话长的故事）</li>\n<li>margin可以为负。（这个特性的作用不小呢）</li>\n</ol>\n<h5 id=\"padding\"><a href=\"#padding\" class=\"headerlink\" title=\"padding\"></a>padding</h5><ol>\n<li>可以应用到的元素：除display的值是‘table-row-group’,’table-header-group’,’table-footer-group’, ‘table-row’， ‘table-column-group’ 和 ’table-column’ 的所有元素。</li>\n</ol>\n<h5 id=\"border\"><a href=\"#border\" class=\"headerlink\" title=\"border\"></a>border</h5><p>border可以设置其border-width，border-color和border-style。它适用于任何元素。</p>\n<h5 id=\"容易被忽略的坑\"><a href=\"#容易被忽略的坑\" class=\"headerlink\" title=\"容易被忽略的坑\"></a>容易被忽略的坑</h5><p>在CSS中，设置的wdith和height指的是内容区域（即content）的宽度和高度。增加内边距、边框和外边距不影响内容区域的尺寸，但是会增加元素框的尺寸。在进行页面布局的时候，我们考虑的应该是元素框的尺寸。</p>\n<p>盒子模型有两种标准。第一种是我们正常渲染模式下采用的W3C标准盒子模型。第二种是怪异模式下采用的IE盒子模型。它们的区别如下：<br><a href=\"https://segmentfault.com/img/bVtyKC\" target=\"_blank\" rel=\"external\"><img src=\"https://segmentfault.com/img/bVtyKC\" alt=\"img\"></a><br><a href=\"https://segmentfault.com/img/bVtyKz\" target=\"_blank\" rel=\"external\"><img src=\"https://segmentfault.com/img/bVtyKz\" alt=\"img\"></a><br>IE盒子模型会把padding和border算入元素的width和height。于是会导致元素框的大小看起来比实际的要小。（在使用IE盒子模型下试试给固定宽高的元素增加padding值，你就知道是怎么一回事了）</p>\n<p>CSS3的box-sizing属性，让我们可以自行决定采用哪种盒子。</p>\n<blockquote>\n<p>box-sizing:content-box|border-box|inherit<br>content-box——默认值，采用Standard box model<br>border-box——采用IE box model<br>inherit——继承父元素属性值</p>\n</blockquote>\n<h2 id=\"CSS基本概念二：视觉格式化模型（visual-formatiing-modal）\"><a href=\"#CSS基本概念二：视觉格式化模型（visual-formatiing-modal）\" class=\"headerlink\" title=\"CSS基本概念二：视觉格式化模型（visual formatiing modal）\"></a>CSS基本概念二：视觉格式化模型（visual formatiing modal）</h2><p>上面所说的盒子模型是CSS的基础，之所以这么说是因为html里面的标签被浏览器解析后会生成元素，各元素被添加到docuemnt dom tree，但是CSS作用的不是元素，而是盒子，在页面渲染的过程，css在document dom tree的基础上会生成render tree，盒子模型就是render tree的节点。</p>\n<blockquote>\n<p>CSS 视觉格式化模型(visual formatting model)是用来处理文档并将它显示在视觉媒体上的机制。这是 CSS 的一个基础概念。 视觉格式化模型根据 CSS 盒模型为文档的每个元素生成 0，1 或多个盒。它也是 CSS 布局的核心，通过它，框( box )可以获得应有的尺寸，放到需要的位置。</p>\n</blockquote>\n<p>咦？！还存在一个元素生成多个盒的情况？<br>有的，<strong>li</strong> 除了生成主要块级盒外还会生成一个额外的盒来放置它的项目符号。但是其实大多数元素都只生成一个盒子。</p>\n<h4 id=\"影响布局的因素\"><a href=\"#影响布局的因素\" class=\"headerlink\" title=\"影响布局的因素\"></a>影响布局的因素</h4><ul>\n<li><strong>盒子的类型和尺寸</strong>：元素的display属性决定了盒子的类型，下面会详讲。</li>\n<li><strong>定位体系</strong>：盒子在布局时，会根据三种定位体系（定位方案）定位（常规流/浮动/绝对定位）</li>\n<li><strong>文档树中元素之间的关系</strong>：比如，一个块元素包含两个互为兄弟节点的浮动元素，后面那个浮动元素的布局，会受前面元素以及它包含块3的影响。</li>\n<li><strong>外部信息</strong>：可视窗口的大小对布局有影响、图片的固有尺寸会影响行内替换元素的尺寸进而影响布局</li>\n</ul>\n<h3 id=\"包含块（Containing-block）\"><a href=\"#包含块（Containing-block）\" class=\"headerlink\" title=\"包含块（Containing block）\"></a>包含块（Containing block）</h3><blockquote>\n<p>在 CSS2.1 中，很多框的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )。</p>\n</blockquote>\n<p>一个盒子相对于它的包含块的边界来渲染。但是盒子并不受它的包含块的限制，当它的布局跑到包含块的外面称为溢出（overflow）.</p>\n<p>通常盒为它的后代元素建立包含块。但父元素就是子元素的包含块吗？答案是否地的。包含块有一个判断标准，因为说来话长，只能上一张包含块判定的总流程图了（希望伙伴们不要被吓到）：<br><a href=\"http://w3help.org/zh-cn/kb/008/008/CB4.png\" target=\"_blank\" rel=\"external\"><img src=\"http://w3help.org/zh-cn/kb/008/008/CB4.png\" alt=\"img\"></a></p>\n<ul>\n<li>根元素存在的包含块，被叫做初始包含块 (initial containing block)。具体，跟用户端有关。</li>\n<li>如果元素的定位（position）为 “relative” （相对定位）或者 “static”（静态定位），它的包含块由它最近的块级、单元格（table cell）或者行内块（inline-block）祖先元素的 内容框1创建。<br>*如果元素是固定定位 (“position:fixed”) 元素，那么它的包含块是当前可视窗口</li>\n<li>绝对定位（”position: absolute”）元素的包含块由离它最近的 ‘position’ 属性为 ‘absolute’、’relative’ 或者 ‘fixed’ 的祖先元素创建。如果其祖先元素是行内元素，则包含块取决于其祖先元素的 ‘direction’ 特性：<ul>\n<li>如果 ‘direction’ 是 ‘ltr’，包含块的顶、左边是祖先元素生成的第一个框的顶、左内边距边界(padding edges) ，右、下边是祖先元素生成的最后一个框的右、下内边距边界(padding edges)</li>\n<li>如果 ‘direction’ 是 ‘rtl’，包含块的顶、右边是祖先元素生成的第一个框的顶、右内边距边界 (padding edges) ，左、下边是祖先元素生成的最后一个框的左、下内边距边界 (padding edges)</li>\n</ul>\n</li>\n</ul>\n<p>详细的说明可以看<a href=\"http://w3help.org/zh-cn/kb/008/\" target=\"_blank\" rel=\"external\">W3help关于包含块的这篇文章</a></p>\n<h3 id=\"盒子的生成\"><a href=\"#盒子的生成\" class=\"headerlink\" title=\"盒子的生成\"></a>盒子的生成</h3><p>从文档元素生成盒子是CSS视觉格式化模型的一部分工作。display属性决定了生成盒的类型，不同类型的盒子，视觉格式化模型对它的处理也不同。</p>\n<h4 id=\"块级元素与块盒\"><a href=\"#块级元素与块盒\" class=\"headerlink\" title=\"块级元素与块盒\"></a>块级元素与块盒</h4><ul>\n<li>display为block，list-item或table的元素是块级元素，它们在视觉呈现为独占一行的块，竖直排列。每个块级元素至少生成一个主要块级盒，且这个盒子可以参与任一一种定位方案。</li>\n<li>块级盒会参与BFC(块级格式化上下文)。</li>\n<li>除了table盒子和替换元素，一个块级盒子一般也是一个块容器盒。</li>\n<li>块容器盒要么只包含块级盒，要么只包含创建了IFC（行内格式化上下文）的行内级盒。</li>\n<li>块级盒不一定是块容器盒（如table），块容器盒也不一定是块级盒（如非替换的inline blocks和非替换的table cells）。既是块级盒又是块容器盒的称为块盒。</li>\n<li>（块级盒侧重描述了元素和它的父元素及兄弟元素之间的表现，块容器盒侧重描述元素跟它的后代元素之间的影响）<br><a href=\"http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/block-box.png\" target=\"_blank\" rel=\"external\"><img src=\"http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/block-box.png\" alt=\"img\"></a></li>\n</ul>\n<p><strong>匿名块盒</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div&gt;Some inline text </div><div class=\"line\">&lt;p&gt;followed by a paragraph&lt;/p&gt; </div><div class=\"line\">    followed by more inline text.</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>其中<code>Some inline text</code>和<code>followed by more inline text.</code>会各自被匿名块盒所包含。匿名块盒不能被CSS 选择符选中（即所有可继承的 CSS 属性值为 inherit ，所有非继承的 CSS 属性值为 initial）。</p>\n<p>创建匿名块盒的情况有两种：</p>\n<ol>\n<li><p>块容器盒同时包含行内级盒和块级盒时，将创建匿名块盒来包含毗邻的行内级盒。即上面的例子。</p>\n</li>\n<li><p>一个行内盒包含了一个或者几个块盒，包含块盒的盒将拆分为两个行内盒放置于块盒前后，然后分别由两个匿名块盒包含。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p style=&quot;display:inline;border=1px solid gray&quot;&gt;</div><div class=\"line\">This is anonymous text before the SPAN。</div><div class=\"line\">&lt;span style=&quot;display:block&quot;&gt;This is the content of SPAN.&lt;/span&gt;</div><div class=\"line\">This is anonymous text after the SPAN。</div><div class=\"line\">&lt;/p&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>效果：<br><a href=\"https://github.com/dolymood/blog/raw/master/pics/001.png\" target=\"_blank\" rel=\"external\"><img src=\"https://github.com/dolymood/blog/raw/master/pics/001.png\" alt=\"img\"></a></p>\n<h3 id=\"行内级元素和行内盒\"><a href=\"#行内级元素和行内盒\" class=\"headerlink\" title=\"行内级元素和行内盒\"></a>行内级元素和行内盒</h3><ul>\n<li>display为inline，inline-block和inline-table的元素为行内级元素。视觉上它与其它行内级元素水平排列，比如input，img等。</li>\n<li>行内级元素生成行内级盒，参与IFC（行内格式化上下文）。</li>\n<li>参与生成IFC的行内级盒为行内盒。而不参与生成IFC的行内级盒为原子行内级盒。</li>\n<li>所有display为inline的非替换元素生成的盒都是行内盒。</li>\n<li>可替换行内元素或display为inline-block或inline-table的元素生成的是原子行内级盒。原子行内级盒在行内格式化上下文里不能分成多行。<br><a href=\"http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/inline-box.png\" target=\"_blank\" rel=\"external\"><img src=\"http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/inline-box.png\" alt=\"img\"></a></li>\n</ul>\n<p><strong>匿名行盒</strong><br>类似于块盒，CSS 引擎有时自动生成行内盒。<br>产生匿名行内盒的情况是块盒直接包含文本，文本将包含在匿名行内盒中。空白如果使用white-space 去掉，则不会生成匿名行内盒。</p>\n<p><strong>行盒</strong><br>行盒由行内格式化上下文(inline formatting context)产生的盒，用于表示一行。</p>\n<p>最后附上一个display属性：不妨结合上面的知识思考一下不同值的display可以生成什么盒子？</p>\n<blockquote>\n<p>display<br>值： inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit</p>\n</blockquote>\n<p>一旦盒生成了， CSS 引擎要指定它们的位置，这时会用到不同的定位方案。<br>定位方案就留到下一篇文章再谈吧。因为我..好饿..咕..感谢能够耐心看到最后的人。</p>\n<p>参考文献：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model\" target=\"_blank\" rel=\"external\">MDN-视觉格式化上下文</a><br><a href=\"http://blog.aijc.net/css/2014/08/06/CSS%20%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B%EF%BC%88Visual%20formatting%20model%EF%BC%89/\" target=\"_blank\" rel=\"external\">css可视化模型-dolymood的博客</a><br><a href=\"https://segmentfault.com/a/1190000004625635#articleHeader11\" target=\"_blank\" rel=\"external\">CSS魔法堂-重新认识Box Model..</a><br><a href=\"http://w3help.org/zh-cn/kb/007/\" target=\"_blank\" rel=\"external\">KB007：可视化格式化模型</a><br><a href=\"http://w3help.org/zh-cn/kb/006/\" target=\"_blank\" rel=\"external\">KB006: CSS 框模型( Box module )</a><br><a href=\"http://w3help.org/zh-cn/kb/008/\" target=\"_blank\" rel=\"external\">KB008: 包含块( Containing block )</a><br><a href=\"http://www.yangyong.me/css2-bfc%E6%A8%A1%E5%9E%8B%E5%92%8Cifc%E6%A8%A1%E5%9E%8B/\" target=\"_blank\" rel=\"external\">CSS2 BFC模型和IFC模型</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我知道好多人，包括以前的自己，都对CSS侧目以待。不就是选择器和一些样式嘛，给我半天的时间就能学会啦。对于css的使用，的确看看W3Cschool可能一下子就会了。但是当实际做项目的时候，你不知道为什么有时候给一些元素设置了宽，高值却不生效；不知道为什么两个inline-block的元素在并排在一起，它们却不是从同一高度开始渲染；不知道给一些设置了vertical-align：middle却不能实现垂直居中…此时此刻，才发现要精通CSS，并没有想象中的那么容易。所以，回到原点，一切从头开始吧!</p>\n<h2 id=\"CSS基础概念一：CSS盒模型\"><a href=\"#CSS基础概念一：CSS盒模型\" class=\"headerlink\" title=\"CSS基础概念一：CSS盒模型\"></a>CSS基础概念一：CSS盒模型</h2><blockquote>\n<p>浏览器展示一个元素时，这个元素会占据一定的空间。这个空间就是CSS的盒模型，它由四部分组成：呈现内容的content，内边距，边框和外边距。</p>\n</blockquote>\n<p><a href=\"http://w3help.org/zh-cn/kb/006/006/boxdim.png\" target=\"_blank\" rel=\"external\"><img src=\"http://w3help.org/zh-cn/kb/006/006/boxdim.png\" alt=\"img\"></a></p>\n<p>上图所示的就是一个盒子模型（也称框模型）的庐山真面目。其中padding，border和margin都有top、right、left和bottom四部分。</p>\n<h4 id=\"与之相关的CSS特性：\"><a href=\"#与之相关的CSS特性：\" class=\"headerlink\" title=\"与之相关的CSS特性：\"></a>与之相关的CSS特性：</h4><h5 id=\"margin\"><a href=\"#margin\" class=\"headerlink\" title=\"margin\"></a>margin</h5><ol>\n<li>margin可以应用到的元素有非table类型的元素，以及table类型中的table-caption，table和inline-table这三类的元素。对于td，tr，th，margin是不适用的，并且，对于行内非替换元素（如span），垂直的margin不起作用。</li>\n<li>垂直方向上的不同元素的相邻的margin在某些情况下，会发生折叠现象。（外边距折叠也是一个可以说来话长的故事）</li>\n<li>margin可以为负。（这个特性的作用不小呢）</li>\n</ol>\n<h5 id=\"padding\"><a href=\"#padding\" class=\"headerlink\" title=\"padding\"></a>padding</h5><ol>\n<li>可以应用到的元素：除display的值是‘table-row-group’,’table-header-group’,’table-footer-group’, ‘table-row’， ‘table-column-group’ 和 ’table-column’ 的所有元素。</li>\n</ol>\n<h5 id=\"border\"><a href=\"#border\" class=\"headerlink\" title=\"border\"></a>border</h5><p>border可以设置其border-width，border-color和border-style。它适用于任何元素。</p>\n<h5 id=\"容易被忽略的坑\"><a href=\"#容易被忽略的坑\" class=\"headerlink\" title=\"容易被忽略的坑\"></a>容易被忽略的坑</h5><p>在CSS中，设置的wdith和height指的是内容区域（即content）的宽度和高度。增加内边距、边框和外边距不影响内容区域的尺寸，但是会增加元素框的尺寸。在进行页面布局的时候，我们考虑的应该是元素框的尺寸。</p>\n<p>盒子模型有两种标准。第一种是我们正常渲染模式下采用的W3C标准盒子模型。第二种是怪异模式下采用的IE盒子模型。它们的区别如下：<br><a href=\"https://segmentfault.com/img/bVtyKC\" target=\"_blank\" rel=\"external\"><img src=\"https://segmentfault.com/img/bVtyKC\" alt=\"img\"></a><br><a href=\"https://segmentfault.com/img/bVtyKz\" target=\"_blank\" rel=\"external\"><img src=\"https://segmentfault.com/img/bVtyKz\" alt=\"img\"></a><br>IE盒子模型会把padding和border算入元素的width和height。于是会导致元素框的大小看起来比实际的要小。（在使用IE盒子模型下试试给固定宽高的元素增加padding值，你就知道是怎么一回事了）</p>\n<p>CSS3的box-sizing属性，让我们可以自行决定采用哪种盒子。</p>\n<blockquote>\n<p>box-sizing:content-box|border-box|inherit<br>content-box——默认值，采用Standard box model<br>border-box——采用IE box model<br>inherit——继承父元素属性值</p>\n</blockquote>\n<h2 id=\"CSS基本概念二：视觉格式化模型（visual-formatiing-modal）\"><a href=\"#CSS基本概念二：视觉格式化模型（visual-formatiing-modal）\" class=\"headerlink\" title=\"CSS基本概念二：视觉格式化模型（visual formatiing modal）\"></a>CSS基本概念二：视觉格式化模型（visual formatiing modal）</h2><p>上面所说的盒子模型是CSS的基础，之所以这么说是因为html里面的标签被浏览器解析后会生成元素，各元素被添加到docuemnt dom tree，但是CSS作用的不是元素，而是盒子，在页面渲染的过程，css在document dom tree的基础上会生成render tree，盒子模型就是render tree的节点。</p>\n<blockquote>\n<p>CSS 视觉格式化模型(visual formatting model)是用来处理文档并将它显示在视觉媒体上的机制。这是 CSS 的一个基础概念。 视觉格式化模型根据 CSS 盒模型为文档的每个元素生成 0，1 或多个盒。它也是 CSS 布局的核心，通过它，框( box )可以获得应有的尺寸，放到需要的位置。</p>\n</blockquote>\n<p>咦？！还存在一个元素生成多个盒的情况？<br>有的，<strong>li</strong> 除了生成主要块级盒外还会生成一个额外的盒来放置它的项目符号。但是其实大多数元素都只生成一个盒子。</p>\n<h4 id=\"影响布局的因素\"><a href=\"#影响布局的因素\" class=\"headerlink\" title=\"影响布局的因素\"></a>影响布局的因素</h4><ul>\n<li><strong>盒子的类型和尺寸</strong>：元素的display属性决定了盒子的类型，下面会详讲。</li>\n<li><strong>定位体系</strong>：盒子在布局时，会根据三种定位体系（定位方案）定位（常规流/浮动/绝对定位）</li>\n<li><strong>文档树中元素之间的关系</strong>：比如，一个块元素包含两个互为兄弟节点的浮动元素，后面那个浮动元素的布局，会受前面元素以及它包含块3的影响。</li>\n<li><strong>外部信息</strong>：可视窗口的大小对布局有影响、图片的固有尺寸会影响行内替换元素的尺寸进而影响布局</li>\n</ul>\n<h3 id=\"包含块（Containing-block）\"><a href=\"#包含块（Containing-block）\" class=\"headerlink\" title=\"包含块（Containing block）\"></a>包含块（Containing block）</h3><blockquote>\n<p>在 CSS2.1 中，很多框的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，被称作是包含块( containing block )。</p>\n</blockquote>\n<p>一个盒子相对于它的包含块的边界来渲染。但是盒子并不受它的包含块的限制，当它的布局跑到包含块的外面称为溢出（overflow）.</p>\n<p>通常盒为它的后代元素建立包含块。但父元素就是子元素的包含块吗？答案是否地的。包含块有一个判断标准，因为说来话长，只能上一张包含块判定的总流程图了（希望伙伴们不要被吓到）：<br><a href=\"http://w3help.org/zh-cn/kb/008/008/CB4.png\" target=\"_blank\" rel=\"external\"><img src=\"http://w3help.org/zh-cn/kb/008/008/CB4.png\" alt=\"img\"></a></p>\n<ul>\n<li>根元素存在的包含块，被叫做初始包含块 (initial containing block)。具体，跟用户端有关。</li>\n<li>如果元素的定位（position）为 “relative” （相对定位）或者 “static”（静态定位），它的包含块由它最近的块级、单元格（table cell）或者行内块（inline-block）祖先元素的 内容框1创建。<br>*如果元素是固定定位 (“position:fixed”) 元素，那么它的包含块是当前可视窗口</li>\n<li>绝对定位（”position: absolute”）元素的包含块由离它最近的 ‘position’ 属性为 ‘absolute’、’relative’ 或者 ‘fixed’ 的祖先元素创建。如果其祖先元素是行内元素，则包含块取决于其祖先元素的 ‘direction’ 特性：<ul>\n<li>如果 ‘direction’ 是 ‘ltr’，包含块的顶、左边是祖先元素生成的第一个框的顶、左内边距边界(padding edges) ，右、下边是祖先元素生成的最后一个框的右、下内边距边界(padding edges)</li>\n<li>如果 ‘direction’ 是 ‘rtl’，包含块的顶、右边是祖先元素生成的第一个框的顶、右内边距边界 (padding edges) ，左、下边是祖先元素生成的最后一个框的左、下内边距边界 (padding edges)</li>\n</ul>\n</li>\n</ul>\n<p>详细的说明可以看<a href=\"http://w3help.org/zh-cn/kb/008/\" target=\"_blank\" rel=\"external\">W3help关于包含块的这篇文章</a></p>\n<h3 id=\"盒子的生成\"><a href=\"#盒子的生成\" class=\"headerlink\" title=\"盒子的生成\"></a>盒子的生成</h3><p>从文档元素生成盒子是CSS视觉格式化模型的一部分工作。display属性决定了生成盒的类型，不同类型的盒子，视觉格式化模型对它的处理也不同。</p>\n<h4 id=\"块级元素与块盒\"><a href=\"#块级元素与块盒\" class=\"headerlink\" title=\"块级元素与块盒\"></a>块级元素与块盒</h4><ul>\n<li>display为block，list-item或table的元素是块级元素，它们在视觉呈现为独占一行的块，竖直排列。每个块级元素至少生成一个主要块级盒，且这个盒子可以参与任一一种定位方案。</li>\n<li>块级盒会参与BFC(块级格式化上下文)。</li>\n<li>除了table盒子和替换元素，一个块级盒子一般也是一个块容器盒。</li>\n<li>块容器盒要么只包含块级盒，要么只包含创建了IFC（行内格式化上下文）的行内级盒。</li>\n<li>块级盒不一定是块容器盒（如table），块容器盒也不一定是块级盒（如非替换的inline blocks和非替换的table cells）。既是块级盒又是块容器盒的称为块盒。</li>\n<li>（块级盒侧重描述了元素和它的父元素及兄弟元素之间的表现，块容器盒侧重描述元素跟它的后代元素之间的影响）<br><a href=\"http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/block-box.png\" target=\"_blank\" rel=\"external\"><img src=\"http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/block-box.png\" alt=\"img\"></a></li>\n</ul>\n<p><strong>匿名块盒</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div&gt;Some inline text </div><div class=\"line\">&lt;p&gt;followed by a paragraph&lt;/p&gt; </div><div class=\"line\">    followed by more inline text.</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>其中<code>Some inline text</code>和<code>followed by more inline text.</code>会各自被匿名块盒所包含。匿名块盒不能被CSS 选择符选中（即所有可继承的 CSS 属性值为 inherit ，所有非继承的 CSS 属性值为 initial）。</p>\n<p>创建匿名块盒的情况有两种：</p>\n<ol>\n<li><p>块容器盒同时包含行内级盒和块级盒时，将创建匿名块盒来包含毗邻的行内级盒。即上面的例子。</p>\n</li>\n<li><p>一个行内盒包含了一个或者几个块盒，包含块盒的盒将拆分为两个行内盒放置于块盒前后，然后分别由两个匿名块盒包含。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p style=&quot;display:inline;border=1px solid gray&quot;&gt;</div><div class=\"line\">This is anonymous text before the SPAN。</div><div class=\"line\">&lt;span style=&quot;display:block&quot;&gt;This is the content of SPAN.&lt;/span&gt;</div><div class=\"line\">This is anonymous text after the SPAN。</div><div class=\"line\">&lt;/p&gt;</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>效果：<br><a href=\"https://github.com/dolymood/blog/raw/master/pics/001.png\" target=\"_blank\" rel=\"external\"><img src=\"https://github.com/dolymood/blog/raw/master/pics/001.png\" alt=\"img\"></a></p>\n<h3 id=\"行内级元素和行内盒\"><a href=\"#行内级元素和行内盒\" class=\"headerlink\" title=\"行内级元素和行内盒\"></a>行内级元素和行内盒</h3><ul>\n<li>display为inline，inline-block和inline-table的元素为行内级元素。视觉上它与其它行内级元素水平排列，比如input，img等。</li>\n<li>行内级元素生成行内级盒，参与IFC（行内格式化上下文）。</li>\n<li>参与生成IFC的行内级盒为行内盒。而不参与生成IFC的行内级盒为原子行内级盒。</li>\n<li>所有display为inline的非替换元素生成的盒都是行内盒。</li>\n<li>可替换行内元素或display为inline-block或inline-table的元素生成的是原子行内级盒。原子行内级盒在行内格式化上下文里不能分成多行。<br><a href=\"http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/inline-box.png\" target=\"_blank\" rel=\"external\"><img src=\"http://yangyong-test.qiniudn.com/wp-content/uploads/2014/11/inline-box.png\" alt=\"img\"></a></li>\n</ul>\n<p><strong>匿名行盒</strong><br>类似于块盒，CSS 引擎有时自动生成行内盒。<br>产生匿名行内盒的情况是块盒直接包含文本，文本将包含在匿名行内盒中。空白如果使用white-space 去掉，则不会生成匿名行内盒。</p>\n<p><strong>行盒</strong><br>行盒由行内格式化上下文(inline formatting context)产生的盒，用于表示一行。</p>\n<p>最后附上一个display属性：不妨结合上面的知识思考一下不同值的display可以生成什么盒子？</p>\n<blockquote>\n<p>display<br>值： inline | block | list-item | inline-block | table | inline-table | table-row-group | table-header-group | table-footer-group | table-row | table-column-group | table-column | table-cell | table-caption | none | inherit</p>\n</blockquote>\n<p>一旦盒生成了， CSS 引擎要指定它们的位置，这时会用到不同的定位方案。<br>定位方案就留到下一篇文章再谈吧。因为我..好饿..咕..感谢能够耐心看到最后的人。</p>\n<p>参考文献：<br><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Visual_formatting_model\" target=\"_blank\" rel=\"external\">MDN-视觉格式化上下文</a><br><a href=\"http://blog.aijc.net/css/2014/08/06/CSS%20%E5%8F%AF%E8%A7%86%E5%8C%96%E6%A0%BC%E5%BC%8F%E6%A8%A1%E5%9E%8B%EF%BC%88Visual%20formatting%20model%EF%BC%89/\" target=\"_blank\" rel=\"external\">css可视化模型-dolymood的博客</a><br><a href=\"https://segmentfault.com/a/1190000004625635#articleHeader11\" target=\"_blank\" rel=\"external\">CSS魔法堂-重新认识Box Model..</a><br><a href=\"http://w3help.org/zh-cn/kb/007/\" target=\"_blank\" rel=\"external\">KB007：可视化格式化模型</a><br><a href=\"http://w3help.org/zh-cn/kb/006/\" target=\"_blank\" rel=\"external\">KB006: CSS 框模型( Box module )</a><br><a href=\"http://w3help.org/zh-cn/kb/008/\" target=\"_blank\" rel=\"external\">KB008: 包含块( Containing block )</a><br><a href=\"http://www.yangyong.me/css2-bfc%E6%A8%A1%E5%9E%8B%E5%92%8Cifc%E6%A8%A1%E5%9E%8B/\" target=\"_blank\" rel=\"external\">CSS2 BFC模型和IFC模型</a></p>\n"},{"title":"CSS定位那些事儿","date":"2016-08-11T15:13:58.000Z","_content":"\n秋风煞爽，迎来了新学期。稍不留神，时间就把我推到了大学的尾巴，容不得我愿不愿意。所有大四老油条都在给自己的未来定位。人生的定位过程，是一个现实和理想的挣扎。CSS的定位，有时也是呢。继上一篇初略探讨了CSS的视觉格式化上下文后，谈谈CSS定位的那些事吧。\n\n## CSS定位概述\n\n上一篇说过CSS的盒生成完毕了，就会指定它们的位置。总的来说，CSS提供了三种定位方案：\n\n- 常规流（normal flow）\n  - normal flow的盒子一个接一个的排列，块级盒子参与BFC进行排列，行内及盒子参与IFC进行排列\n  - 通常position为static或relateive或float为none的元素都会触发常规流的定位方案\n- 绝对定位\n  - 绝对定位的盒子会从常规流中移除，且不影响常规流的布局。它的相对定位相对于它的包含块\n  - 元素属性position为absolute|fixed的元素触发绝对定位布局\n- 浮动\n  - 它通常漂浮在常规流的上方\n  - float:left|right的元素触发浮动定位\n\n### CSS的position属性\n\n- static：\n  - 元素的默认值，位置是常规流布局里的位置，不能使用top，bottom，left，right，z-index来定位\n- relative：\n  - 可以相对于自身的默认位置来进行定位偏移。但即使有偏移，仍然保留原有的位置，即其它常规流的元素不能占用它原本的位置，它偏移的位置也不影响其他常规流元素的布局\n- absolute：\n  - 脱离常规流，可以相对于position不为static的第一个父元素进行定位。\n- fixed：\n  - 可以相对于浏览器窗口进行定位。旧版IE不支持。\n- inherit:\n  - 从父元素继承position属性的值。\n\nps：static和relative都属于常规流，而fixed和absolute都属于绝对定位。\n\n### display,position和float的影响\n\n> 定位有类似优先级的机制。\n\n1.”position:absolute” 和 “position:fixed” 优先级最高，有它存在的时候，浮动不起作用，’display’ 会按一定规则进行重置\n\n```\n<div id=\"test\" style=\"position:absolute; float:left; display:inline;\"></div>\n\n```\n\n上面的代码中，因为设置了绝对定位，元素根据定位规则重新计算后的值为：float为none（浮动失效）display为block。\nbut在IE:计算后的值’float’ 值和 ‘display’ 的特性值未发生变化，还是 “float: left; display: inline”。\n2.设置了float不为none的元素，display会按照规则转换成特定的值。\n\n```\n<span style=\"width:100px; height:100px; border:1px solid red; float:left;\">float span</span>\n\n```\n\n上面的代码，虽然span是行内元素，但是因为设置了浮动，在正常的浏览器中其display会被转换成block，因此可以设置其宽和高。\n\n1. 根元素，其display也会根据规则来转换。\n\n2. 最后，非根元素，并且非浮动元素，并且非绝对定位的元素，根据’display’ 特性值来定位。\n\n   **以上也反映了一个问题：浮动或绝对定位的元素，只能是块元素或表格。**对于非块元素或者表格的元素，在应用绝对定位或者float时，都会按照以下规则进行转换。\n   [![img](http://ww3.sinaimg.cn/large/63739cabjw1f79rsqjfmyj20it07g3zc.jpg)](http://ww3.sinaimg.cn/large/63739cabjw1f79rsqjfmyj20it07g3zc.jpg)\n\n   ## 常规流\n\n   常规流里的每一个盒子，都属于一个格式化的上下文中。不同的的元素会依据不同的格式化上下文来决定在当前环境中如何布局，块盒参与块级格式化上下文，行内盒子参与行内格式化上下文。\n\n   ### 块级格式化上下文BFC\n\n   在BFC中，盒子会一个接着一个垂直排列，且其中相邻的块级元素的垂直外边会发生折叠。\n\n   > 块格式化上下文是一个比较抽象的概念。可以把它想象成一个大箱子，很多元素装在里面，箱子把它们和外面的元素隔开。\n\n浮动元素，绝对定位元，display为inline-block，table-cell或table-captain的元素，以及overflow不为visible的元素，会创建新的格式化上下文。（！注意这些元素创建了块级格式化上下文，但它们本身不是块级格式化上下文）\n\n块级格式化很重要，因为它对宽高的计算，外边距折叠，定位都有影响。\n具体请看[之前的一篇文章CSS的BFC](http://blog.yzzhuo.com/2016/07/20/CSS%E7%9A%84BFC/)\n\n### 行内格式化上下文IFC\n\n块级格式化上下文的盒子一个接一个水平排列，起点是包含块的顶部。水平方向的margin，border，padding在盒子之间得以保留。 这些盒子在垂直方向可以以不同的方式来对齐。\n行内级盒子(inline-level boxes)布局到一个由行盒(line boxes)垂直排列而成的容器里。\n\n- IFC里面的盒子不能指定宽高。\n- 超出行盒宽度限制的行内框会被分割成多行。\n- IFC涉及的东西很多，包括\n  - 行盒和其大小计算\n  - 行内级盒子的对齐方式\n  - …\n\n在此必须知道基线是什么，以及line-height和vertical-align的原理。篇幅会比较长，为了避免本文篇幅过长，所以这部分打算之后有时间再另外抽出时间来探讨。\n\n## 浮动\n\n浮动的元素脱离常规流，并且内容（line box）可与沿着浮动盒子的边缘环绕，比如文字环绕效果就是利用浮动来实现的。给元素设置clear属性就能清除其环绕在周围的浮动元素。\n\n```\n<p style=\" margin: 2em; border: 1px solid red;width: 200px;\">\n<span style=\"width:100px; height:100px; background-color:green; margin:20px;float: left;\"></span>\nThe IMG box is floated to the left. The content that follows is formatted to the\nright of the float, starting on the same line as the float.\n</p>\n\n```\n\n[![img](http://w3help.org/zh-cn/kb/011/011/around_float.png)](http://w3help.org/zh-cn/kb/011/011/around_float.png)\n\n**浮动框的位置**\n一个浮动框要么向左偏移或向右偏移，偏移到直到它的外边界接触到它包含块的边界或者另外一个浮动框的外边界。\n（注意，浮动框虽然脱离了常规流，但是确实是会被常规流所决定它的位置的。反正很久之前自己就错误地，单纯的以为float元素在另外一个层叠空间起作用，也不受其他非浮动元素影响）\n\n**浮动框对其它框的影响** 因为浮动框脱离了常规流，所以常规流中的框会把浮动框当作不存在一样，即不会影响它们本来的排列布局。但是，在浮动框后创建的行盒会被缩短。\n\n对于table元素，块级替换元素，BFC元素和浮动元素,它们不能覆盖任何浮动元素。例子如下。\n\n```\n<div style=\" margin: 2em;border: 1px solid red;width: 200px;overflow: hidden;\">\n<div id=\"A\" style=\"width:50px; height:50px; background-color:green; margin:20px; float:left;\">A</div>\n<div id=\"B\" style=\" width:50px; background-color:blue; overflow:hidden;\">B</div>\n</div>\n\n```\n\n[![img](http://w3help.org/zh-cn/kb/011/011/float_overflow1.png)](http://w3help.org/zh-cn/kb/011/011/float_overflow1.png)\n\n## 绝对定位\n\n绝对定位元素定位的参照物是其包含块，关于包含块的判定可以回顾上一篇文章。\n\n> 常规流中的框，都在同一个层上，浮动框是处于常规流之上的一个特殊层，它可能会对常规流中的框的定位产生影响。但绝对定位的框不会， 每个绝对定位的框都可以看做一个单独的图层，不会对其他层框的定位产生影响。\n\n- 需要注意的是，在没有给绝对定位元素设置偏移时，它们的位置还是在常规流中的默认位置。\n\n参考文献：\n[CSS规范](https://www.w3.org/TR/2011/REC-CSS2-20110607/)","source":"_posts/CSS定位那些事儿.md","raw":"---\ntitle: CSS定位那些事儿\ndate: 2016-08-11 23:13:58\ntags: CSS\n---\n\n秋风煞爽，迎来了新学期。稍不留神，时间就把我推到了大学的尾巴，容不得我愿不愿意。所有大四老油条都在给自己的未来定位。人生的定位过程，是一个现实和理想的挣扎。CSS的定位，有时也是呢。继上一篇初略探讨了CSS的视觉格式化上下文后，谈谈CSS定位的那些事吧。\n\n## CSS定位概述\n\n上一篇说过CSS的盒生成完毕了，就会指定它们的位置。总的来说，CSS提供了三种定位方案：\n\n- 常规流（normal flow）\n  - normal flow的盒子一个接一个的排列，块级盒子参与BFC进行排列，行内及盒子参与IFC进行排列\n  - 通常position为static或relateive或float为none的元素都会触发常规流的定位方案\n- 绝对定位\n  - 绝对定位的盒子会从常规流中移除，且不影响常规流的布局。它的相对定位相对于它的包含块\n  - 元素属性position为absolute|fixed的元素触发绝对定位布局\n- 浮动\n  - 它通常漂浮在常规流的上方\n  - float:left|right的元素触发浮动定位\n\n### CSS的position属性\n\n- static：\n  - 元素的默认值，位置是常规流布局里的位置，不能使用top，bottom，left，right，z-index来定位\n- relative：\n  - 可以相对于自身的默认位置来进行定位偏移。但即使有偏移，仍然保留原有的位置，即其它常规流的元素不能占用它原本的位置，它偏移的位置也不影响其他常规流元素的布局\n- absolute：\n  - 脱离常规流，可以相对于position不为static的第一个父元素进行定位。\n- fixed：\n  - 可以相对于浏览器窗口进行定位。旧版IE不支持。\n- inherit:\n  - 从父元素继承position属性的值。\n\nps：static和relative都属于常规流，而fixed和absolute都属于绝对定位。\n\n### display,position和float的影响\n\n> 定位有类似优先级的机制。\n\n1.”position:absolute” 和 “position:fixed” 优先级最高，有它存在的时候，浮动不起作用，’display’ 会按一定规则进行重置\n\n```\n<div id=\"test\" style=\"position:absolute; float:left; display:inline;\"></div>\n\n```\n\n上面的代码中，因为设置了绝对定位，元素根据定位规则重新计算后的值为：float为none（浮动失效）display为block。\nbut在IE:计算后的值’float’ 值和 ‘display’ 的特性值未发生变化，还是 “float: left; display: inline”。\n2.设置了float不为none的元素，display会按照规则转换成特定的值。\n\n```\n<span style=\"width:100px; height:100px; border:1px solid red; float:left;\">float span</span>\n\n```\n\n上面的代码，虽然span是行内元素，但是因为设置了浮动，在正常的浏览器中其display会被转换成block，因此可以设置其宽和高。\n\n1. 根元素，其display也会根据规则来转换。\n\n2. 最后，非根元素，并且非浮动元素，并且非绝对定位的元素，根据’display’ 特性值来定位。\n\n   **以上也反映了一个问题：浮动或绝对定位的元素，只能是块元素或表格。**对于非块元素或者表格的元素，在应用绝对定位或者float时，都会按照以下规则进行转换。\n   [![img](http://ww3.sinaimg.cn/large/63739cabjw1f79rsqjfmyj20it07g3zc.jpg)](http://ww3.sinaimg.cn/large/63739cabjw1f79rsqjfmyj20it07g3zc.jpg)\n\n   ## 常规流\n\n   常规流里的每一个盒子，都属于一个格式化的上下文中。不同的的元素会依据不同的格式化上下文来决定在当前环境中如何布局，块盒参与块级格式化上下文，行内盒子参与行内格式化上下文。\n\n   ### 块级格式化上下文BFC\n\n   在BFC中，盒子会一个接着一个垂直排列，且其中相邻的块级元素的垂直外边会发生折叠。\n\n   > 块格式化上下文是一个比较抽象的概念。可以把它想象成一个大箱子，很多元素装在里面，箱子把它们和外面的元素隔开。\n\n浮动元素，绝对定位元，display为inline-block，table-cell或table-captain的元素，以及overflow不为visible的元素，会创建新的格式化上下文。（！注意这些元素创建了块级格式化上下文，但它们本身不是块级格式化上下文）\n\n块级格式化很重要，因为它对宽高的计算，外边距折叠，定位都有影响。\n具体请看[之前的一篇文章CSS的BFC](http://blog.yzzhuo.com/2016/07/20/CSS%E7%9A%84BFC/)\n\n### 行内格式化上下文IFC\n\n块级格式化上下文的盒子一个接一个水平排列，起点是包含块的顶部。水平方向的margin，border，padding在盒子之间得以保留。 这些盒子在垂直方向可以以不同的方式来对齐。\n行内级盒子(inline-level boxes)布局到一个由行盒(line boxes)垂直排列而成的容器里。\n\n- IFC里面的盒子不能指定宽高。\n- 超出行盒宽度限制的行内框会被分割成多行。\n- IFC涉及的东西很多，包括\n  - 行盒和其大小计算\n  - 行内级盒子的对齐方式\n  - …\n\n在此必须知道基线是什么，以及line-height和vertical-align的原理。篇幅会比较长，为了避免本文篇幅过长，所以这部分打算之后有时间再另外抽出时间来探讨。\n\n## 浮动\n\n浮动的元素脱离常规流，并且内容（line box）可与沿着浮动盒子的边缘环绕，比如文字环绕效果就是利用浮动来实现的。给元素设置clear属性就能清除其环绕在周围的浮动元素。\n\n```\n<p style=\" margin: 2em; border: 1px solid red;width: 200px;\">\n<span style=\"width:100px; height:100px; background-color:green; margin:20px;float: left;\"></span>\nThe IMG box is floated to the left. The content that follows is formatted to the\nright of the float, starting on the same line as the float.\n</p>\n\n```\n\n[![img](http://w3help.org/zh-cn/kb/011/011/around_float.png)](http://w3help.org/zh-cn/kb/011/011/around_float.png)\n\n**浮动框的位置**\n一个浮动框要么向左偏移或向右偏移，偏移到直到它的外边界接触到它包含块的边界或者另外一个浮动框的外边界。\n（注意，浮动框虽然脱离了常规流，但是确实是会被常规流所决定它的位置的。反正很久之前自己就错误地，单纯的以为float元素在另外一个层叠空间起作用，也不受其他非浮动元素影响）\n\n**浮动框对其它框的影响** 因为浮动框脱离了常规流，所以常规流中的框会把浮动框当作不存在一样，即不会影响它们本来的排列布局。但是，在浮动框后创建的行盒会被缩短。\n\n对于table元素，块级替换元素，BFC元素和浮动元素,它们不能覆盖任何浮动元素。例子如下。\n\n```\n<div style=\" margin: 2em;border: 1px solid red;width: 200px;overflow: hidden;\">\n<div id=\"A\" style=\"width:50px; height:50px; background-color:green; margin:20px; float:left;\">A</div>\n<div id=\"B\" style=\" width:50px; background-color:blue; overflow:hidden;\">B</div>\n</div>\n\n```\n\n[![img](http://w3help.org/zh-cn/kb/011/011/float_overflow1.png)](http://w3help.org/zh-cn/kb/011/011/float_overflow1.png)\n\n## 绝对定位\n\n绝对定位元素定位的参照物是其包含块，关于包含块的判定可以回顾上一篇文章。\n\n> 常规流中的框，都在同一个层上，浮动框是处于常规流之上的一个特殊层，它可能会对常规流中的框的定位产生影响。但绝对定位的框不会， 每个绝对定位的框都可以看做一个单独的图层，不会对其他层框的定位产生影响。\n\n- 需要注意的是，在没有给绝对定位元素设置偏移时，它们的位置还是在常规流中的默认位置。\n\n参考文献：\n[CSS规范](https://www.w3.org/TR/2011/REC-CSS2-20110607/)","slug":"CSS定位那些事儿","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwmi0001cgesrfedfra6","content":"<p>秋风煞爽，迎来了新学期。稍不留神，时间就把我推到了大学的尾巴，容不得我愿不愿意。所有大四老油条都在给自己的未来定位。人生的定位过程，是一个现实和理想的挣扎。CSS的定位，有时也是呢。继上一篇初略探讨了CSS的视觉格式化上下文后，谈谈CSS定位的那些事吧。</p>\n<h2 id=\"CSS定位概述\"><a href=\"#CSS定位概述\" class=\"headerlink\" title=\"CSS定位概述\"></a>CSS定位概述</h2><p>上一篇说过CSS的盒生成完毕了，就会指定它们的位置。总的来说，CSS提供了三种定位方案：</p>\n<ul>\n<li>常规流（normal flow）<ul>\n<li>normal flow的盒子一个接一个的排列，块级盒子参与BFC进行排列，行内及盒子参与IFC进行排列</li>\n<li>通常position为static或relateive或float为none的元素都会触发常规流的定位方案</li>\n</ul>\n</li>\n<li>绝对定位<ul>\n<li>绝对定位的盒子会从常规流中移除，且不影响常规流的布局。它的相对定位相对于它的包含块</li>\n<li>元素属性position为absolute|fixed的元素触发绝对定位布局</li>\n</ul>\n</li>\n<li>浮动<ul>\n<li>它通常漂浮在常规流的上方</li>\n<li>float:left|right的元素触发浮动定位</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CSS的position属性\"><a href=\"#CSS的position属性\" class=\"headerlink\" title=\"CSS的position属性\"></a>CSS的position属性</h3><ul>\n<li>static：<ul>\n<li>元素的默认值，位置是常规流布局里的位置，不能使用top，bottom，left，right，z-index来定位</li>\n</ul>\n</li>\n<li>relative：<ul>\n<li>可以相对于自身的默认位置来进行定位偏移。但即使有偏移，仍然保留原有的位置，即其它常规流的元素不能占用它原本的位置，它偏移的位置也不影响其他常规流元素的布局</li>\n</ul>\n</li>\n<li>absolute：<ul>\n<li>脱离常规流，可以相对于position不为static的第一个父元素进行定位。</li>\n</ul>\n</li>\n<li>fixed：<ul>\n<li>可以相对于浏览器窗口进行定位。旧版IE不支持。</li>\n</ul>\n</li>\n<li>inherit:<ul>\n<li>从父元素继承position属性的值。</li>\n</ul>\n</li>\n</ul>\n<p>ps：static和relative都属于常规流，而fixed和absolute都属于绝对定位。</p>\n<h3 id=\"display-position和float的影响\"><a href=\"#display-position和float的影响\" class=\"headerlink\" title=\"display,position和float的影响\"></a>display,position和float的影响</h3><blockquote>\n<p>定位有类似优先级的机制。</p>\n</blockquote>\n<p>1.”position:absolute” 和 “position:fixed” 优先级最高，有它存在的时候，浮动不起作用，’display’ 会按一定规则进行重置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;test&quot; style=&quot;position:absolute; float:left; display:inline;&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>上面的代码中，因为设置了绝对定位，元素根据定位规则重新计算后的值为：float为none（浮动失效）display为block。<br>but在IE:计算后的值’float’ 值和 ‘display’ 的特性值未发生变化，还是 “float: left; display: inline”。<br>2.设置了float不为none的元素，display会按照规则转换成特定的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;span style=&quot;width:100px; height:100px; border:1px solid red; float:left;&quot;&gt;float span&lt;/span&gt;</div></pre></td></tr></table></figure>\n<p>上面的代码，虽然span是行内元素，但是因为设置了浮动，在正常的浏览器中其display会被转换成block，因此可以设置其宽和高。</p>\n<ol>\n<li><p>根元素，其display也会根据规则来转换。</p>\n</li>\n<li><p>最后，非根元素，并且非浮动元素，并且非绝对定位的元素，根据’display’ 特性值来定位。</p>\n<p><strong>以上也反映了一个问题：浮动或绝对定位的元素，只能是块元素或表格。</strong>对于非块元素或者表格的元素，在应用绝对定位或者float时，都会按照以下规则进行转换。<br><a href=\"http://ww3.sinaimg.cn/large/63739cabjw1f79rsqjfmyj20it07g3zc.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww3.sinaimg.cn/large/63739cabjw1f79rsqjfmyj20it07g3zc.jpg\" alt=\"img\"></a></p>\n<h2 id=\"常规流\"><a href=\"#常规流\" class=\"headerlink\" title=\"常规流\"></a>常规流</h2><p>常规流里的每一个盒子，都属于一个格式化的上下文中。不同的的元素会依据不同的格式化上下文来决定在当前环境中如何布局，块盒参与块级格式化上下文，行内盒子参与行内格式化上下文。</p>\n<h3 id=\"块级格式化上下文BFC\"><a href=\"#块级格式化上下文BFC\" class=\"headerlink\" title=\"块级格式化上下文BFC\"></a>块级格式化上下文BFC</h3><p>在BFC中，盒子会一个接着一个垂直排列，且其中相邻的块级元素的垂直外边会发生折叠。</p>\n<blockquote>\n<p>块格式化上下文是一个比较抽象的概念。可以把它想象成一个大箱子，很多元素装在里面，箱子把它们和外面的元素隔开。</p>\n</blockquote>\n</li>\n</ol>\n<p>浮动元素，绝对定位元，display为inline-block，table-cell或table-captain的元素，以及overflow不为visible的元素，会创建新的格式化上下文。（！注意这些元素创建了块级格式化上下文，但它们本身不是块级格式化上下文）</p>\n<p>块级格式化很重要，因为它对宽高的计算，外边距折叠，定位都有影响。<br>具体请看<a href=\"http://blog.yzzhuo.com/2016/07/20/CSS%E7%9A%84BFC/\">之前的一篇文章CSS的BFC</a></p>\n<h3 id=\"行内格式化上下文IFC\"><a href=\"#行内格式化上下文IFC\" class=\"headerlink\" title=\"行内格式化上下文IFC\"></a>行内格式化上下文IFC</h3><p>块级格式化上下文的盒子一个接一个水平排列，起点是包含块的顶部。水平方向的margin，border，padding在盒子之间得以保留。 这些盒子在垂直方向可以以不同的方式来对齐。<br>行内级盒子(inline-level boxes)布局到一个由行盒(line boxes)垂直排列而成的容器里。</p>\n<ul>\n<li>IFC里面的盒子不能指定宽高。</li>\n<li>超出行盒宽度限制的行内框会被分割成多行。</li>\n<li>IFC涉及的东西很多，包括<ul>\n<li>行盒和其大小计算</li>\n<li>行内级盒子的对齐方式</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<p>在此必须知道基线是什么，以及line-height和vertical-align的原理。篇幅会比较长，为了避免本文篇幅过长，所以这部分打算之后有时间再另外抽出时间来探讨。</p>\n<h2 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h2><p>浮动的元素脱离常规流，并且内容（line box）可与沿着浮动盒子的边缘环绕，比如文字环绕效果就是利用浮动来实现的。给元素设置clear属性就能清除其环绕在周围的浮动元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p style=&quot; margin: 2em; border: 1px solid red;width: 200px;&quot;&gt;</div><div class=\"line\">&lt;span style=&quot;width:100px; height:100px; background-color:green; margin:20px;float: left;&quot;&gt;&lt;/span&gt;</div><div class=\"line\">The IMG box is floated to the left. The content that follows is formatted to the</div><div class=\"line\">right of the float, starting on the same line as the float.</div><div class=\"line\">&lt;/p&gt;</div></pre></td></tr></table></figure>\n<p><a href=\"http://w3help.org/zh-cn/kb/011/011/around_float.png\" target=\"_blank\" rel=\"external\"><img src=\"http://w3help.org/zh-cn/kb/011/011/around_float.png\" alt=\"img\"></a></p>\n<p><strong>浮动框的位置</strong><br>一个浮动框要么向左偏移或向右偏移，偏移到直到它的外边界接触到它包含块的边界或者另外一个浮动框的外边界。<br>（注意，浮动框虽然脱离了常规流，但是确实是会被常规流所决定它的位置的。反正很久之前自己就错误地，单纯的以为float元素在另外一个层叠空间起作用，也不受其他非浮动元素影响）</p>\n<p><strong>浮动框对其它框的影响</strong> 因为浮动框脱离了常规流，所以常规流中的框会把浮动框当作不存在一样，即不会影响它们本来的排列布局。但是，在浮动框后创建的行盒会被缩短。</p>\n<p>对于table元素，块级替换元素，BFC元素和浮动元素,它们不能覆盖任何浮动元素。例子如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot; margin: 2em;border: 1px solid red;width: 200px;overflow: hidden;&quot;&gt;</div><div class=\"line\">&lt;div id=&quot;A&quot; style=&quot;width:50px; height:50px; background-color:green; margin:20px; float:left;&quot;&gt;A&lt;/div&gt;</div><div class=\"line\">&lt;div id=&quot;B&quot; style=&quot; width:50px; background-color:blue; overflow:hidden;&quot;&gt;B&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p><a href=\"http://w3help.org/zh-cn/kb/011/011/float_overflow1.png\" target=\"_blank\" rel=\"external\"><img src=\"http://w3help.org/zh-cn/kb/011/011/float_overflow1.png\" alt=\"img\"></a></p>\n<h2 id=\"绝对定位\"><a href=\"#绝对定位\" class=\"headerlink\" title=\"绝对定位\"></a>绝对定位</h2><p>绝对定位元素定位的参照物是其包含块，关于包含块的判定可以回顾上一篇文章。</p>\n<blockquote>\n<p>常规流中的框，都在同一个层上，浮动框是处于常规流之上的一个特殊层，它可能会对常规流中的框的定位产生影响。但绝对定位的框不会， 每个绝对定位的框都可以看做一个单独的图层，不会对其他层框的定位产生影响。</p>\n</blockquote>\n<ul>\n<li>需要注意的是，在没有给绝对定位元素设置偏移时，它们的位置还是在常规流中的默认位置。</li>\n</ul>\n<p>参考文献：<br><a href=\"https://www.w3.org/TR/2011/REC-CSS2-20110607/\" target=\"_blank\" rel=\"external\">CSS规范</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>秋风煞爽，迎来了新学期。稍不留神，时间就把我推到了大学的尾巴，容不得我愿不愿意。所有大四老油条都在给自己的未来定位。人生的定位过程，是一个现实和理想的挣扎。CSS的定位，有时也是呢。继上一篇初略探讨了CSS的视觉格式化上下文后，谈谈CSS定位的那些事吧。</p>\n<h2 id=\"CSS定位概述\"><a href=\"#CSS定位概述\" class=\"headerlink\" title=\"CSS定位概述\"></a>CSS定位概述</h2><p>上一篇说过CSS的盒生成完毕了，就会指定它们的位置。总的来说，CSS提供了三种定位方案：</p>\n<ul>\n<li>常规流（normal flow）<ul>\n<li>normal flow的盒子一个接一个的排列，块级盒子参与BFC进行排列，行内及盒子参与IFC进行排列</li>\n<li>通常position为static或relateive或float为none的元素都会触发常规流的定位方案</li>\n</ul>\n</li>\n<li>绝对定位<ul>\n<li>绝对定位的盒子会从常规流中移除，且不影响常规流的布局。它的相对定位相对于它的包含块</li>\n<li>元素属性position为absolute|fixed的元素触发绝对定位布局</li>\n</ul>\n</li>\n<li>浮动<ul>\n<li>它通常漂浮在常规流的上方</li>\n<li>float:left|right的元素触发浮动定位</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CSS的position属性\"><a href=\"#CSS的position属性\" class=\"headerlink\" title=\"CSS的position属性\"></a>CSS的position属性</h3><ul>\n<li>static：<ul>\n<li>元素的默认值，位置是常规流布局里的位置，不能使用top，bottom，left，right，z-index来定位</li>\n</ul>\n</li>\n<li>relative：<ul>\n<li>可以相对于自身的默认位置来进行定位偏移。但即使有偏移，仍然保留原有的位置，即其它常规流的元素不能占用它原本的位置，它偏移的位置也不影响其他常规流元素的布局</li>\n</ul>\n</li>\n<li>absolute：<ul>\n<li>脱离常规流，可以相对于position不为static的第一个父元素进行定位。</li>\n</ul>\n</li>\n<li>fixed：<ul>\n<li>可以相对于浏览器窗口进行定位。旧版IE不支持。</li>\n</ul>\n</li>\n<li>inherit:<ul>\n<li>从父元素继承position属性的值。</li>\n</ul>\n</li>\n</ul>\n<p>ps：static和relative都属于常规流，而fixed和absolute都属于绝对定位。</p>\n<h3 id=\"display-position和float的影响\"><a href=\"#display-position和float的影响\" class=\"headerlink\" title=\"display,position和float的影响\"></a>display,position和float的影响</h3><blockquote>\n<p>定位有类似优先级的机制。</p>\n</blockquote>\n<p>1.”position:absolute” 和 “position:fixed” 优先级最高，有它存在的时候，浮动不起作用，’display’ 会按一定规则进行重置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div id=&quot;test&quot; style=&quot;position:absolute; float:left; display:inline;&quot;&gt;&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p>上面的代码中，因为设置了绝对定位，元素根据定位规则重新计算后的值为：float为none（浮动失效）display为block。<br>but在IE:计算后的值’float’ 值和 ‘display’ 的特性值未发生变化，还是 “float: left; display: inline”。<br>2.设置了float不为none的元素，display会按照规则转换成特定的值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;span style=&quot;width:100px; height:100px; border:1px solid red; float:left;&quot;&gt;float span&lt;/span&gt;</div></pre></td></tr></table></figure>\n<p>上面的代码，虽然span是行内元素，但是因为设置了浮动，在正常的浏览器中其display会被转换成block，因此可以设置其宽和高。</p>\n<ol>\n<li><p>根元素，其display也会根据规则来转换。</p>\n</li>\n<li><p>最后，非根元素，并且非浮动元素，并且非绝对定位的元素，根据’display’ 特性值来定位。</p>\n<p><strong>以上也反映了一个问题：浮动或绝对定位的元素，只能是块元素或表格。</strong>对于非块元素或者表格的元素，在应用绝对定位或者float时，都会按照以下规则进行转换。<br><a href=\"http://ww3.sinaimg.cn/large/63739cabjw1f79rsqjfmyj20it07g3zc.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww3.sinaimg.cn/large/63739cabjw1f79rsqjfmyj20it07g3zc.jpg\" alt=\"img\"></a></p>\n<h2 id=\"常规流\"><a href=\"#常规流\" class=\"headerlink\" title=\"常规流\"></a>常规流</h2><p>常规流里的每一个盒子，都属于一个格式化的上下文中。不同的的元素会依据不同的格式化上下文来决定在当前环境中如何布局，块盒参与块级格式化上下文，行内盒子参与行内格式化上下文。</p>\n<h3 id=\"块级格式化上下文BFC\"><a href=\"#块级格式化上下文BFC\" class=\"headerlink\" title=\"块级格式化上下文BFC\"></a>块级格式化上下文BFC</h3><p>在BFC中，盒子会一个接着一个垂直排列，且其中相邻的块级元素的垂直外边会发生折叠。</p>\n<blockquote>\n<p>块格式化上下文是一个比较抽象的概念。可以把它想象成一个大箱子，很多元素装在里面，箱子把它们和外面的元素隔开。</p>\n</blockquote>\n</li>\n</ol>\n<p>浮动元素，绝对定位元，display为inline-block，table-cell或table-captain的元素，以及overflow不为visible的元素，会创建新的格式化上下文。（！注意这些元素创建了块级格式化上下文，但它们本身不是块级格式化上下文）</p>\n<p>块级格式化很重要，因为它对宽高的计算，外边距折叠，定位都有影响。<br>具体请看<a href=\"http://blog.yzzhuo.com/2016/07/20/CSS%E7%9A%84BFC/\">之前的一篇文章CSS的BFC</a></p>\n<h3 id=\"行内格式化上下文IFC\"><a href=\"#行内格式化上下文IFC\" class=\"headerlink\" title=\"行内格式化上下文IFC\"></a>行内格式化上下文IFC</h3><p>块级格式化上下文的盒子一个接一个水平排列，起点是包含块的顶部。水平方向的margin，border，padding在盒子之间得以保留。 这些盒子在垂直方向可以以不同的方式来对齐。<br>行内级盒子(inline-level boxes)布局到一个由行盒(line boxes)垂直排列而成的容器里。</p>\n<ul>\n<li>IFC里面的盒子不能指定宽高。</li>\n<li>超出行盒宽度限制的行内框会被分割成多行。</li>\n<li>IFC涉及的东西很多，包括<ul>\n<li>行盒和其大小计算</li>\n<li>行内级盒子的对齐方式</li>\n<li>…</li>\n</ul>\n</li>\n</ul>\n<p>在此必须知道基线是什么，以及line-height和vertical-align的原理。篇幅会比较长，为了避免本文篇幅过长，所以这部分打算之后有时间再另外抽出时间来探讨。</p>\n<h2 id=\"浮动\"><a href=\"#浮动\" class=\"headerlink\" title=\"浮动\"></a>浮动</h2><p>浮动的元素脱离常规流，并且内容（line box）可与沿着浮动盒子的边缘环绕，比如文字环绕效果就是利用浮动来实现的。给元素设置clear属性就能清除其环绕在周围的浮动元素。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;p style=&quot; margin: 2em; border: 1px solid red;width: 200px;&quot;&gt;</div><div class=\"line\">&lt;span style=&quot;width:100px; height:100px; background-color:green; margin:20px;float: left;&quot;&gt;&lt;/span&gt;</div><div class=\"line\">The IMG box is floated to the left. The content that follows is formatted to the</div><div class=\"line\">right of the float, starting on the same line as the float.</div><div class=\"line\">&lt;/p&gt;</div></pre></td></tr></table></figure>\n<p><a href=\"http://w3help.org/zh-cn/kb/011/011/around_float.png\" target=\"_blank\" rel=\"external\"><img src=\"http://w3help.org/zh-cn/kb/011/011/around_float.png\" alt=\"img\"></a></p>\n<p><strong>浮动框的位置</strong><br>一个浮动框要么向左偏移或向右偏移，偏移到直到它的外边界接触到它包含块的边界或者另外一个浮动框的外边界。<br>（注意，浮动框虽然脱离了常规流，但是确实是会被常规流所决定它的位置的。反正很久之前自己就错误地，单纯的以为float元素在另外一个层叠空间起作用，也不受其他非浮动元素影响）</p>\n<p><strong>浮动框对其它框的影响</strong> 因为浮动框脱离了常规流，所以常规流中的框会把浮动框当作不存在一样，即不会影响它们本来的排列布局。但是，在浮动框后创建的行盒会被缩短。</p>\n<p>对于table元素，块级替换元素，BFC元素和浮动元素,它们不能覆盖任何浮动元素。例子如下。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;div style=&quot; margin: 2em;border: 1px solid red;width: 200px;overflow: hidden;&quot;&gt;</div><div class=\"line\">&lt;div id=&quot;A&quot; style=&quot;width:50px; height:50px; background-color:green; margin:20px; float:left;&quot;&gt;A&lt;/div&gt;</div><div class=\"line\">&lt;div id=&quot;B&quot; style=&quot; width:50px; background-color:blue; overflow:hidden;&quot;&gt;B&lt;/div&gt;</div><div class=\"line\">&lt;/div&gt;</div></pre></td></tr></table></figure>\n<p><a href=\"http://w3help.org/zh-cn/kb/011/011/float_overflow1.png\" target=\"_blank\" rel=\"external\"><img src=\"http://w3help.org/zh-cn/kb/011/011/float_overflow1.png\" alt=\"img\"></a></p>\n<h2 id=\"绝对定位\"><a href=\"#绝对定位\" class=\"headerlink\" title=\"绝对定位\"></a>绝对定位</h2><p>绝对定位元素定位的参照物是其包含块，关于包含块的判定可以回顾上一篇文章。</p>\n<blockquote>\n<p>常规流中的框，都在同一个层上，浮动框是处于常规流之上的一个特殊层，它可能会对常规流中的框的定位产生影响。但绝对定位的框不会， 每个绝对定位的框都可以看做一个单独的图层，不会对其他层框的定位产生影响。</p>\n</blockquote>\n<ul>\n<li>需要注意的是，在没有给绝对定位元素设置偏移时，它们的位置还是在常规流中的默认位置。</li>\n</ul>\n<p>参考文献：<br><a href=\"https://www.w3.org/TR/2011/REC-CSS2-20110607/\" target=\"_blank\" rel=\"external\">CSS规范</a></p>\n"},{"title":"CSS的BFC","date":"2016-08-10T15:13:58.000Z","_content":"\n昨天经历了一次百度的电话面试（一次带着淡淡忧伤的面试，有时间再写个面筋）被问到BFC这个东西问到傻了。昨晚谷歌看了好多篇关于BFC的文章。在终于理清了BFC这个东西时，突然就有想写篇博文的冲动了呢！（怒~）\n\n------\n\n在学习BFC这个东西前，先说说FC这两个字的含义吧。\n**FC(Formatting Context):格式化上下文是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。**CSS2有BFC,IFC，CSS3还增加了GFC和FFC(突然想去KFC吃个全家桶来冷静一下…)\n\n### BFC\n\n> 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。\n\n#### BFC的特性\n\n1. 内部的Box会在垂直方向，从顶部开始一个接一个的放置。\n2. Box垂直方向之间的距离由margin决定，同一个BFC的两个相邻BOX的margin会发生叠加。\n3. 每个元素的左边margin会与包含的box的左border相接触。\n4. BFC的区域不会与float box叠加。\n5. BFC是页面一个隔离的独立容器。与外面的元素互补影响。\n6. 计算BFC的高度时，浮动元素也参与计算。\n\n### 创建一个新的BFC的条件\n\n根据定义就可以知道，当一个元素的样式符合以下条件之一时，就可以创建一个新的BFC:\n\n- float：left|right；\n- position：absolute|fixed;\n- display:table-cell|table-caption|inline-block;\n- overflow:hidden|scroll|auto;\n\n### BFC的作用和应用场景\n\n1. 清楚内部浮动\n2. 外边距折叠问题\n3. 多栏式布局\n   （因为网络很多博文对这部分都图文并茂地讲得很清楚了，这里只是轻轻带过~，但是重点是要知道BFC这个东西延伸出来的东西原来都是我们经常用到的啊！！！（只知其然不知其所有然的我露出细思极恐状））\n\n### 拓展延伸思考\n\n看完了网络上各位大神对BFC详尽的介绍，总算知道了BFC这个家伙是干吗的了。这个学习的过程也伴随着几个曾经很纠结的问题。\n\n1. **页面写了普通的几个div，这时就存在了BFC了吗？**\n\n   实践证明是的，因为你写两个div时会发现它们垂直排列，而且垂直的边距margin发生了重叠，这符合BFC的特性。说明了根元素(html)会生成默认BFC供其子孙block-level box使用。\n\n2. **在和舍友讨论这个问题时，舍友说到，为什么明明叫做块级格式化上下文，生成一个BFC的条件怎么好像跟块级元素不搭边呢？**\n   盒子是CSS布局的基本单位，CSS有不同类型的盒子，不同的盒子会参与不同的FC。display为block，table等的元素会生成块级盒子，参与BFC（html生成的默认的BFC）。但其实BFC这个概念对我们的最大作用是如何生成一个新的BFC,来达到自己想要的布局排版方式。\n\n3. **包含了浮动元素的父元素为什么高度会塌陷？给父元素添加了overflow：hidden|auto是生成了一个新的BFC，可为什么能让父元素高度与浮动元素一致了呢？**\n   （我曾经也想过用BFC这个问题来解答，但发现论据不足。后来看到知乎有一个回答还是不能大彻大悟（就像学术领域的一些问题得到的回答往往是权威两个字），后来又看了CSS魔法堂的一篇文章，才算是真正理解。）\n   第一个问题，为什么div中仅含浮动元素时，盒子高度为0?这个要归咎于block-level box对高度的计算（详见文档，其中提到out-flow box不影响block-level box高度的计算。）\n   第二个问题，为什么通过overflow产生了一个新的BFC就能让父元素高度不为0了呢？对于产生新的BFC的盒子而言，会有以下几个现象：\n\n   - 不发生外边折叠\n   - out-flow box纳入block-level box高度的计算\n   - 不与positioning scheme为floats的兄弟盒子重叠\n\n#### 后话\n\n对于IFC，等自己了解完有勇气了再写吧~！另外有了点人生感悟想拿来分享：年少无知的自己曾经觉得CSS和html是最容易学最小儿科的东西，觉得大不了用时有不会的再看看文档大概也能实现自己想要的效果。但是现在深刻体会到了CSS入门简单，精通难（前端也是这个道理）。很多时候原来我们不仅要知道怎么去实现一个效果和样式，更要去探究其实现的原理，通过探究学习这个原理，往往会发现一个我们未知的真理，而这个真理将带我们有一个质的飞跃~！\n\n在此感谢巨人让我看的更高\n参考内容：\n[小科普：到底什么是BFC、IFC、GFC和FFC，次奥？](http://www.xiaomeiti.com/note/3608)\n[CSS之BFC详解](http://www.html-js.com/article/1866)\n[CSS魔法堂：重新认识Box Model、IFC、BFC和Collapsing margins](https://segmentfault.com/a/1190000004625635#articleHeader11)\n[W3C对BFC的定义](https://www.w3.org/TR/CSS2/visuren.html#block-formatting)","source":"_posts/CSS的BFC.md","raw":"---\ntitle: CSS的BFC\ndate: 2016-08-10 23:13:58\ntags: CSS\n---\n\n昨天经历了一次百度的电话面试（一次带着淡淡忧伤的面试，有时间再写个面筋）被问到BFC这个东西问到傻了。昨晚谷歌看了好多篇关于BFC的文章。在终于理清了BFC这个东西时，突然就有想写篇博文的冲动了呢！（怒~）\n\n------\n\n在学习BFC这个东西前，先说说FC这两个字的含义吧。\n**FC(Formatting Context):格式化上下文是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。**CSS2有BFC,IFC，CSS3还增加了GFC和FFC(突然想去KFC吃个全家桶来冷静一下…)\n\n### BFC\n\n> 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。\n\n#### BFC的特性\n\n1. 内部的Box会在垂直方向，从顶部开始一个接一个的放置。\n2. Box垂直方向之间的距离由margin决定，同一个BFC的两个相邻BOX的margin会发生叠加。\n3. 每个元素的左边margin会与包含的box的左border相接触。\n4. BFC的区域不会与float box叠加。\n5. BFC是页面一个隔离的独立容器。与外面的元素互补影响。\n6. 计算BFC的高度时，浮动元素也参与计算。\n\n### 创建一个新的BFC的条件\n\n根据定义就可以知道，当一个元素的样式符合以下条件之一时，就可以创建一个新的BFC:\n\n- float：left|right；\n- position：absolute|fixed;\n- display:table-cell|table-caption|inline-block;\n- overflow:hidden|scroll|auto;\n\n### BFC的作用和应用场景\n\n1. 清楚内部浮动\n2. 外边距折叠问题\n3. 多栏式布局\n   （因为网络很多博文对这部分都图文并茂地讲得很清楚了，这里只是轻轻带过~，但是重点是要知道BFC这个东西延伸出来的东西原来都是我们经常用到的啊！！！（只知其然不知其所有然的我露出细思极恐状））\n\n### 拓展延伸思考\n\n看完了网络上各位大神对BFC详尽的介绍，总算知道了BFC这个家伙是干吗的了。这个学习的过程也伴随着几个曾经很纠结的问题。\n\n1. **页面写了普通的几个div，这时就存在了BFC了吗？**\n\n   实践证明是的，因为你写两个div时会发现它们垂直排列，而且垂直的边距margin发生了重叠，这符合BFC的特性。说明了根元素(html)会生成默认BFC供其子孙block-level box使用。\n\n2. **在和舍友讨论这个问题时，舍友说到，为什么明明叫做块级格式化上下文，生成一个BFC的条件怎么好像跟块级元素不搭边呢？**\n   盒子是CSS布局的基本单位，CSS有不同类型的盒子，不同的盒子会参与不同的FC。display为block，table等的元素会生成块级盒子，参与BFC（html生成的默认的BFC）。但其实BFC这个概念对我们的最大作用是如何生成一个新的BFC,来达到自己想要的布局排版方式。\n\n3. **包含了浮动元素的父元素为什么高度会塌陷？给父元素添加了overflow：hidden|auto是生成了一个新的BFC，可为什么能让父元素高度与浮动元素一致了呢？**\n   （我曾经也想过用BFC这个问题来解答，但发现论据不足。后来看到知乎有一个回答还是不能大彻大悟（就像学术领域的一些问题得到的回答往往是权威两个字），后来又看了CSS魔法堂的一篇文章，才算是真正理解。）\n   第一个问题，为什么div中仅含浮动元素时，盒子高度为0?这个要归咎于block-level box对高度的计算（详见文档，其中提到out-flow box不影响block-level box高度的计算。）\n   第二个问题，为什么通过overflow产生了一个新的BFC就能让父元素高度不为0了呢？对于产生新的BFC的盒子而言，会有以下几个现象：\n\n   - 不发生外边折叠\n   - out-flow box纳入block-level box高度的计算\n   - 不与positioning scheme为floats的兄弟盒子重叠\n\n#### 后话\n\n对于IFC，等自己了解完有勇气了再写吧~！另外有了点人生感悟想拿来分享：年少无知的自己曾经觉得CSS和html是最容易学最小儿科的东西，觉得大不了用时有不会的再看看文档大概也能实现自己想要的效果。但是现在深刻体会到了CSS入门简单，精通难（前端也是这个道理）。很多时候原来我们不仅要知道怎么去实现一个效果和样式，更要去探究其实现的原理，通过探究学习这个原理，往往会发现一个我们未知的真理，而这个真理将带我们有一个质的飞跃~！\n\n在此感谢巨人让我看的更高\n参考内容：\n[小科普：到底什么是BFC、IFC、GFC和FFC，次奥？](http://www.xiaomeiti.com/note/3608)\n[CSS之BFC详解](http://www.html-js.com/article/1866)\n[CSS魔法堂：重新认识Box Model、IFC、BFC和Collapsing margins](https://segmentfault.com/a/1190000004625635#articleHeader11)\n[W3C对BFC的定义](https://www.w3.org/TR/CSS2/visuren.html#block-formatting)","slug":"CSS的BFC","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwmn0003cges3ye401n7","content":"<p>昨天经历了一次百度的电话面试（一次带着淡淡忧伤的面试，有时间再写个面筋）被问到BFC这个东西问到傻了。昨晚谷歌看了好多篇关于BFC的文章。在终于理清了BFC这个东西时，突然就有想写篇博文的冲动了呢！（怒~）</p>\n<hr>\n<p>在学习BFC这个东西前，先说说FC这两个字的含义吧。<br><strong>FC(Formatting Context):格式化上下文是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</strong>CSS2有BFC,IFC，CSS3还增加了GFC和FFC(突然想去KFC吃个全家桶来冷静一下…)</p>\n<h3 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h3><blockquote>\n<p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。</p>\n</blockquote>\n<h4 id=\"BFC的特性\"><a href=\"#BFC的特性\" class=\"headerlink\" title=\"BFC的特性\"></a>BFC的特性</h4><ol>\n<li>内部的Box会在垂直方向，从顶部开始一个接一个的放置。</li>\n<li>Box垂直方向之间的距离由margin决定，同一个BFC的两个相邻BOX的margin会发生叠加。</li>\n<li>每个元素的左边margin会与包含的box的左border相接触。</li>\n<li>BFC的区域不会与float box叠加。</li>\n<li>BFC是页面一个隔离的独立容器。与外面的元素互补影响。</li>\n<li>计算BFC的高度时，浮动元素也参与计算。</li>\n</ol>\n<h3 id=\"创建一个新的BFC的条件\"><a href=\"#创建一个新的BFC的条件\" class=\"headerlink\" title=\"创建一个新的BFC的条件\"></a>创建一个新的BFC的条件</h3><p>根据定义就可以知道，当一个元素的样式符合以下条件之一时，就可以创建一个新的BFC:</p>\n<ul>\n<li>float：left|right；</li>\n<li>position：absolute|fixed;</li>\n<li>display:table-cell|table-caption|inline-block;</li>\n<li>overflow:hidden|scroll|auto;</li>\n</ul>\n<h3 id=\"BFC的作用和应用场景\"><a href=\"#BFC的作用和应用场景\" class=\"headerlink\" title=\"BFC的作用和应用场景\"></a>BFC的作用和应用场景</h3><ol>\n<li>清楚内部浮动</li>\n<li>外边距折叠问题</li>\n<li>多栏式布局<br>（因为网络很多博文对这部分都图文并茂地讲得很清楚了，这里只是轻轻带过~，但是重点是要知道BFC这个东西延伸出来的东西原来都是我们经常用到的啊！！！（只知其然不知其所有然的我露出细思极恐状））</li>\n</ol>\n<h3 id=\"拓展延伸思考\"><a href=\"#拓展延伸思考\" class=\"headerlink\" title=\"拓展延伸思考\"></a>拓展延伸思考</h3><p>看完了网络上各位大神对BFC详尽的介绍，总算知道了BFC这个家伙是干吗的了。这个学习的过程也伴随着几个曾经很纠结的问题。</p>\n<ol>\n<li><p><strong>页面写了普通的几个div，这时就存在了BFC了吗？</strong></p>\n<p>实践证明是的，因为你写两个div时会发现它们垂直排列，而且垂直的边距margin发生了重叠，这符合BFC的特性。说明了根元素(html)会生成默认BFC供其子孙block-level box使用。</p>\n</li>\n<li><p><strong>在和舍友讨论这个问题时，舍友说到，为什么明明叫做块级格式化上下文，生成一个BFC的条件怎么好像跟块级元素不搭边呢？</strong><br>盒子是CSS布局的基本单位，CSS有不同类型的盒子，不同的盒子会参与不同的FC。display为block，table等的元素会生成块级盒子，参与BFC（html生成的默认的BFC）。但其实BFC这个概念对我们的最大作用是如何生成一个新的BFC,来达到自己想要的布局排版方式。</p>\n</li>\n<li><p><strong>包含了浮动元素的父元素为什么高度会塌陷？给父元素添加了overflow：hidden|auto是生成了一个新的BFC，可为什么能让父元素高度与浮动元素一致了呢？</strong><br>（我曾经也想过用BFC这个问题来解答，但发现论据不足。后来看到知乎有一个回答还是不能大彻大悟（就像学术领域的一些问题得到的回答往往是权威两个字），后来又看了CSS魔法堂的一篇文章，才算是真正理解。）<br>第一个问题，为什么div中仅含浮动元素时，盒子高度为0?这个要归咎于block-level box对高度的计算（详见文档，其中提到out-flow box不影响block-level box高度的计算。）<br>第二个问题，为什么通过overflow产生了一个新的BFC就能让父元素高度不为0了呢？对于产生新的BFC的盒子而言，会有以下几个现象：</p>\n<ul>\n<li>不发生外边折叠</li>\n<li>out-flow box纳入block-level box高度的计算</li>\n<li>不与positioning scheme为floats的兄弟盒子重叠</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h4><p>对于IFC，等自己了解完有勇气了再写吧~！另外有了点人生感悟想拿来分享：年少无知的自己曾经觉得CSS和html是最容易学最小儿科的东西，觉得大不了用时有不会的再看看文档大概也能实现自己想要的效果。但是现在深刻体会到了CSS入门简单，精通难（前端也是这个道理）。很多时候原来我们不仅要知道怎么去实现一个效果和样式，更要去探究其实现的原理，通过探究学习这个原理，往往会发现一个我们未知的真理，而这个真理将带我们有一个质的飞跃~！</p>\n<p>在此感谢巨人让我看的更高<br>参考内容：<br><a href=\"http://www.xiaomeiti.com/note/3608\" target=\"_blank\" rel=\"external\">小科普：到底什么是BFC、IFC、GFC和FFC，次奥？</a><br><a href=\"http://www.html-js.com/article/1866\" target=\"_blank\" rel=\"external\">CSS之BFC详解</a><br><a href=\"https://segmentfault.com/a/1190000004625635#articleHeader11\" target=\"_blank\" rel=\"external\">CSS魔法堂：重新认识Box Model、IFC、BFC和Collapsing margins</a><br><a href=\"https://www.w3.org/TR/CSS2/visuren.html#block-formatting\" target=\"_blank\" rel=\"external\">W3C对BFC的定义</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>昨天经历了一次百度的电话面试（一次带着淡淡忧伤的面试，有时间再写个面筋）被问到BFC这个东西问到傻了。昨晚谷歌看了好多篇关于BFC的文章。在终于理清了BFC这个东西时，突然就有想写篇博文的冲动了呢！（怒~）</p>\n<hr>\n<p>在学习BFC这个东西前，先说说FC这两个字的含义吧。<br><strong>FC(Formatting Context):格式化上下文是W3C CSS2.1规范中的一个概念。它是页面中的一块渲染区域，并且有一套渲染规则，它决定了其子元素将如何定位，以及和其他元素的关系和相互作用。</strong>CSS2有BFC,IFC，CSS3还增加了GFC和FFC(突然想去KFC吃个全家桶来冷静一下…)</p>\n<h3 id=\"BFC\"><a href=\"#BFC\" class=\"headerlink\" title=\"BFC\"></a>BFC</h3><blockquote>\n<p>浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的块级格式化上下文。</p>\n</blockquote>\n<h4 id=\"BFC的特性\"><a href=\"#BFC的特性\" class=\"headerlink\" title=\"BFC的特性\"></a>BFC的特性</h4><ol>\n<li>内部的Box会在垂直方向，从顶部开始一个接一个的放置。</li>\n<li>Box垂直方向之间的距离由margin决定，同一个BFC的两个相邻BOX的margin会发生叠加。</li>\n<li>每个元素的左边margin会与包含的box的左border相接触。</li>\n<li>BFC的区域不会与float box叠加。</li>\n<li>BFC是页面一个隔离的独立容器。与外面的元素互补影响。</li>\n<li>计算BFC的高度时，浮动元素也参与计算。</li>\n</ol>\n<h3 id=\"创建一个新的BFC的条件\"><a href=\"#创建一个新的BFC的条件\" class=\"headerlink\" title=\"创建一个新的BFC的条件\"></a>创建一个新的BFC的条件</h3><p>根据定义就可以知道，当一个元素的样式符合以下条件之一时，就可以创建一个新的BFC:</p>\n<ul>\n<li>float：left|right；</li>\n<li>position：absolute|fixed;</li>\n<li>display:table-cell|table-caption|inline-block;</li>\n<li>overflow:hidden|scroll|auto;</li>\n</ul>\n<h3 id=\"BFC的作用和应用场景\"><a href=\"#BFC的作用和应用场景\" class=\"headerlink\" title=\"BFC的作用和应用场景\"></a>BFC的作用和应用场景</h3><ol>\n<li>清楚内部浮动</li>\n<li>外边距折叠问题</li>\n<li>多栏式布局<br>（因为网络很多博文对这部分都图文并茂地讲得很清楚了，这里只是轻轻带过~，但是重点是要知道BFC这个东西延伸出来的东西原来都是我们经常用到的啊！！！（只知其然不知其所有然的我露出细思极恐状））</li>\n</ol>\n<h3 id=\"拓展延伸思考\"><a href=\"#拓展延伸思考\" class=\"headerlink\" title=\"拓展延伸思考\"></a>拓展延伸思考</h3><p>看完了网络上各位大神对BFC详尽的介绍，总算知道了BFC这个家伙是干吗的了。这个学习的过程也伴随着几个曾经很纠结的问题。</p>\n<ol>\n<li><p><strong>页面写了普通的几个div，这时就存在了BFC了吗？</strong></p>\n<p>实践证明是的，因为你写两个div时会发现它们垂直排列，而且垂直的边距margin发生了重叠，这符合BFC的特性。说明了根元素(html)会生成默认BFC供其子孙block-level box使用。</p>\n</li>\n<li><p><strong>在和舍友讨论这个问题时，舍友说到，为什么明明叫做块级格式化上下文，生成一个BFC的条件怎么好像跟块级元素不搭边呢？</strong><br>盒子是CSS布局的基本单位，CSS有不同类型的盒子，不同的盒子会参与不同的FC。display为block，table等的元素会生成块级盒子，参与BFC（html生成的默认的BFC）。但其实BFC这个概念对我们的最大作用是如何生成一个新的BFC,来达到自己想要的布局排版方式。</p>\n</li>\n<li><p><strong>包含了浮动元素的父元素为什么高度会塌陷？给父元素添加了overflow：hidden|auto是生成了一个新的BFC，可为什么能让父元素高度与浮动元素一致了呢？</strong><br>（我曾经也想过用BFC这个问题来解答，但发现论据不足。后来看到知乎有一个回答还是不能大彻大悟（就像学术领域的一些问题得到的回答往往是权威两个字），后来又看了CSS魔法堂的一篇文章，才算是真正理解。）<br>第一个问题，为什么div中仅含浮动元素时，盒子高度为0?这个要归咎于block-level box对高度的计算（详见文档，其中提到out-flow box不影响block-level box高度的计算。）<br>第二个问题，为什么通过overflow产生了一个新的BFC就能让父元素高度不为0了呢？对于产生新的BFC的盒子而言，会有以下几个现象：</p>\n<ul>\n<li>不发生外边折叠</li>\n<li>out-flow box纳入block-level box高度的计算</li>\n<li>不与positioning scheme为floats的兄弟盒子重叠</li>\n</ul>\n</li>\n</ol>\n<h4 id=\"后话\"><a href=\"#后话\" class=\"headerlink\" title=\"后话\"></a>后话</h4><p>对于IFC，等自己了解完有勇气了再写吧~！另外有了点人生感悟想拿来分享：年少无知的自己曾经觉得CSS和html是最容易学最小儿科的东西，觉得大不了用时有不会的再看看文档大概也能实现自己想要的效果。但是现在深刻体会到了CSS入门简单，精通难（前端也是这个道理）。很多时候原来我们不仅要知道怎么去实现一个效果和样式，更要去探究其实现的原理，通过探究学习这个原理，往往会发现一个我们未知的真理，而这个真理将带我们有一个质的飞跃~！</p>\n<p>在此感谢巨人让我看的更高<br>参考内容：<br><a href=\"http://www.xiaomeiti.com/note/3608\" target=\"_blank\" rel=\"external\">小科普：到底什么是BFC、IFC、GFC和FFC，次奥？</a><br><a href=\"http://www.html-js.com/article/1866\" target=\"_blank\" rel=\"external\">CSS之BFC详解</a><br><a href=\"https://segmentfault.com/a/1190000004625635#articleHeader11\" target=\"_blank\" rel=\"external\">CSS魔法堂：重新认识Box Model、IFC、BFC和Collapsing margins</a><br><a href=\"https://www.w3.org/TR/CSS2/visuren.html#block-formatting\" target=\"_blank\" rel=\"external\">W3C对BFC的定义</a></p>\n"},{"title":"React中的样式处理","date":"2017-06-20T15:13:58.000Z","_content":"\n 最近有在写react应用了，以前总是图简单，直接用inline style。趁着有空，总结一下除了inline style之外更优的react样式处理方法。\n\n1.classname库\n\n便于给组件动态设置className。\n\n```javascript\nimpoert React, { Componet } from 'react';\nimport classNames from 'classnames';\n\nclass Button extends Component {\n  render() {\n    const btnClass = classNames({\n      'btn': true,\n      'btn-pressed': this.state.isPressed,\n      'btn-over': !this.state.isPressed && this.state.isHovered,\n    });\n    return <button className={btnClass}>{this.props.label}</button>\n  }\n}\n```\n\n1. CSS Modules\n\n   实现组件样式的局部作用域和模块依赖问题。\n   使用方法 :\n   webpack的css-loader内置了CSS Modules功能，所以使用CSS Modules首先要在webpack配置中启用css Modules，如下\n\n```javascript\ncss?modules&localIdentName=[name]__[local]-[hash:base64:5]\n```\n\n​\t其中加上modules即为启用，localIdentName是设置样式的命名规则。\n​\t接着在组件文件中将css样式import进来使用即可。\n\n```\n.normal {\n  color: #eee;\n}\nimport style from './styles.css';\nclass Button extends Component {\n  render(){\n    return <button className={style.normal}></button>    \n  }\n}\n```\n\n其它注意\n\n1. 全局样式：CSS Module默认采用了局部样式，即样式外用:local包裹，生成的css名字附加了一串随机数，以此来实现样式的局部化。\n   自己可以用:global来实现全局样式。\n\n   ``` css\n   :global(.btn) {\n   …\n   }\n   // more than one syle in gloabl\n   :global {\n   .normal{\n    ...\n   }\n   .danger{\n     ...\n     }\n   }\n   ```\n\n   2. 样式复用：使用compose\n\n```\n.base{\n  //通用样式\n}\n.normal{\n    composes:base;\n      //normal独有样式\n}\n```\n\n​\t此时使用了normal样式的元素或者组件实际会生成两个class。\n\n3. CSS Modules只会转换class名相关的样式，即只会转变类选择器。所以id选择器或者其他属性选择器的样式不会被css modules进行转化。\n\n4. CSS Mdoules结合classNames在react中的应用：\n\n   ```javascript\n   ...\n   import className from 'classnames';\n   import styles from './styles.css';\n\n   class Dialog extends Component {\n       render() {\n       const cx = classNames({\n         confirm: !this.state.disabled,\n         disabledConfirm: this.state.disabled,\n       });\n         return (\n             <div className={styles.root}>\n               <a className={styles[cx]}>Confirm</a>    \n           </div>\n         )\n       }\n   }\n   ```\n\n5. 结合react-css-modules库，避免重复输入styles.xx。\n\n   ```\n    //....\n   import CSSModules from 'react-css-modules';\n    //...\n       return (\n            <div styleName={root}>\n               <a styleName={cx}>Confirm</a>    \n           </div>\n       )\n    export default CSSModules(Dialog, styles);\n   ```\n\n其它：\n\nts中import css文件的时候报错。\n\n解决方法：增加一个module definition告诉typescript可以import css文件。\n\n```javascript\n// declaration.d.ts\ndeclare module '*.css' {\n    const content: any;\n    export default content;\n}\n```\n\n","source":"_posts/React中的样式处理.md","raw":"---\ntitle: React中的样式处理\ndate: 2017-6-20 23:13:58\ntags: 前端框架\n---\n\n 最近有在写react应用了，以前总是图简单，直接用inline style。趁着有空，总结一下除了inline style之外更优的react样式处理方法。\n\n1.classname库\n\n便于给组件动态设置className。\n\n```javascript\nimpoert React, { Componet } from 'react';\nimport classNames from 'classnames';\n\nclass Button extends Component {\n  render() {\n    const btnClass = classNames({\n      'btn': true,\n      'btn-pressed': this.state.isPressed,\n      'btn-over': !this.state.isPressed && this.state.isHovered,\n    });\n    return <button className={btnClass}>{this.props.label}</button>\n  }\n}\n```\n\n1. CSS Modules\n\n   实现组件样式的局部作用域和模块依赖问题。\n   使用方法 :\n   webpack的css-loader内置了CSS Modules功能，所以使用CSS Modules首先要在webpack配置中启用css Modules，如下\n\n```javascript\ncss?modules&localIdentName=[name]__[local]-[hash:base64:5]\n```\n\n​\t其中加上modules即为启用，localIdentName是设置样式的命名规则。\n​\t接着在组件文件中将css样式import进来使用即可。\n\n```\n.normal {\n  color: #eee;\n}\nimport style from './styles.css';\nclass Button extends Component {\n  render(){\n    return <button className={style.normal}></button>    \n  }\n}\n```\n\n其它注意\n\n1. 全局样式：CSS Module默认采用了局部样式，即样式外用:local包裹，生成的css名字附加了一串随机数，以此来实现样式的局部化。\n   自己可以用:global来实现全局样式。\n\n   ``` css\n   :global(.btn) {\n   …\n   }\n   // more than one syle in gloabl\n   :global {\n   .normal{\n    ...\n   }\n   .danger{\n     ...\n     }\n   }\n   ```\n\n   2. 样式复用：使用compose\n\n```\n.base{\n  //通用样式\n}\n.normal{\n    composes:base;\n      //normal独有样式\n}\n```\n\n​\t此时使用了normal样式的元素或者组件实际会生成两个class。\n\n3. CSS Modules只会转换class名相关的样式，即只会转变类选择器。所以id选择器或者其他属性选择器的样式不会被css modules进行转化。\n\n4. CSS Mdoules结合classNames在react中的应用：\n\n   ```javascript\n   ...\n   import className from 'classnames';\n   import styles from './styles.css';\n\n   class Dialog extends Component {\n       render() {\n       const cx = classNames({\n         confirm: !this.state.disabled,\n         disabledConfirm: this.state.disabled,\n       });\n         return (\n             <div className={styles.root}>\n               <a className={styles[cx]}>Confirm</a>    \n           </div>\n         )\n       }\n   }\n   ```\n\n5. 结合react-css-modules库，避免重复输入styles.xx。\n\n   ```\n    //....\n   import CSSModules from 'react-css-modules';\n    //...\n       return (\n            <div styleName={root}>\n               <a styleName={cx}>Confirm</a>    \n           </div>\n       )\n    export default CSSModules(Dialog, styles);\n   ```\n\n其它：\n\nts中import css文件的时候报错。\n\n解决方法：增加一个module definition告诉typescript可以import css文件。\n\n```javascript\n// declaration.d.ts\ndeclare module '*.css' {\n    const content: any;\n    export default content;\n}\n```\n\n","slug":"React中的样式处理","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwmo0004cgesr1jqoky2","content":"<p> 最近有在写react应用了，以前总是图简单，直接用inline style。趁着有空，总结一下除了inline style之外更优的react样式处理方法。</p>\n<p>1.classname库</p>\n<p>便于给组件动态设置className。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">impoert React, &#123; Componet &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> classNames <span class=\"keyword\">from</span> <span class=\"string\">'classnames'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Button</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> btnClass = classNames(&#123;</div><div class=\"line\">      <span class=\"string\">'btn'</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"string\">'btn-pressed'</span>: <span class=\"keyword\">this</span>.state.isPressed,</div><div class=\"line\">      <span class=\"string\">'btn-over'</span>: !<span class=\"keyword\">this</span>.state.isPressed &amp;&amp; <span class=\"keyword\">this</span>.state.isHovered,</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;button className=&#123;btnClass&#125;&gt;&#123;this.props.label&#125;&lt;/button&gt;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>CSS Modules</p>\n<p>实现组件样式的局部作用域和模块依赖问题。<br>使用方法 :<br>webpack的css-loader内置了CSS Modules功能，所以使用CSS Modules首先要在webpack配置中启用css Modules，如下</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">css?modules&amp;localIdentName=[name]__[local]-[hash:base64:<span class=\"number\">5</span>]</div></pre></td></tr></table></figure>\n<p>​    其中加上modules即为启用，localIdentName是设置样式的命名规则。<br>​    接着在组件文件中将css样式import进来使用即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.normal &#123;</div><div class=\"line\">  color: #eee;</div><div class=\"line\">&#125;</div><div class=\"line\">import style from &apos;./styles.css&apos;;</div><div class=\"line\">class Button extends Component &#123;</div><div class=\"line\">  render()&#123;</div><div class=\"line\">    return &lt;button className=&#123;style.normal&#125;&gt;&lt;/button&gt;    </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其它注意</p>\n<ol>\n<li><p>全局样式：CSS Module默认采用了局部样式，即样式外用:local包裹，生成的css名字附加了一串随机数，以此来实现样式的局部化。<br>自己可以用:global来实现全局样式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-pseudo\">:global(.btn)</span> &#123;</div><div class=\"line\">…</div><div class=\"line\">&#125;</div><div class=\"line\">// more than one syle in gloabl</div><div class=\"line\"><span class=\"selector-pseudo\">:global</span> &#123;</div><div class=\"line\">.normal&#123;</div><div class=\"line\"> ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.danger</span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>样式复用：使用compose</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.base&#123;</div><div class=\"line\">  //通用样式</div><div class=\"line\">&#125;</div><div class=\"line\">.normal&#123;</div><div class=\"line\">    composes:base;</div><div class=\"line\">      //normal独有样式</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​    此时使用了normal样式的元素或者组件实际会生成两个class。</p>\n<ol>\n<li><p>CSS Modules只会转换class名相关的样式，即只会转变类选择器。所以id选择器或者其他属性选择器的样式不会被css modules进行转化。</p>\n</li>\n<li><p>CSS Mdoules结合classNames在react中的应用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">import</span> className <span class=\"keyword\">from</span> <span class=\"string\">'classnames'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> styles <span class=\"keyword\">from</span> <span class=\"string\">'./styles.css'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dialog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> cx = classNames(&#123;</div><div class=\"line\">      confirm: !<span class=\"keyword\">this</span>.state.disabled,</div><div class=\"line\">      disabledConfirm: <span class=\"keyword\">this</span>.state.disabled,</div><div class=\"line\">    &#125;);</div><div class=\"line\">      <span class=\"keyword\">return</span> (</div><div class=\"line\">          &lt;div className=&#123;styles.root&#125;&gt;</div><div class=\"line\">            &lt;a className=&#123;styles[cx]&#125;&gt;Confirm&lt;<span class=\"regexp\">/a&gt;    </span></div><div class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</div><div class=\"line\">      )</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>结合react-css-modules库，避免重复输入styles.xx。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> //....</div><div class=\"line\">import CSSModules from &apos;react-css-modules&apos;;</div><div class=\"line\"> //...</div><div class=\"line\">    return (</div><div class=\"line\">         &lt;div styleName=&#123;root&#125;&gt;</div><div class=\"line\">            &lt;a styleName=&#123;cx&#125;&gt;Confirm&lt;/a&gt;    </div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">    )</div><div class=\"line\"> export default CSSModules(Dialog, styles);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其它：</p>\n<p>ts中import css文件的时候报错。</p>\n<p>解决方法：增加一个module definition告诉typescript可以import css文件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// declaration.d.ts</span></div><div class=\"line\">declare <span class=\"built_in\">module</span> <span class=\"string\">'*.css'</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> content: any;</div><div class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> content;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p> 最近有在写react应用了，以前总是图简单，直接用inline style。趁着有空，总结一下除了inline style之外更优的react样式处理方法。</p>\n<p>1.classname库</p>\n<p>便于给组件动态设置className。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">impoert React, &#123; Componet &#125; <span class=\"keyword\">from</span> <span class=\"string\">'react'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> classNames <span class=\"keyword\">from</span> <span class=\"string\">'classnames'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Button</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">  render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> btnClass = classNames(&#123;</div><div class=\"line\">      <span class=\"string\">'btn'</span>: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"string\">'btn-pressed'</span>: <span class=\"keyword\">this</span>.state.isPressed,</div><div class=\"line\">      <span class=\"string\">'btn-over'</span>: !<span class=\"keyword\">this</span>.state.isPressed &amp;&amp; <span class=\"keyword\">this</span>.state.isHovered,</div><div class=\"line\">    &#125;);</div><div class=\"line\">    <span class=\"keyword\">return</span> &lt;button className=&#123;btnClass&#125;&gt;&#123;this.props.label&#125;&lt;/button&gt;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li><p>CSS Modules</p>\n<p>实现组件样式的局部作用域和模块依赖问题。<br>使用方法 :<br>webpack的css-loader内置了CSS Modules功能，所以使用CSS Modules首先要在webpack配置中启用css Modules，如下</p>\n</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">css?modules&amp;localIdentName=[name]__[local]-[hash:base64:<span class=\"number\">5</span>]</div></pre></td></tr></table></figure>\n<p>​    其中加上modules即为启用，localIdentName是设置样式的命名规则。<br>​    接着在组件文件中将css样式import进来使用即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">.normal &#123;</div><div class=\"line\">  color: #eee;</div><div class=\"line\">&#125;</div><div class=\"line\">import style from &apos;./styles.css&apos;;</div><div class=\"line\">class Button extends Component &#123;</div><div class=\"line\">  render()&#123;</div><div class=\"line\">    return &lt;button className=&#123;style.normal&#125;&gt;&lt;/button&gt;    </div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其它注意</p>\n<ol>\n<li><p>全局样式：CSS Module默认采用了局部样式，即样式外用:local包裹，生成的css名字附加了一串随机数，以此来实现样式的局部化。<br>自己可以用:global来实现全局样式。</p>\n<figure class=\"highlight css\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"selector-pseudo\">:global(.btn)</span> &#123;</div><div class=\"line\">…</div><div class=\"line\">&#125;</div><div class=\"line\">// more than one syle in gloabl</div><div class=\"line\"><span class=\"selector-pseudo\">:global</span> &#123;</div><div class=\"line\">.normal&#123;</div><div class=\"line\"> ...</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"selector-class\">.danger</span>&#123;</div><div class=\"line\">  ...</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<ol>\n<li>样式复用：使用compose</li>\n</ol>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">.base&#123;</div><div class=\"line\">  //通用样式</div><div class=\"line\">&#125;</div><div class=\"line\">.normal&#123;</div><div class=\"line\">    composes:base;</div><div class=\"line\">      //normal独有样式</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>​    此时使用了normal样式的元素或者组件实际会生成两个class。</p>\n<ol>\n<li><p>CSS Modules只会转换class名相关的样式，即只会转变类选择器。所以id选择器或者其他属性选择器的样式不会被css modules进行转化。</p>\n</li>\n<li><p>CSS Mdoules结合classNames在react中的应用：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">...</div><div class=\"line\"><span class=\"keyword\">import</span> className <span class=\"keyword\">from</span> <span class=\"string\">'classnames'</span>;</div><div class=\"line\"><span class=\"keyword\">import</span> styles <span class=\"keyword\">from</span> <span class=\"string\">'./styles.css'</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Dialog</span> <span class=\"keyword\">extends</span> <span class=\"title\">Component</span> </span>&#123;</div><div class=\"line\">    render() &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> cx = classNames(&#123;</div><div class=\"line\">      confirm: !<span class=\"keyword\">this</span>.state.disabled,</div><div class=\"line\">      disabledConfirm: <span class=\"keyword\">this</span>.state.disabled,</div><div class=\"line\">    &#125;);</div><div class=\"line\">      <span class=\"keyword\">return</span> (</div><div class=\"line\">          &lt;div className=&#123;styles.root&#125;&gt;</div><div class=\"line\">            &lt;a className=&#123;styles[cx]&#125;&gt;Confirm&lt;<span class=\"regexp\">/a&gt;    </span></div><div class=\"line\"><span class=\"regexp\">        &lt;/</span>div&gt;</div><div class=\"line\">      )</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>结合react-css-modules库，避免重复输入styles.xx。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"> //....</div><div class=\"line\">import CSSModules from &apos;react-css-modules&apos;;</div><div class=\"line\"> //...</div><div class=\"line\">    return (</div><div class=\"line\">         &lt;div styleName=&#123;root&#125;&gt;</div><div class=\"line\">            &lt;a styleName=&#123;cx&#125;&gt;Confirm&lt;/a&gt;    </div><div class=\"line\">        &lt;/div&gt;</div><div class=\"line\">    )</div><div class=\"line\"> export default CSSModules(Dialog, styles);</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>其它：</p>\n<p>ts中import css文件的时候报错。</p>\n<p>解决方法：增加一个module definition告诉typescript可以import css文件。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// declaration.d.ts</span></div><div class=\"line\">declare <span class=\"built_in\">module</span> <span class=\"string\">'*.css'</span> &#123;</div><div class=\"line\">    <span class=\"keyword\">const</span> content: any;</div><div class=\"line\">    <span class=\"keyword\">export</span> <span class=\"keyword\">default</span> content;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n"},{"title":"angularJS初体验","date":"2016-09-11T15:13:58.000Z","_content":"\n实习的一个运营后台开发的项目，也许是实习期间对我而言最有挑战性的一次工作，因为这是初次实践angularJS。在边学边做的过程，收获不小，因此想趁着感受还比较深之时把学习和使用AngularJS进行开发的一些体验记录下来（AngularJS 1.x版本），这里主要总结学习angular的感受。（类似一篇读后感，并非入门教程）\n\n### 背景\n\n> 当你决定去改变一些东西的时，你应该知道你为什么要这样做，这很重要。\n\n公司要重新开发运营后台的命令一下来，进度瞬间也被排的紧凑。后端人员先走一步，把接口完成得差不多，我看了一下接口文档，背后一阵凉风吹过，光是课程管理模块就有足足两页（十几个接口），大致看了一下需求，多数功能都是建立在CRUD上的。\n\n即使熟悉使用Jquery来进行web开发的人，尝试用jquery+api来完成这个任务也会大受打击，即便硬着头皮实现了这个系统，后期的维护和修改必定也会是一场灾难。所以，对于这类大型web应用来说，前端开发使用框架时必要的，这不仅提高我们的开发效率，同时支持我们编写更加整洁的代码。\n\n早有耳闻AngularJS作为一个客户端MVC框架，尤其适合编写有大量CRUD操作的，具体Ajax风格的富客户端应用，咦(*@ο@*) 这不就是我现在想要的吗？加之学习了解了一段时间之后，心里一阵呐喊“AngularJS，去吧，就决定就是你了”。（盗用下《宠物小精灵》的台词）\n\n### AngularJS初印象\n\n与react.js不同，AngularJS是一个完整的前端框架，模板、控制器、过滤器、服务等一应俱全，其依赖注入系统更是让测试变得更加简单。以下是学习过程让我比较深刻的几点。\n\n#### 视图与指令\n\nangular与HTML和DOM有着密切的联系。AngularJS依靠浏览器去解析模板文本（就像浏览器对HTML文档的解析）。浏览器将html解析成一个DOM tree后，AngularJS就参与进来，开始遍历解析好的DOM结构，遇到指令，就执行相关逻辑，将指令转换成页面的动态部分。\n\n> Angular提供了很多遍历的指令，但重要的不是这些指令的语法或者功能，而是隐藏在表象下的关于如何构建UI组件的AngularJS哲学。\n\n刚学习angularJS，都是从一个hello world和即时显示输入框输入内容的demo开始。尤其是输入框的例子让人惊叹不已。因为如果用js或者jq来实现，你必须先获取输入框的内容，再通过dom操作显示出其文本。而用angularJS，你只需引入angular的库，利用ng-app指令来引导（bootstrap）该应用，使用ng-model来进行数据绑定，angular就会自动去理解解释其中的指令帮我们做一些事情，比如在输入框那里例子实现数据的即时刷新。开发过程，我也逐步在发现自己的编程方式发生了改变，但无法用合理的语言来表达，直到我看了《精通AngularJS》里面的一段话。\n\nAngularJS提倡声明式UI结构，让模板专注于描述所需要的效果，而非实现。举例子，想想在输入框输入内容即时显示其文本的入门demo，以及ng-class来动态添加class，以及ng-click等来绑定点击事件等的编程是不是和我们平日用jquery的编程方式不大一样？（用jq为了实现以上的效果，你不得不按部就班地去操作修改dom来达到目的）。\n\n传统的开发采用命令式的编程风格，我们用js或者jq控制一切和调整每个细节。但“掌控一切”的代价，就是编写大量底层的，重复的代码。AngularJS采用的声明式编程风格更具表现力，Angular的支持，让开发者从严格的底层实现中解放出来，写出更简洁易读的代码，除了开发者实现自定义指令时会需要有步骤详细的底层DOM操作，开发过程我们很少去操作DOM。\n\n> 永远不要在AngularJS控制器中去操纵DOM，在控制器中获取对DOM元素的引用，操纵元素的属性，预示着在用命令式编程风格来构建UI—这违背了AngularJS之道。\n\n但想要更有效地使用模板和指令，就必须去了解更多的内部机制。这或许就是深入学习AngularJS的难点吧。毕竟声明式编程风格的一个基础，就是建立一个能够正确解释高级命令的机制。\n\n#### 作用域\n\n$scope这个东西确实引起了我的注意，虽然听说angular2已经把它废弃了，但我还是想说一下它以及angular里面的作用域。\n\n通过ng-controller指令来指定使用的控制器，一个作用域实例就会被初始化。作用域控制了该领域模型中的哪些数据和操作在视图上时有效的，而控制器提供了模型的初始值并处理UI相关的行为。\n\nangularjs的作用域也拥有层级的概念。$rootScope是顶级作用域，每个控制器用拥有自己的$scope。每个作用域拥有自己的整套模型值，不同的作用域定义同名的变量，不会造成命名冲突。并且，与js原型基础的规则类似，angular的作用域也有继承的概念，子scope可以访问父scope的变量和对象。\n\n但是，作用域层级继承也具备一定的风险。读操作的时候，一切都在自己的预料之中。但写操作的时候，要注意的一点是，子作用域的写操作不会影响父作用域。要经历避免直接绑定变量给作用域属性，而是采用对象属性的双向数据绑定。\n\n**作用域层级和事件系统**\nangular通过传播带有信息的命名事件，允许跨越作用域层级。每个作用域都有$on方法，用于注册作用域的事件处理程序。angular支持通过$emit进行向上分发和$broadcast进行向下分发。\n\n#### 模块与依赖注入\n\nAngularJS拥有全套的API来定义模块以及在模块中注册对象。AngularJS为自己定义了全局命名空间angular，它提供了多种功能和函数，比如.module()、.controller（）、.filter（）等。\n\n模块模式在组织代码方面非常有用，此外，AngularJS也提供了一套依赖注入系统来声明模块和模块注册对象的相互依赖关系。(学习这个的时候让我想起学习javaEE时的依赖注入，印象中在一个对象使用另外一个对象必须用new来实例化，但是通过spring的依赖注入功能可以避免在对象中new一个对象造成的高耦合..)\n\nangularJS内建的依赖注入引擎，它能理解对象对其协作对象的需求，找到所需的协作对象，连接协作对象已形成完备的应用。\n\n> 依靠这套依赖管理系统，开发者：“为了正常工作，我需要一个依赖，我不知道它从哪儿来，也不知道它如何创建，我只知道我需要它，所以请为我提供它”。\n\n声明依赖关系的作用，让对象无需担心协作对象的生命周期。你甚至可以随意交换协作对象，通过替换服务来建立不同的应用，而这点也是有效进行单元测试的关键。（如果没有将其真实实现替换为伪造实现的能力，便很难孤立地对一个对象进行测试）。\n\n**AngularJS的注册服务** 接入依赖注入之前，是创建一个对象并将对象注册在模块上。开发者不直接注册对象的实例，而是将对象创建的方案抛给依赖注入系统，然后AngularJS解释这些方案以初始化该对象，并连接它们成为一个可运行的应用。\n\nAngularJS的$provide服务可以注册不同的对象创建方案，之后$inject服务会解释这些方案，解决所有依赖关系，生产完备而可用的对象实例。总而言之，angularJS模块保存对象实例，而我们控制这些对象的创建，AngularJS提供以下几种创建对象的方式。\n\n- value：可用于注册已初始化好的对象\n  这种注册方法只对非常简单的对象有用，因为通过这种方式注册的对象不能依赖其他对象。\n- service：用于注册构造函数，让依赖该对象的模块无需对其依赖对象进行初始化（类似消除new关键字的功能）。\n- factory：任何能够创建对象的函数都可以被注册，因此相比service而言，它更加灵活。factory是让对象加入依赖注入最常用的方法，它可以实现复杂的对象创建逻辑。因为可以是普通的函数，利用词法作用域可以来模拟“私有”变量，因此服务的一些实现细节。\n- constant：可用于创建不同应用使用的共通服务（如可供服务的客进行定制的配置信息）\n- provider:以上的所有注册方法，都是最通用provider的特殊类型。\n\n**模块的生命周期**\nangularJS将模块的生命周期分为两个阶段：\n\n- 配置阶段：收集对象的创建方案，并进行配置。\n- 运行阶段：执行所有初始化后的逻辑。\n\n在配置阶段，仅运行constant和provider的注入，而在运行阶段，可以注入provider的任意对象。\n\n### 总结\n\n世界上没有最完美的框架，只有最合适的框架，了解和认识Angular与众不同的地方，可以让我们判断它到底适不适合用在某一个项目上，angularJS的特点总结如下：\n\n- 自动刷新与双向数据绑定，让开发者从显式触发来进行UI重绘的枯燥工作中解放\n- 以HTML语法为基础的动态DOM充当模板语言，可通过创建指令来扩展现存的html标签库。\n- 声明式UI编程风格，精炼并附有表达力。\n- 依赖注入使其具备良好的测试性。\n\n学习和实践Angular的过程，体验到Angular采用了完全不同的方法来构建UI，由模型的变化来取得模板更新。虽然Jquery功能很强大，但因为是以编写DOM操作为中心的代码，对于成熟和庞大、互动性相对复杂的应用来说，代码就会变得难以管理。\n\n尽管有人和我说过，现在学习angular(1.x)已经落伍啦，react，vue和angular2才是最火的，但是这次通过学习和使用angular，我得到的回报大于投资。angular1确实还存在一些缺陷可供改善的地方，但不可否认，它的出现在当时肯定给web开发生态带来了一次震荡，也给前端er们催生了许多创意（对浏览器内核以及web前端的开发模式）。\n\n##### 附：angular的一些学习资源\n\n网上资源：\n[angularJS主页](http://www.angularjs.org/)\n[stackoverflow的angular专题](http://stackoverflow.com/questions/tagged/angularjs)\n[awesome-angularjs](https://github.com/gianarb/awesome-angularjs)\n[angularJS最佳实践](https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md)\n\n工具：\n[AngularJS Batarang-官方提供的chrome插件：可查看作用域和性能](https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk)\n\n书籍：\n《angularJS开发秘笈》\n《angularJS权威指南》\n《精通angularJS》（墙裂推荐这本！！尤其在带着实践遇到的疑问去看这本书，里面也讲了一些最佳实践，受益匪浅，此次的文章很多东西也是摘取于此书的）","source":"_posts/angularJS初体验.md","raw":"---\ntitle: angularJS初体验\ndate: 2016-9-11 23:13:58\ntags: 前端框架\n---\n\n实习的一个运营后台开发的项目，也许是实习期间对我而言最有挑战性的一次工作，因为这是初次实践angularJS。在边学边做的过程，收获不小，因此想趁着感受还比较深之时把学习和使用AngularJS进行开发的一些体验记录下来（AngularJS 1.x版本），这里主要总结学习angular的感受。（类似一篇读后感，并非入门教程）\n\n### 背景\n\n> 当你决定去改变一些东西的时，你应该知道你为什么要这样做，这很重要。\n\n公司要重新开发运营后台的命令一下来，进度瞬间也被排的紧凑。后端人员先走一步，把接口完成得差不多，我看了一下接口文档，背后一阵凉风吹过，光是课程管理模块就有足足两页（十几个接口），大致看了一下需求，多数功能都是建立在CRUD上的。\n\n即使熟悉使用Jquery来进行web开发的人，尝试用jquery+api来完成这个任务也会大受打击，即便硬着头皮实现了这个系统，后期的维护和修改必定也会是一场灾难。所以，对于这类大型web应用来说，前端开发使用框架时必要的，这不仅提高我们的开发效率，同时支持我们编写更加整洁的代码。\n\n早有耳闻AngularJS作为一个客户端MVC框架，尤其适合编写有大量CRUD操作的，具体Ajax风格的富客户端应用，咦(*@ο@*) 这不就是我现在想要的吗？加之学习了解了一段时间之后，心里一阵呐喊“AngularJS，去吧，就决定就是你了”。（盗用下《宠物小精灵》的台词）\n\n### AngularJS初印象\n\n与react.js不同，AngularJS是一个完整的前端框架，模板、控制器、过滤器、服务等一应俱全，其依赖注入系统更是让测试变得更加简单。以下是学习过程让我比较深刻的几点。\n\n#### 视图与指令\n\nangular与HTML和DOM有着密切的联系。AngularJS依靠浏览器去解析模板文本（就像浏览器对HTML文档的解析）。浏览器将html解析成一个DOM tree后，AngularJS就参与进来，开始遍历解析好的DOM结构，遇到指令，就执行相关逻辑，将指令转换成页面的动态部分。\n\n> Angular提供了很多遍历的指令，但重要的不是这些指令的语法或者功能，而是隐藏在表象下的关于如何构建UI组件的AngularJS哲学。\n\n刚学习angularJS，都是从一个hello world和即时显示输入框输入内容的demo开始。尤其是输入框的例子让人惊叹不已。因为如果用js或者jq来实现，你必须先获取输入框的内容，再通过dom操作显示出其文本。而用angularJS，你只需引入angular的库，利用ng-app指令来引导（bootstrap）该应用，使用ng-model来进行数据绑定，angular就会自动去理解解释其中的指令帮我们做一些事情，比如在输入框那里例子实现数据的即时刷新。开发过程，我也逐步在发现自己的编程方式发生了改变，但无法用合理的语言来表达，直到我看了《精通AngularJS》里面的一段话。\n\nAngularJS提倡声明式UI结构，让模板专注于描述所需要的效果，而非实现。举例子，想想在输入框输入内容即时显示其文本的入门demo，以及ng-class来动态添加class，以及ng-click等来绑定点击事件等的编程是不是和我们平日用jquery的编程方式不大一样？（用jq为了实现以上的效果，你不得不按部就班地去操作修改dom来达到目的）。\n\n传统的开发采用命令式的编程风格，我们用js或者jq控制一切和调整每个细节。但“掌控一切”的代价，就是编写大量底层的，重复的代码。AngularJS采用的声明式编程风格更具表现力，Angular的支持，让开发者从严格的底层实现中解放出来，写出更简洁易读的代码，除了开发者实现自定义指令时会需要有步骤详细的底层DOM操作，开发过程我们很少去操作DOM。\n\n> 永远不要在AngularJS控制器中去操纵DOM，在控制器中获取对DOM元素的引用，操纵元素的属性，预示着在用命令式编程风格来构建UI—这违背了AngularJS之道。\n\n但想要更有效地使用模板和指令，就必须去了解更多的内部机制。这或许就是深入学习AngularJS的难点吧。毕竟声明式编程风格的一个基础，就是建立一个能够正确解释高级命令的机制。\n\n#### 作用域\n\n$scope这个东西确实引起了我的注意，虽然听说angular2已经把它废弃了，但我还是想说一下它以及angular里面的作用域。\n\n通过ng-controller指令来指定使用的控制器，一个作用域实例就会被初始化。作用域控制了该领域模型中的哪些数据和操作在视图上时有效的，而控制器提供了模型的初始值并处理UI相关的行为。\n\nangularjs的作用域也拥有层级的概念。$rootScope是顶级作用域，每个控制器用拥有自己的$scope。每个作用域拥有自己的整套模型值，不同的作用域定义同名的变量，不会造成命名冲突。并且，与js原型基础的规则类似，angular的作用域也有继承的概念，子scope可以访问父scope的变量和对象。\n\n但是，作用域层级继承也具备一定的风险。读操作的时候，一切都在自己的预料之中。但写操作的时候，要注意的一点是，子作用域的写操作不会影响父作用域。要经历避免直接绑定变量给作用域属性，而是采用对象属性的双向数据绑定。\n\n**作用域层级和事件系统**\nangular通过传播带有信息的命名事件，允许跨越作用域层级。每个作用域都有$on方法，用于注册作用域的事件处理程序。angular支持通过$emit进行向上分发和$broadcast进行向下分发。\n\n#### 模块与依赖注入\n\nAngularJS拥有全套的API来定义模块以及在模块中注册对象。AngularJS为自己定义了全局命名空间angular，它提供了多种功能和函数，比如.module()、.controller（）、.filter（）等。\n\n模块模式在组织代码方面非常有用，此外，AngularJS也提供了一套依赖注入系统来声明模块和模块注册对象的相互依赖关系。(学习这个的时候让我想起学习javaEE时的依赖注入，印象中在一个对象使用另外一个对象必须用new来实例化，但是通过spring的依赖注入功能可以避免在对象中new一个对象造成的高耦合..)\n\nangularJS内建的依赖注入引擎，它能理解对象对其协作对象的需求，找到所需的协作对象，连接协作对象已形成完备的应用。\n\n> 依靠这套依赖管理系统，开发者：“为了正常工作，我需要一个依赖，我不知道它从哪儿来，也不知道它如何创建，我只知道我需要它，所以请为我提供它”。\n\n声明依赖关系的作用，让对象无需担心协作对象的生命周期。你甚至可以随意交换协作对象，通过替换服务来建立不同的应用，而这点也是有效进行单元测试的关键。（如果没有将其真实实现替换为伪造实现的能力，便很难孤立地对一个对象进行测试）。\n\n**AngularJS的注册服务** 接入依赖注入之前，是创建一个对象并将对象注册在模块上。开发者不直接注册对象的实例，而是将对象创建的方案抛给依赖注入系统，然后AngularJS解释这些方案以初始化该对象，并连接它们成为一个可运行的应用。\n\nAngularJS的$provide服务可以注册不同的对象创建方案，之后$inject服务会解释这些方案，解决所有依赖关系，生产完备而可用的对象实例。总而言之，angularJS模块保存对象实例，而我们控制这些对象的创建，AngularJS提供以下几种创建对象的方式。\n\n- value：可用于注册已初始化好的对象\n  这种注册方法只对非常简单的对象有用，因为通过这种方式注册的对象不能依赖其他对象。\n- service：用于注册构造函数，让依赖该对象的模块无需对其依赖对象进行初始化（类似消除new关键字的功能）。\n- factory：任何能够创建对象的函数都可以被注册，因此相比service而言，它更加灵活。factory是让对象加入依赖注入最常用的方法，它可以实现复杂的对象创建逻辑。因为可以是普通的函数，利用词法作用域可以来模拟“私有”变量，因此服务的一些实现细节。\n- constant：可用于创建不同应用使用的共通服务（如可供服务的客进行定制的配置信息）\n- provider:以上的所有注册方法，都是最通用provider的特殊类型。\n\n**模块的生命周期**\nangularJS将模块的生命周期分为两个阶段：\n\n- 配置阶段：收集对象的创建方案，并进行配置。\n- 运行阶段：执行所有初始化后的逻辑。\n\n在配置阶段，仅运行constant和provider的注入，而在运行阶段，可以注入provider的任意对象。\n\n### 总结\n\n世界上没有最完美的框架，只有最合适的框架，了解和认识Angular与众不同的地方，可以让我们判断它到底适不适合用在某一个项目上，angularJS的特点总结如下：\n\n- 自动刷新与双向数据绑定，让开发者从显式触发来进行UI重绘的枯燥工作中解放\n- 以HTML语法为基础的动态DOM充当模板语言，可通过创建指令来扩展现存的html标签库。\n- 声明式UI编程风格，精炼并附有表达力。\n- 依赖注入使其具备良好的测试性。\n\n学习和实践Angular的过程，体验到Angular采用了完全不同的方法来构建UI，由模型的变化来取得模板更新。虽然Jquery功能很强大，但因为是以编写DOM操作为中心的代码，对于成熟和庞大、互动性相对复杂的应用来说，代码就会变得难以管理。\n\n尽管有人和我说过，现在学习angular(1.x)已经落伍啦，react，vue和angular2才是最火的，但是这次通过学习和使用angular，我得到的回报大于投资。angular1确实还存在一些缺陷可供改善的地方，但不可否认，它的出现在当时肯定给web开发生态带来了一次震荡，也给前端er们催生了许多创意（对浏览器内核以及web前端的开发模式）。\n\n##### 附：angular的一些学习资源\n\n网上资源：\n[angularJS主页](http://www.angularjs.org/)\n[stackoverflow的angular专题](http://stackoverflow.com/questions/tagged/angularjs)\n[awesome-angularjs](https://github.com/gianarb/awesome-angularjs)\n[angularJS最佳实践](https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md)\n\n工具：\n[AngularJS Batarang-官方提供的chrome插件：可查看作用域和性能](https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk)\n\n书籍：\n《angularJS开发秘笈》\n《angularJS权威指南》\n《精通angularJS》（墙裂推荐这本！！尤其在带着实践遇到的疑问去看这本书，里面也讲了一些最佳实践，受益匪浅，此次的文章很多东西也是摘取于此书的）","slug":"angularJS初体验","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwmp0005cgesj936udr4","content":"<p>实习的一个运营后台开发的项目，也许是实习期间对我而言最有挑战性的一次工作，因为这是初次实践angularJS。在边学边做的过程，收获不小，因此想趁着感受还比较深之时把学习和使用AngularJS进行开发的一些体验记录下来（AngularJS 1.x版本），这里主要总结学习angular的感受。（类似一篇读后感，并非入门教程）</p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><blockquote>\n<p>当你决定去改变一些东西的时，你应该知道你为什么要这样做，这很重要。</p>\n</blockquote>\n<p>公司要重新开发运营后台的命令一下来，进度瞬间也被排的紧凑。后端人员先走一步，把接口完成得差不多，我看了一下接口文档，背后一阵凉风吹过，光是课程管理模块就有足足两页（十几个接口），大致看了一下需求，多数功能都是建立在CRUD上的。</p>\n<p>即使熟悉使用Jquery来进行web开发的人，尝试用jquery+api来完成这个任务也会大受打击，即便硬着头皮实现了这个系统，后期的维护和修改必定也会是一场灾难。所以，对于这类大型web应用来说，前端开发使用框架时必要的，这不仅提高我们的开发效率，同时支持我们编写更加整洁的代码。</p>\n<p>早有耳闻AngularJS作为一个客户端MVC框架，尤其适合编写有大量CRUD操作的，具体Ajax风格的富客户端应用，咦(<em>@ο@</em>) 这不就是我现在想要的吗？加之学习了解了一段时间之后，心里一阵呐喊“AngularJS，去吧，就决定就是你了”。（盗用下《宠物小精灵》的台词）</p>\n<h3 id=\"AngularJS初印象\"><a href=\"#AngularJS初印象\" class=\"headerlink\" title=\"AngularJS初印象\"></a>AngularJS初印象</h3><p>与react.js不同，AngularJS是一个完整的前端框架，模板、控制器、过滤器、服务等一应俱全，其依赖注入系统更是让测试变得更加简单。以下是学习过程让我比较深刻的几点。</p>\n<h4 id=\"视图与指令\"><a href=\"#视图与指令\" class=\"headerlink\" title=\"视图与指令\"></a>视图与指令</h4><p>angular与HTML和DOM有着密切的联系。AngularJS依靠浏览器去解析模板文本（就像浏览器对HTML文档的解析）。浏览器将html解析成一个DOM tree后，AngularJS就参与进来，开始遍历解析好的DOM结构，遇到指令，就执行相关逻辑，将指令转换成页面的动态部分。</p>\n<blockquote>\n<p>Angular提供了很多遍历的指令，但重要的不是这些指令的语法或者功能，而是隐藏在表象下的关于如何构建UI组件的AngularJS哲学。</p>\n</blockquote>\n<p>刚学习angularJS，都是从一个hello world和即时显示输入框输入内容的demo开始。尤其是输入框的例子让人惊叹不已。因为如果用js或者jq来实现，你必须先获取输入框的内容，再通过dom操作显示出其文本。而用angularJS，你只需引入angular的库，利用ng-app指令来引导（bootstrap）该应用，使用ng-model来进行数据绑定，angular就会自动去理解解释其中的指令帮我们做一些事情，比如在输入框那里例子实现数据的即时刷新。开发过程，我也逐步在发现自己的编程方式发生了改变，但无法用合理的语言来表达，直到我看了《精通AngularJS》里面的一段话。</p>\n<p>AngularJS提倡声明式UI结构，让模板专注于描述所需要的效果，而非实现。举例子，想想在输入框输入内容即时显示其文本的入门demo，以及ng-class来动态添加class，以及ng-click等来绑定点击事件等的编程是不是和我们平日用jquery的编程方式不大一样？（用jq为了实现以上的效果，你不得不按部就班地去操作修改dom来达到目的）。</p>\n<p>传统的开发采用命令式的编程风格，我们用js或者jq控制一切和调整每个细节。但“掌控一切”的代价，就是编写大量底层的，重复的代码。AngularJS采用的声明式编程风格更具表现力，Angular的支持，让开发者从严格的底层实现中解放出来，写出更简洁易读的代码，除了开发者实现自定义指令时会需要有步骤详细的底层DOM操作，开发过程我们很少去操作DOM。</p>\n<blockquote>\n<p>永远不要在AngularJS控制器中去操纵DOM，在控制器中获取对DOM元素的引用，操纵元素的属性，预示着在用命令式编程风格来构建UI—这违背了AngularJS之道。</p>\n</blockquote>\n<p>但想要更有效地使用模板和指令，就必须去了解更多的内部机制。这或许就是深入学习AngularJS的难点吧。毕竟声明式编程风格的一个基础，就是建立一个能够正确解释高级命令的机制。</p>\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><p>$scope这个东西确实引起了我的注意，虽然听说angular2已经把它废弃了，但我还是想说一下它以及angular里面的作用域。</p>\n<p>通过ng-controller指令来指定使用的控制器，一个作用域实例就会被初始化。作用域控制了该领域模型中的哪些数据和操作在视图上时有效的，而控制器提供了模型的初始值并处理UI相关的行为。</p>\n<p>angularjs的作用域也拥有层级的概念。$rootScope是顶级作用域，每个控制器用拥有自己的$scope。每个作用域拥有自己的整套模型值，不同的作用域定义同名的变量，不会造成命名冲突。并且，与js原型基础的规则类似，angular的作用域也有继承的概念，子scope可以访问父scope的变量和对象。</p>\n<p>但是，作用域层级继承也具备一定的风险。读操作的时候，一切都在自己的预料之中。但写操作的时候，要注意的一点是，子作用域的写操作不会影响父作用域。要经历避免直接绑定变量给作用域属性，而是采用对象属性的双向数据绑定。</p>\n<p><strong>作用域层级和事件系统</strong><br>angular通过传播带有信息的命名事件，允许跨越作用域层级。每个作用域都有$on方法，用于注册作用域的事件处理程序。angular支持通过$emit进行向上分发和$broadcast进行向下分发。</p>\n<h4 id=\"模块与依赖注入\"><a href=\"#模块与依赖注入\" class=\"headerlink\" title=\"模块与依赖注入\"></a>模块与依赖注入</h4><p>AngularJS拥有全套的API来定义模块以及在模块中注册对象。AngularJS为自己定义了全局命名空间angular，它提供了多种功能和函数，比如.module()、.controller（）、.filter（）等。</p>\n<p>模块模式在组织代码方面非常有用，此外，AngularJS也提供了一套依赖注入系统来声明模块和模块注册对象的相互依赖关系。(学习这个的时候让我想起学习javaEE时的依赖注入，印象中在一个对象使用另外一个对象必须用new来实例化，但是通过spring的依赖注入功能可以避免在对象中new一个对象造成的高耦合..)</p>\n<p>angularJS内建的依赖注入引擎，它能理解对象对其协作对象的需求，找到所需的协作对象，连接协作对象已形成完备的应用。</p>\n<blockquote>\n<p>依靠这套依赖管理系统，开发者：“为了正常工作，我需要一个依赖，我不知道它从哪儿来，也不知道它如何创建，我只知道我需要它，所以请为我提供它”。</p>\n</blockquote>\n<p>声明依赖关系的作用，让对象无需担心协作对象的生命周期。你甚至可以随意交换协作对象，通过替换服务来建立不同的应用，而这点也是有效进行单元测试的关键。（如果没有将其真实实现替换为伪造实现的能力，便很难孤立地对一个对象进行测试）。</p>\n<p><strong>AngularJS的注册服务</strong> 接入依赖注入之前，是创建一个对象并将对象注册在模块上。开发者不直接注册对象的实例，而是将对象创建的方案抛给依赖注入系统，然后AngularJS解释这些方案以初始化该对象，并连接它们成为一个可运行的应用。</p>\n<p>AngularJS的$provide服务可以注册不同的对象创建方案，之后$inject服务会解释这些方案，解决所有依赖关系，生产完备而可用的对象实例。总而言之，angularJS模块保存对象实例，而我们控制这些对象的创建，AngularJS提供以下几种创建对象的方式。</p>\n<ul>\n<li>value：可用于注册已初始化好的对象<br>这种注册方法只对非常简单的对象有用，因为通过这种方式注册的对象不能依赖其他对象。</li>\n<li>service：用于注册构造函数，让依赖该对象的模块无需对其依赖对象进行初始化（类似消除new关键字的功能）。</li>\n<li>factory：任何能够创建对象的函数都可以被注册，因此相比service而言，它更加灵活。factory是让对象加入依赖注入最常用的方法，它可以实现复杂的对象创建逻辑。因为可以是普通的函数，利用词法作用域可以来模拟“私有”变量，因此服务的一些实现细节。</li>\n<li>constant：可用于创建不同应用使用的共通服务（如可供服务的客进行定制的配置信息）</li>\n<li>provider:以上的所有注册方法，都是最通用provider的特殊类型。</li>\n</ul>\n<p><strong>模块的生命周期</strong><br>angularJS将模块的生命周期分为两个阶段：</p>\n<ul>\n<li>配置阶段：收集对象的创建方案，并进行配置。</li>\n<li>运行阶段：执行所有初始化后的逻辑。</li>\n</ul>\n<p>在配置阶段，仅运行constant和provider的注入，而在运行阶段，可以注入provider的任意对象。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>世界上没有最完美的框架，只有最合适的框架，了解和认识Angular与众不同的地方，可以让我们判断它到底适不适合用在某一个项目上，angularJS的特点总结如下：</p>\n<ul>\n<li>自动刷新与双向数据绑定，让开发者从显式触发来进行UI重绘的枯燥工作中解放</li>\n<li>以HTML语法为基础的动态DOM充当模板语言，可通过创建指令来扩展现存的html标签库。</li>\n<li>声明式UI编程风格，精炼并附有表达力。</li>\n<li>依赖注入使其具备良好的测试性。</li>\n</ul>\n<p>学习和实践Angular的过程，体验到Angular采用了完全不同的方法来构建UI，由模型的变化来取得模板更新。虽然Jquery功能很强大，但因为是以编写DOM操作为中心的代码，对于成熟和庞大、互动性相对复杂的应用来说，代码就会变得难以管理。</p>\n<p>尽管有人和我说过，现在学习angular(1.x)已经落伍啦，react，vue和angular2才是最火的，但是这次通过学习和使用angular，我得到的回报大于投资。angular1确实还存在一些缺陷可供改善的地方，但不可否认，它的出现在当时肯定给web开发生态带来了一次震荡，也给前端er们催生了许多创意（对浏览器内核以及web前端的开发模式）。</p>\n<h5 id=\"附：angular的一些学习资源\"><a href=\"#附：angular的一些学习资源\" class=\"headerlink\" title=\"附：angular的一些学习资源\"></a>附：angular的一些学习资源</h5><p>网上资源：<br><a href=\"http://www.angularjs.org/\" target=\"_blank\" rel=\"external\">angularJS主页</a><br><a href=\"http://stackoverflow.com/questions/tagged/angularjs\" target=\"_blank\" rel=\"external\">stackoverflow的angular专题</a><br><a href=\"https://github.com/gianarb/awesome-angularjs\" target=\"_blank\" rel=\"external\">awesome-angularjs</a><br><a href=\"https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md\" target=\"_blank\" rel=\"external\">angularJS最佳实践</a></p>\n<p>工具：<br><a href=\"https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk\" target=\"_blank\" rel=\"external\">AngularJS Batarang-官方提供的chrome插件：可查看作用域和性能</a></p>\n<p>书籍：<br>《angularJS开发秘笈》<br>《angularJS权威指南》<br>《精通angularJS》（墙裂推荐这本！！尤其在带着实践遇到的疑问去看这本书，里面也讲了一些最佳实践，受益匪浅，此次的文章很多东西也是摘取于此书的）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>实习的一个运营后台开发的项目，也许是实习期间对我而言最有挑战性的一次工作，因为这是初次实践angularJS。在边学边做的过程，收获不小，因此想趁着感受还比较深之时把学习和使用AngularJS进行开发的一些体验记录下来（AngularJS 1.x版本），这里主要总结学习angular的感受。（类似一篇读后感，并非入门教程）</p>\n<h3 id=\"背景\"><a href=\"#背景\" class=\"headerlink\" title=\"背景\"></a>背景</h3><blockquote>\n<p>当你决定去改变一些东西的时，你应该知道你为什么要这样做，这很重要。</p>\n</blockquote>\n<p>公司要重新开发运营后台的命令一下来，进度瞬间也被排的紧凑。后端人员先走一步，把接口完成得差不多，我看了一下接口文档，背后一阵凉风吹过，光是课程管理模块就有足足两页（十几个接口），大致看了一下需求，多数功能都是建立在CRUD上的。</p>\n<p>即使熟悉使用Jquery来进行web开发的人，尝试用jquery+api来完成这个任务也会大受打击，即便硬着头皮实现了这个系统，后期的维护和修改必定也会是一场灾难。所以，对于这类大型web应用来说，前端开发使用框架时必要的，这不仅提高我们的开发效率，同时支持我们编写更加整洁的代码。</p>\n<p>早有耳闻AngularJS作为一个客户端MVC框架，尤其适合编写有大量CRUD操作的，具体Ajax风格的富客户端应用，咦(<em>@ο@</em>) 这不就是我现在想要的吗？加之学习了解了一段时间之后，心里一阵呐喊“AngularJS，去吧，就决定就是你了”。（盗用下《宠物小精灵》的台词）</p>\n<h3 id=\"AngularJS初印象\"><a href=\"#AngularJS初印象\" class=\"headerlink\" title=\"AngularJS初印象\"></a>AngularJS初印象</h3><p>与react.js不同，AngularJS是一个完整的前端框架，模板、控制器、过滤器、服务等一应俱全，其依赖注入系统更是让测试变得更加简单。以下是学习过程让我比较深刻的几点。</p>\n<h4 id=\"视图与指令\"><a href=\"#视图与指令\" class=\"headerlink\" title=\"视图与指令\"></a>视图与指令</h4><p>angular与HTML和DOM有着密切的联系。AngularJS依靠浏览器去解析模板文本（就像浏览器对HTML文档的解析）。浏览器将html解析成一个DOM tree后，AngularJS就参与进来，开始遍历解析好的DOM结构，遇到指令，就执行相关逻辑，将指令转换成页面的动态部分。</p>\n<blockquote>\n<p>Angular提供了很多遍历的指令，但重要的不是这些指令的语法或者功能，而是隐藏在表象下的关于如何构建UI组件的AngularJS哲学。</p>\n</blockquote>\n<p>刚学习angularJS，都是从一个hello world和即时显示输入框输入内容的demo开始。尤其是输入框的例子让人惊叹不已。因为如果用js或者jq来实现，你必须先获取输入框的内容，再通过dom操作显示出其文本。而用angularJS，你只需引入angular的库，利用ng-app指令来引导（bootstrap）该应用，使用ng-model来进行数据绑定，angular就会自动去理解解释其中的指令帮我们做一些事情，比如在输入框那里例子实现数据的即时刷新。开发过程，我也逐步在发现自己的编程方式发生了改变，但无法用合理的语言来表达，直到我看了《精通AngularJS》里面的一段话。</p>\n<p>AngularJS提倡声明式UI结构，让模板专注于描述所需要的效果，而非实现。举例子，想想在输入框输入内容即时显示其文本的入门demo，以及ng-class来动态添加class，以及ng-click等来绑定点击事件等的编程是不是和我们平日用jquery的编程方式不大一样？（用jq为了实现以上的效果，你不得不按部就班地去操作修改dom来达到目的）。</p>\n<p>传统的开发采用命令式的编程风格，我们用js或者jq控制一切和调整每个细节。但“掌控一切”的代价，就是编写大量底层的，重复的代码。AngularJS采用的声明式编程风格更具表现力，Angular的支持，让开发者从严格的底层实现中解放出来，写出更简洁易读的代码，除了开发者实现自定义指令时会需要有步骤详细的底层DOM操作，开发过程我们很少去操作DOM。</p>\n<blockquote>\n<p>永远不要在AngularJS控制器中去操纵DOM，在控制器中获取对DOM元素的引用，操纵元素的属性，预示着在用命令式编程风格来构建UI—这违背了AngularJS之道。</p>\n</blockquote>\n<p>但想要更有效地使用模板和指令，就必须去了解更多的内部机制。这或许就是深入学习AngularJS的难点吧。毕竟声明式编程风格的一个基础，就是建立一个能够正确解释高级命令的机制。</p>\n<h4 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h4><p>$scope这个东西确实引起了我的注意，虽然听说angular2已经把它废弃了，但我还是想说一下它以及angular里面的作用域。</p>\n<p>通过ng-controller指令来指定使用的控制器，一个作用域实例就会被初始化。作用域控制了该领域模型中的哪些数据和操作在视图上时有效的，而控制器提供了模型的初始值并处理UI相关的行为。</p>\n<p>angularjs的作用域也拥有层级的概念。$rootScope是顶级作用域，每个控制器用拥有自己的$scope。每个作用域拥有自己的整套模型值，不同的作用域定义同名的变量，不会造成命名冲突。并且，与js原型基础的规则类似，angular的作用域也有继承的概念，子scope可以访问父scope的变量和对象。</p>\n<p>但是，作用域层级继承也具备一定的风险。读操作的时候，一切都在自己的预料之中。但写操作的时候，要注意的一点是，子作用域的写操作不会影响父作用域。要经历避免直接绑定变量给作用域属性，而是采用对象属性的双向数据绑定。</p>\n<p><strong>作用域层级和事件系统</strong><br>angular通过传播带有信息的命名事件，允许跨越作用域层级。每个作用域都有$on方法，用于注册作用域的事件处理程序。angular支持通过$emit进行向上分发和$broadcast进行向下分发。</p>\n<h4 id=\"模块与依赖注入\"><a href=\"#模块与依赖注入\" class=\"headerlink\" title=\"模块与依赖注入\"></a>模块与依赖注入</h4><p>AngularJS拥有全套的API来定义模块以及在模块中注册对象。AngularJS为自己定义了全局命名空间angular，它提供了多种功能和函数，比如.module()、.controller（）、.filter（）等。</p>\n<p>模块模式在组织代码方面非常有用，此外，AngularJS也提供了一套依赖注入系统来声明模块和模块注册对象的相互依赖关系。(学习这个的时候让我想起学习javaEE时的依赖注入，印象中在一个对象使用另外一个对象必须用new来实例化，但是通过spring的依赖注入功能可以避免在对象中new一个对象造成的高耦合..)</p>\n<p>angularJS内建的依赖注入引擎，它能理解对象对其协作对象的需求，找到所需的协作对象，连接协作对象已形成完备的应用。</p>\n<blockquote>\n<p>依靠这套依赖管理系统，开发者：“为了正常工作，我需要一个依赖，我不知道它从哪儿来，也不知道它如何创建，我只知道我需要它，所以请为我提供它”。</p>\n</blockquote>\n<p>声明依赖关系的作用，让对象无需担心协作对象的生命周期。你甚至可以随意交换协作对象，通过替换服务来建立不同的应用，而这点也是有效进行单元测试的关键。（如果没有将其真实实现替换为伪造实现的能力，便很难孤立地对一个对象进行测试）。</p>\n<p><strong>AngularJS的注册服务</strong> 接入依赖注入之前，是创建一个对象并将对象注册在模块上。开发者不直接注册对象的实例，而是将对象创建的方案抛给依赖注入系统，然后AngularJS解释这些方案以初始化该对象，并连接它们成为一个可运行的应用。</p>\n<p>AngularJS的$provide服务可以注册不同的对象创建方案，之后$inject服务会解释这些方案，解决所有依赖关系，生产完备而可用的对象实例。总而言之，angularJS模块保存对象实例，而我们控制这些对象的创建，AngularJS提供以下几种创建对象的方式。</p>\n<ul>\n<li>value：可用于注册已初始化好的对象<br>这种注册方法只对非常简单的对象有用，因为通过这种方式注册的对象不能依赖其他对象。</li>\n<li>service：用于注册构造函数，让依赖该对象的模块无需对其依赖对象进行初始化（类似消除new关键字的功能）。</li>\n<li>factory：任何能够创建对象的函数都可以被注册，因此相比service而言，它更加灵活。factory是让对象加入依赖注入最常用的方法，它可以实现复杂的对象创建逻辑。因为可以是普通的函数，利用词法作用域可以来模拟“私有”变量，因此服务的一些实现细节。</li>\n<li>constant：可用于创建不同应用使用的共通服务（如可供服务的客进行定制的配置信息）</li>\n<li>provider:以上的所有注册方法，都是最通用provider的特殊类型。</li>\n</ul>\n<p><strong>模块的生命周期</strong><br>angularJS将模块的生命周期分为两个阶段：</p>\n<ul>\n<li>配置阶段：收集对象的创建方案，并进行配置。</li>\n<li>运行阶段：执行所有初始化后的逻辑。</li>\n</ul>\n<p>在配置阶段，仅运行constant和provider的注入，而在运行阶段，可以注入provider的任意对象。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>世界上没有最完美的框架，只有最合适的框架，了解和认识Angular与众不同的地方，可以让我们判断它到底适不适合用在某一个项目上，angularJS的特点总结如下：</p>\n<ul>\n<li>自动刷新与双向数据绑定，让开发者从显式触发来进行UI重绘的枯燥工作中解放</li>\n<li>以HTML语法为基础的动态DOM充当模板语言，可通过创建指令来扩展现存的html标签库。</li>\n<li>声明式UI编程风格，精炼并附有表达力。</li>\n<li>依赖注入使其具备良好的测试性。</li>\n</ul>\n<p>学习和实践Angular的过程，体验到Angular采用了完全不同的方法来构建UI，由模型的变化来取得模板更新。虽然Jquery功能很强大，但因为是以编写DOM操作为中心的代码，对于成熟和庞大、互动性相对复杂的应用来说，代码就会变得难以管理。</p>\n<p>尽管有人和我说过，现在学习angular(1.x)已经落伍啦，react，vue和angular2才是最火的，但是这次通过学习和使用angular，我得到的回报大于投资。angular1确实还存在一些缺陷可供改善的地方，但不可否认，它的出现在当时肯定给web开发生态带来了一次震荡，也给前端er们催生了许多创意（对浏览器内核以及web前端的开发模式）。</p>\n<h5 id=\"附：angular的一些学习资源\"><a href=\"#附：angular的一些学习资源\" class=\"headerlink\" title=\"附：angular的一些学习资源\"></a>附：angular的一些学习资源</h5><p>网上资源：<br><a href=\"http://www.angularjs.org/\" target=\"_blank\" rel=\"external\">angularJS主页</a><br><a href=\"http://stackoverflow.com/questions/tagged/angularjs\" target=\"_blank\" rel=\"external\">stackoverflow的angular专题</a><br><a href=\"https://github.com/gianarb/awesome-angularjs\" target=\"_blank\" rel=\"external\">awesome-angularjs</a><br><a href=\"https://github.com/mgechev/angularjs-style-guide/blob/master/README-zh-cn.md\" target=\"_blank\" rel=\"external\">angularJS最佳实践</a></p>\n<p>工具：<br><a href=\"https://chrome.google.com/webstore/detail/angularjs-batarang/ighdmehidhipcmcojjgiloacoafjmpfk\" target=\"_blank\" rel=\"external\">AngularJS Batarang-官方提供的chrome插件：可查看作用域和性能</a></p>\n<p>书籍：<br>《angularJS开发秘笈》<br>《angularJS权威指南》<br>《精通angularJS》（墙裂推荐这本！！尤其在带着实践遇到的疑问去看这本书，里面也讲了一些最佳实践，受益匪浅，此次的文章很多东西也是摘取于此书的）</p>\n"},{"title":"bower入门","date":"2015-08-11T15:13:58.000Z","_content":"\n> 随着网页功能变得越来越复杂，同一张网页加载多个JavaScript函数库早已是家常便饭。开发者越来越需要一个工具，对浏览器端的各种库进行管理，比如搜索、自动安装\\卸载、检查更新、确保依赖关系等等。Bower就是为了解决这个问题而诞生的针对浏览器端的库管理工具。\n\n### bower的常用操作\n\n- 包的安装：`$ bower install（包名）`\n\n若包安装失败，执行”bower cache clean”，后重新安装。\n\n- 包的搜索\n\n  ```\n  $ bower search （包名）\n  ```\n\n- 对已安装的包进行查看\n\n  ```\n  $ bower list\n  ```\n\n\n- 查看某个包的信息\n\n  ```\n  $ bower info （包名）\n  ```\n\n- 卸载包\n\n  ```\n  $ bower uninstall （包名）\n  ```\n\n### bower.json\n\n这个文件便于在项目中对于包可以进行批量安装\n\n- 在项目中创建bower.json`$ bower init`\n\nbower.json的一般格式：\n\n```\n{\n  \"name\": \"blog\",  \n  \"version\": \"0.0.1\"     \n  \"authors\": [\n    \"sb\"\n  ],\n  \"license\": \"MIT\",\n  \"ignore\": [      \n    \"**/.*\",    \n    \"node_modules\",      \n    \"bower_components\",    \n    \"test\",\n    \"tests\"\n  ],\n  \"dependencies\": {\n    \"jquery\": \"~2.0.3\"\n  }\n}\n```\n\n其中dependencies就是项目依赖的包列表。\n\n- 安装包并更新bower.json`$ bower install （某包） --save`\n\n### .bowerrc\n\n若不希望包文件下载到/bower-component中，而下载安装到自己习惯的目录，则在项目目录下新建一个.bowerrc文件，修改里面的directory的路径。\n一般的.bowerrc文件：\n\n```\n{\n  \"directory\" : \"components\",//存放库文件的目录。\n  \"json\"      : \"bower.json\",//描述各个库的json文件名。\n  \"endpoint\"  : \"https://Bower.herokuapp.com\",//在线索引的网址，用来搜索各种库。\n  \"searchpath\"  : \"\",//一个数组，储存备选的在线索引网址。如果某个库在endpoint中找不到，则继续搜索该属性指定的网址，通常用于放置某些不公开的库。\n  \"shorthand_resolver\" : \"\"//定义各个库名称简写形式\n}\n```\n\n### bower与npm\n\n**npm和bower都是包管理器。npm是node端的包管理工具包，而bower是基于node的，用于管理前端依赖资源的管理工具。**\n通常，在实际项目中，npm和bower都会用到，并且bower的安装和升级依赖于npm。\nNPM主要运用于Node.js项目的内部依赖包管理，安装的模块位于项目根目录下的node_modules文件夹内。而Bower大部分情况下用于前端开发，对于CSS/JS/模板等内容进行依赖管理，依赖的下载目录结构可以自定义。\nnpm采用嵌套的依赖关系树，而bower采用变片的依赖关系管理方式，而一个普通前端的依赖树非常荣昌，同时和其它安装包不能共享依赖代码，采用npm管理会导致文件非常多，不依赖前端代码部署。\n实际项目中，后端可以采用npm进行包管理，而前端可以采用bower进行包管理，让各自的工作效率大大提升","source":"_posts/bower入门.md","raw":"---\ntitle: bower入门\ndate: 2015-08-11 23:13:58\ntags: 前端工具\n---\n\n> 随着网页功能变得越来越复杂，同一张网页加载多个JavaScript函数库早已是家常便饭。开发者越来越需要一个工具，对浏览器端的各种库进行管理，比如搜索、自动安装\\卸载、检查更新、确保依赖关系等等。Bower就是为了解决这个问题而诞生的针对浏览器端的库管理工具。\n\n### bower的常用操作\n\n- 包的安装：`$ bower install（包名）`\n\n若包安装失败，执行”bower cache clean”，后重新安装。\n\n- 包的搜索\n\n  ```\n  $ bower search （包名）\n  ```\n\n- 对已安装的包进行查看\n\n  ```\n  $ bower list\n  ```\n\n\n- 查看某个包的信息\n\n  ```\n  $ bower info （包名）\n  ```\n\n- 卸载包\n\n  ```\n  $ bower uninstall （包名）\n  ```\n\n### bower.json\n\n这个文件便于在项目中对于包可以进行批量安装\n\n- 在项目中创建bower.json`$ bower init`\n\nbower.json的一般格式：\n\n```\n{\n  \"name\": \"blog\",  \n  \"version\": \"0.0.1\"     \n  \"authors\": [\n    \"sb\"\n  ],\n  \"license\": \"MIT\",\n  \"ignore\": [      \n    \"**/.*\",    \n    \"node_modules\",      \n    \"bower_components\",    \n    \"test\",\n    \"tests\"\n  ],\n  \"dependencies\": {\n    \"jquery\": \"~2.0.3\"\n  }\n}\n```\n\n其中dependencies就是项目依赖的包列表。\n\n- 安装包并更新bower.json`$ bower install （某包） --save`\n\n### .bowerrc\n\n若不希望包文件下载到/bower-component中，而下载安装到自己习惯的目录，则在项目目录下新建一个.bowerrc文件，修改里面的directory的路径。\n一般的.bowerrc文件：\n\n```\n{\n  \"directory\" : \"components\",//存放库文件的目录。\n  \"json\"      : \"bower.json\",//描述各个库的json文件名。\n  \"endpoint\"  : \"https://Bower.herokuapp.com\",//在线索引的网址，用来搜索各种库。\n  \"searchpath\"  : \"\",//一个数组，储存备选的在线索引网址。如果某个库在endpoint中找不到，则继续搜索该属性指定的网址，通常用于放置某些不公开的库。\n  \"shorthand_resolver\" : \"\"//定义各个库名称简写形式\n}\n```\n\n### bower与npm\n\n**npm和bower都是包管理器。npm是node端的包管理工具包，而bower是基于node的，用于管理前端依赖资源的管理工具。**\n通常，在实际项目中，npm和bower都会用到，并且bower的安装和升级依赖于npm。\nNPM主要运用于Node.js项目的内部依赖包管理，安装的模块位于项目根目录下的node_modules文件夹内。而Bower大部分情况下用于前端开发，对于CSS/JS/模板等内容进行依赖管理，依赖的下载目录结构可以自定义。\nnpm采用嵌套的依赖关系树，而bower采用变片的依赖关系管理方式，而一个普通前端的依赖树非常荣昌，同时和其它安装包不能共享依赖代码，采用npm管理会导致文件非常多，不依赖前端代码部署。\n实际项目中，后端可以采用npm进行包管理，而前端可以采用bower进行包管理，让各自的工作效率大大提升","slug":"bower入门","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwmt0008cgeso670d0iv","content":"<blockquote>\n<p>随着网页功能变得越来越复杂，同一张网页加载多个JavaScript函数库早已是家常便饭。开发者越来越需要一个工具，对浏览器端的各种库进行管理，比如搜索、自动安装\\卸载、检查更新、确保依赖关系等等。Bower就是为了解决这个问题而诞生的针对浏览器端的库管理工具。</p>\n</blockquote>\n<h3 id=\"bower的常用操作\"><a href=\"#bower的常用操作\" class=\"headerlink\" title=\"bower的常用操作\"></a>bower的常用操作</h3><ul>\n<li>包的安装：<code>$ bower install（包名）</code></li>\n</ul>\n<p>若包安装失败，执行”bower cache clean”，后重新安装。</p>\n<ul>\n<li><p>包的搜索</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower search （包名）</div></pre></td></tr></table></figure>\n</li>\n<li><p>对已安装的包进行查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower list</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看某个包的信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower info （包名）</div></pre></td></tr></table></figure>\n</li>\n<li><p>卸载包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower uninstall （包名）</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"bower-json\"><a href=\"#bower-json\" class=\"headerlink\" title=\"bower.json\"></a>bower.json</h3><p>这个文件便于在项目中对于包可以进行批量安装</p>\n<ul>\n<li>在项目中创建bower.json<code>$ bower init</code></li>\n</ul>\n<p>bower.json的一般格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;name&quot;: &quot;blog&quot;,  </div><div class=\"line\">  &quot;version&quot;: &quot;0.0.1&quot;     </div><div class=\"line\">  &quot;authors&quot;: [</div><div class=\"line\">    &quot;sb&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;license&quot;: &quot;MIT&quot;,</div><div class=\"line\">  &quot;ignore&quot;: [      </div><div class=\"line\">    &quot;**/.*&quot;,    </div><div class=\"line\">    &quot;node_modules&quot;,      </div><div class=\"line\">    &quot;bower_components&quot;,    </div><div class=\"line\">    &quot;test&quot;,</div><div class=\"line\">    &quot;tests&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;dependencies&quot;: &#123;</div><div class=\"line\">    &quot;jquery&quot;: &quot;~2.0.3&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中dependencies就是项目依赖的包列表。</p>\n<ul>\n<li>安装包并更新bower.json<code>$ bower install （某包） --save</code></li>\n</ul>\n<h3 id=\"bowerrc\"><a href=\"#bowerrc\" class=\"headerlink\" title=\".bowerrc\"></a>.bowerrc</h3><p>若不希望包文件下载到/bower-component中，而下载安装到自己习惯的目录，则在项目目录下新建一个.bowerrc文件，修改里面的directory的路径。<br>一般的.bowerrc文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;directory&quot; : &quot;components&quot;,//存放库文件的目录。</div><div class=\"line\">  &quot;json&quot;      : &quot;bower.json&quot;,//描述各个库的json文件名。</div><div class=\"line\">  &quot;endpoint&quot;  : &quot;https://Bower.herokuapp.com&quot;,//在线索引的网址，用来搜索各种库。</div><div class=\"line\">  &quot;searchpath&quot;  : &quot;&quot;,//一个数组，储存备选的在线索引网址。如果某个库在endpoint中找不到，则继续搜索该属性指定的网址，通常用于放置某些不公开的库。</div><div class=\"line\">  &quot;shorthand_resolver&quot; : &quot;&quot;//定义各个库名称简写形式</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"bower与npm\"><a href=\"#bower与npm\" class=\"headerlink\" title=\"bower与npm\"></a>bower与npm</h3><p><strong>npm和bower都是包管理器。npm是node端的包管理工具包，而bower是基于node的，用于管理前端依赖资源的管理工具。</strong><br>通常，在实际项目中，npm和bower都会用到，并且bower的安装和升级依赖于npm。<br>NPM主要运用于Node.js项目的内部依赖包管理，安装的模块位于项目根目录下的node_modules文件夹内。而Bower大部分情况下用于前端开发，对于CSS/JS/模板等内容进行依赖管理，依赖的下载目录结构可以自定义。<br>npm采用嵌套的依赖关系树，而bower采用变片的依赖关系管理方式，而一个普通前端的依赖树非常荣昌，同时和其它安装包不能共享依赖代码，采用npm管理会导致文件非常多，不依赖前端代码部署。<br>实际项目中，后端可以采用npm进行包管理，而前端可以采用bower进行包管理，让各自的工作效率大大提升</p>\n","site":{"data":{}},"excerpt":"","more":"<blockquote>\n<p>随着网页功能变得越来越复杂，同一张网页加载多个JavaScript函数库早已是家常便饭。开发者越来越需要一个工具，对浏览器端的各种库进行管理，比如搜索、自动安装\\卸载、检查更新、确保依赖关系等等。Bower就是为了解决这个问题而诞生的针对浏览器端的库管理工具。</p>\n</blockquote>\n<h3 id=\"bower的常用操作\"><a href=\"#bower的常用操作\" class=\"headerlink\" title=\"bower的常用操作\"></a>bower的常用操作</h3><ul>\n<li>包的安装：<code>$ bower install（包名）</code></li>\n</ul>\n<p>若包安装失败，执行”bower cache clean”，后重新安装。</p>\n<ul>\n<li><p>包的搜索</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower search （包名）</div></pre></td></tr></table></figure>\n</li>\n<li><p>对已安装的包进行查看</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower list</div></pre></td></tr></table></figure>\n</li>\n<li><p>查看某个包的信息</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower info （包名）</div></pre></td></tr></table></figure>\n</li>\n<li><p>卸载包</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$ bower uninstall （包名）</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"bower-json\"><a href=\"#bower-json\" class=\"headerlink\" title=\"bower.json\"></a>bower.json</h3><p>这个文件便于在项目中对于包可以进行批量安装</p>\n<ul>\n<li>在项目中创建bower.json<code>$ bower init</code></li>\n</ul>\n<p>bower.json的一般格式：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;name&quot;: &quot;blog&quot;,  </div><div class=\"line\">  &quot;version&quot;: &quot;0.0.1&quot;     </div><div class=\"line\">  &quot;authors&quot;: [</div><div class=\"line\">    &quot;sb&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;license&quot;: &quot;MIT&quot;,</div><div class=\"line\">  &quot;ignore&quot;: [      </div><div class=\"line\">    &quot;**/.*&quot;,    </div><div class=\"line\">    &quot;node_modules&quot;,      </div><div class=\"line\">    &quot;bower_components&quot;,    </div><div class=\"line\">    &quot;test&quot;,</div><div class=\"line\">    &quot;tests&quot;</div><div class=\"line\">  ],</div><div class=\"line\">  &quot;dependencies&quot;: &#123;</div><div class=\"line\">    &quot;jquery&quot;: &quot;~2.0.3&quot;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>其中dependencies就是项目依赖的包列表。</p>\n<ul>\n<li>安装包并更新bower.json<code>$ bower install （某包） --save</code></li>\n</ul>\n<h3 id=\"bowerrc\"><a href=\"#bowerrc\" class=\"headerlink\" title=\".bowerrc\"></a>.bowerrc</h3><p>若不希望包文件下载到/bower-component中，而下载安装到自己习惯的目录，则在项目目录下新建一个.bowerrc文件，修改里面的directory的路径。<br>一般的.bowerrc文件：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">  &quot;directory&quot; : &quot;components&quot;,//存放库文件的目录。</div><div class=\"line\">  &quot;json&quot;      : &quot;bower.json&quot;,//描述各个库的json文件名。</div><div class=\"line\">  &quot;endpoint&quot;  : &quot;https://Bower.herokuapp.com&quot;,//在线索引的网址，用来搜索各种库。</div><div class=\"line\">  &quot;searchpath&quot;  : &quot;&quot;,//一个数组，储存备选的在线索引网址。如果某个库在endpoint中找不到，则继续搜索该属性指定的网址，通常用于放置某些不公开的库。</div><div class=\"line\">  &quot;shorthand_resolver&quot; : &quot;&quot;//定义各个库名称简写形式</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"bower与npm\"><a href=\"#bower与npm\" class=\"headerlink\" title=\"bower与npm\"></a>bower与npm</h3><p><strong>npm和bower都是包管理器。npm是node端的包管理工具包，而bower是基于node的，用于管理前端依赖资源的管理工具。</strong><br>通常，在实际项目中，npm和bower都会用到，并且bower的安装和升级依赖于npm。<br>NPM主要运用于Node.js项目的内部依赖包管理，安装的模块位于项目根目录下的node_modules文件夹内。而Bower大部分情况下用于前端开发，对于CSS/JS/模板等内容进行依赖管理，依赖的下载目录结构可以自定义。<br>npm采用嵌套的依赖关系树，而bower采用变片的依赖关系管理方式，而一个普通前端的依赖树非常荣昌，同时和其它安装包不能共享依赖代码，采用npm管理会导致文件非常多，不依赖前端代码部署。<br>实际项目中，后端可以采用npm进行包管理，而前端可以采用bower进行包管理，让各自的工作效率大大提升</p>\n"},{"title":"javascript设计模式-单例模式","date":"2017-06-23T15:13:58.000Z","_content":"\n用单例模式创建一个独一无二的对象，常常用来管理共享的资源，例如数据库链接或者线程池，另外也可以确保某个资源在全局只有一份。简单的单例模式，配上惰性的特性，在开发中具有非一般的实用性。\n\n#### 定义\n\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n#### 实现\n\n利用一个变量来标志当前是否已经为某个类创建过对象，并且不直接用new来得到一个实例，而是通过类似getInstance的方法来获取对象实例。\n\n```javascript\nvar Singleton = function() {\n  this.instance = null;\n}\nSingleton.protype.getInstance = function(){\n  if(!this.instance) {\n    this.instance = new Singleton();\n  }\n  return this.instance;\n};\nvar a = Singleton.getInstance();\nvar b = Singleton.getInstance();\nconsole.log(a===b); // true\n```\n\n思考：那么如何避免别人来实例化多个呢？上面的代码的确我可以new多个。\n\njava中的做法是不公开构造函数，即给构造器添加private关键字。javascript则可以用闭包来实现私有的效果。\n\n#### 针对JavaScrpt的单例模式\n\n在js中我们可以通过使用全局变量来实现单例模式的效果。我们在全局可以创建一个对象，让代码中的任何为止都可以访问，从而通过判断该对象是否初始化来实现单例模式。但是实际中，全局变量存在很多问题，比如命名空间污染。那如何降低js全局变量带来的命名污染？有以下几个方法：\n\n1. 使用对象字面量\n\n   ```javascript\n   var namespace = {\n     a: function(){...},\n     b: function(){...}\n   }\n   ```\n\n2. 使用闭包封装私有变量\n\n   ```javascript\n   var a = (function(){\n     var __instance = new Singleton();\n     return {\n       getInstance: function(){\n         return __instance;\n       }\n     }\n   }) ();\n   ```\n\n#### 惰性单例\n\n然而，实际开发中我们还可以使用单例模式，在只在需要它的时候才去创建实例，这类单例叫做惰性单例。\n\n比如网页的登录框，它不仅是唯一的（不可能同时出现两个登录框），所以这里就很适合用单例模式。而且如果用户不点击登录按钮进行登录，它就不会现身，so我们为了加快页面加载的速度，应该等到需要它时才去实例化。\n\n将创建对象和管理单例的职责分别放置于两个方法中，组合使用的话能让单例模式的使用更加符合单一职责原则。\n\n#### 感叹\n\n在设计模式中，经常能听到我们需要把变和不变的部分隔离出来，把业务逻辑和业务无关的逻辑隔离出来。学习设计模式的这几天，看书看别人举例子都觉得好奇妙，好简单的样子，然而等我跃跃欲试想拿着自己学到的这几个模式去重构以前写的代码时，深刻发现实际开发的使用其实并没有现象中那么简单，你需要辨别如何把代码隔离出来，做到可复用的同时又做到易读性。尽管对我来说，写出优美代码这条路长路漫漫，但是通过学习设计模式才体会到写代码真的是一件有意思的事情啊！","source":"_posts/javascript设计模式-单例模式.md","raw":"---\ntitle: javascript设计模式-单例模式\ndate: 2017-6-23 23:13:58\ntags: 设计模式\n---\n\n用单例模式创建一个独一无二的对象，常常用来管理共享的资源，例如数据库链接或者线程池，另外也可以确保某个资源在全局只有一份。简单的单例模式，配上惰性的特性，在开发中具有非一般的实用性。\n\n#### 定义\n\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n\n#### 实现\n\n利用一个变量来标志当前是否已经为某个类创建过对象，并且不直接用new来得到一个实例，而是通过类似getInstance的方法来获取对象实例。\n\n```javascript\nvar Singleton = function() {\n  this.instance = null;\n}\nSingleton.protype.getInstance = function(){\n  if(!this.instance) {\n    this.instance = new Singleton();\n  }\n  return this.instance;\n};\nvar a = Singleton.getInstance();\nvar b = Singleton.getInstance();\nconsole.log(a===b); // true\n```\n\n思考：那么如何避免别人来实例化多个呢？上面的代码的确我可以new多个。\n\njava中的做法是不公开构造函数，即给构造器添加private关键字。javascript则可以用闭包来实现私有的效果。\n\n#### 针对JavaScrpt的单例模式\n\n在js中我们可以通过使用全局变量来实现单例模式的效果。我们在全局可以创建一个对象，让代码中的任何为止都可以访问，从而通过判断该对象是否初始化来实现单例模式。但是实际中，全局变量存在很多问题，比如命名空间污染。那如何降低js全局变量带来的命名污染？有以下几个方法：\n\n1. 使用对象字面量\n\n   ```javascript\n   var namespace = {\n     a: function(){...},\n     b: function(){...}\n   }\n   ```\n\n2. 使用闭包封装私有变量\n\n   ```javascript\n   var a = (function(){\n     var __instance = new Singleton();\n     return {\n       getInstance: function(){\n         return __instance;\n       }\n     }\n   }) ();\n   ```\n\n#### 惰性单例\n\n然而，实际开发中我们还可以使用单例模式，在只在需要它的时候才去创建实例，这类单例叫做惰性单例。\n\n比如网页的登录框，它不仅是唯一的（不可能同时出现两个登录框），所以这里就很适合用单例模式。而且如果用户不点击登录按钮进行登录，它就不会现身，so我们为了加快页面加载的速度，应该等到需要它时才去实例化。\n\n将创建对象和管理单例的职责分别放置于两个方法中，组合使用的话能让单例模式的使用更加符合单一职责原则。\n\n#### 感叹\n\n在设计模式中，经常能听到我们需要把变和不变的部分隔离出来，把业务逻辑和业务无关的逻辑隔离出来。学习设计模式的这几天，看书看别人举例子都觉得好奇妙，好简单的样子，然而等我跃跃欲试想拿着自己学到的这几个模式去重构以前写的代码时，深刻发现实际开发的使用其实并没有现象中那么简单，你需要辨别如何把代码隔离出来，做到可复用的同时又做到易读性。尽管对我来说，写出优美代码这条路长路漫漫，但是通过学习设计模式才体会到写代码真的是一件有意思的事情啊！","slug":"javascript设计模式-单例模式","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwmv0009cgessqvfws2c","content":"<p>用单例模式创建一个独一无二的对象，常常用来管理共享的资源，例如数据库链接或者线程池，另外也可以确保某个资源在全局只有一份。简单的单例模式，配上惰性的特性，在开发中具有非一般的实用性。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>利用一个变量来标志当前是否已经为某个类创建过对象，并且不直接用new来得到一个实例，而是通过类似getInstance的方法来获取对象实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Singleton = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.instance = <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">Singleton.protype.getInstance = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.instance) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.instance;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> a = Singleton.getInstance();</div><div class=\"line\"><span class=\"keyword\">var</span> b = Singleton.getInstance();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a===b); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>思考：那么如何避免别人来实例化多个呢？上面的代码的确我可以new多个。</p>\n<p>java中的做法是不公开构造函数，即给构造器添加private关键字。javascript则可以用闭包来实现私有的效果。</p>\n<h4 id=\"针对JavaScrpt的单例模式\"><a href=\"#针对JavaScrpt的单例模式\" class=\"headerlink\" title=\"针对JavaScrpt的单例模式\"></a>针对JavaScrpt的单例模式</h4><p>在js中我们可以通过使用全局变量来实现单例模式的效果。我们在全局可以创建一个对象，让代码中的任何为止都可以访问，从而通过判断该对象是否初始化来实现单例模式。但是实际中，全局变量存在很多问题，比如命名空间污染。那如何降低js全局变量带来的命名污染？有以下几个方法：</p>\n<ol>\n<li><p>使用对象字面量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> namespace = &#123;</div><div class=\"line\">  a: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;,</div><div class=\"line\">  b: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用闭包封装私有变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> __instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    getInstance: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> __instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;) ();</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"惰性单例\"><a href=\"#惰性单例\" class=\"headerlink\" title=\"惰性单例\"></a>惰性单例</h4><p>然而，实际开发中我们还可以使用单例模式，在只在需要它的时候才去创建实例，这类单例叫做惰性单例。</p>\n<p>比如网页的登录框，它不仅是唯一的（不可能同时出现两个登录框），所以这里就很适合用单例模式。而且如果用户不点击登录按钮进行登录，它就不会现身，so我们为了加快页面加载的速度，应该等到需要它时才去实例化。</p>\n<p>将创建对象和管理单例的职责分别放置于两个方法中，组合使用的话能让单例模式的使用更加符合单一职责原则。</p>\n<h4 id=\"感叹\"><a href=\"#感叹\" class=\"headerlink\" title=\"感叹\"></a>感叹</h4><p>在设计模式中，经常能听到我们需要把变和不变的部分隔离出来，把业务逻辑和业务无关的逻辑隔离出来。学习设计模式的这几天，看书看别人举例子都觉得好奇妙，好简单的样子，然而等我跃跃欲试想拿着自己学到的这几个模式去重构以前写的代码时，深刻发现实际开发的使用其实并没有现象中那么简单，你需要辨别如何把代码隔离出来，做到可复用的同时又做到易读性。尽管对我来说，写出优美代码这条路长路漫漫，但是通过学习设计模式才体会到写代码真的是一件有意思的事情啊！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>用单例模式创建一个独一无二的对象，常常用来管理共享的资源，例如数据库链接或者线程池，另外也可以确保某个资源在全局只有一份。简单的单例模式，配上惰性的特性，在开发中具有非一般的实用性。</p>\n<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>\n<h4 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h4><p>利用一个变量来标志当前是否已经为某个类创建过对象，并且不直接用new来得到一个实例，而是通过类似getInstance的方法来获取对象实例。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Singleton = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.instance = <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">Singleton.protype.getInstance = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">this</span>.instance) &#123;</div><div class=\"line\">    <span class=\"keyword\">this</span>.instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.instance;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> a = Singleton.getInstance();</div><div class=\"line\"><span class=\"keyword\">var</span> b = Singleton.getInstance();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a===b); <span class=\"comment\">// true</span></div></pre></td></tr></table></figure>\n<p>思考：那么如何避免别人来实例化多个呢？上面的代码的确我可以new多个。</p>\n<p>java中的做法是不公开构造函数，即给构造器添加private关键字。javascript则可以用闭包来实现私有的效果。</p>\n<h4 id=\"针对JavaScrpt的单例模式\"><a href=\"#针对JavaScrpt的单例模式\" class=\"headerlink\" title=\"针对JavaScrpt的单例模式\"></a>针对JavaScrpt的单例模式</h4><p>在js中我们可以通过使用全局变量来实现单例模式的效果。我们在全局可以创建一个对象，让代码中的任何为止都可以访问，从而通过判断该对象是否初始化来实现单例模式。但是实际中，全局变量存在很多问题，比如命名空间污染。那如何降低js全局变量带来的命名污染？有以下几个方法：</p>\n<ol>\n<li><p>使用对象字面量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> namespace = &#123;</div><div class=\"line\">  a: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;,</div><div class=\"line\">  b: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;...&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>使用闭包封装私有变量</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> a = (<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> __instance = <span class=\"keyword\">new</span> Singleton();</div><div class=\"line\">  <span class=\"keyword\">return</span> &#123;</div><div class=\"line\">    getInstance: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">      <span class=\"keyword\">return</span> __instance;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;) ();</div></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"惰性单例\"><a href=\"#惰性单例\" class=\"headerlink\" title=\"惰性单例\"></a>惰性单例</h4><p>然而，实际开发中我们还可以使用单例模式，在只在需要它的时候才去创建实例，这类单例叫做惰性单例。</p>\n<p>比如网页的登录框，它不仅是唯一的（不可能同时出现两个登录框），所以这里就很适合用单例模式。而且如果用户不点击登录按钮进行登录，它就不会现身，so我们为了加快页面加载的速度，应该等到需要它时才去实例化。</p>\n<p>将创建对象和管理单例的职责分别放置于两个方法中，组合使用的话能让单例模式的使用更加符合单一职责原则。</p>\n<h4 id=\"感叹\"><a href=\"#感叹\" class=\"headerlink\" title=\"感叹\"></a>感叹</h4><p>在设计模式中，经常能听到我们需要把变和不变的部分隔离出来，把业务逻辑和业务无关的逻辑隔离出来。学习设计模式的这几天，看书看别人举例子都觉得好奇妙，好简单的样子，然而等我跃跃欲试想拿着自己学到的这几个模式去重构以前写的代码时，深刻发现实际开发的使用其实并没有现象中那么简单，你需要辨别如何把代码隔离出来，做到可复用的同时又做到易读性。尽管对我来说，写出优美代码这条路长路漫漫，但是通过学习设计模式才体会到写代码真的是一件有意思的事情啊！</p>\n"},{"title":"javascript设计模式-原型模式","date":"2017-06-23T15:13:58.000Z","_content":"\n之前对设计模式的学习和实践都是基于Java的。虽说设计模式其实无关语言，仅仅是对某一种问题的特定的一种解决方案和设计思想。但是最近看的曾探写的《Javascript设计模式与开发实践》深有体会。一是，认同作者认为设计模式说白了就是对某一种问题的解决方案和设计思路，只是后来被冠之以名。但学习设计模式是必要的，因为知道了有哪些设计模式，才能更清楚地知道自己的代码写得好不好，以及怎么使用适合的设计模式来改善自己的代码。\n\n二是设计模式本质的一样的，但会随着不同语言，根据根据语言本身的特性的不同有不同的实现方式。好比针对Javascript，实现多态，继承和封装就和java不大一样。\n\n通过阅读上面提到的书，整理了关于javaScript的几个设计模式。首先，是原型模式。\n\n### 原型模式\n\n#### 介绍\n\n设计模式中，原型模式是用来创建对象的一种模式，我们可以用原型模式来创建一个一模一样的对象，但是通常目的只是为了更便捷地创建某个类型的对象。在Java中，创建对象的方法是先指定它的类型，然后后通过类的概念来创建对象。而对于Javascript这种没有类的语言，我们创建对象通常是找到一个对象，然后通过克隆它来创建一个对象。\n\n虽然ES6中有了class来创建一个类，但是它本质上还是用原型来创建对象的。\n\n#### 在js中的应用\n\nps：js中没有类的概念，只有对象的概念。但是为了区分不同对象充当的角色，通常用开头大学来标注它是一个“类”（抽象的对象），而开头小写来标注它是个具体的实例。\n\n##### 创建对象，实现继承\n\n- new创建对象，js的构造器其实是一个函数\n\n  js没有类的概念，而函数是js的一等公民，js中的函数可以作为普通函数被调用，也可以作为构造器被调用。我们创建对象使用的new关键词实际上就是在调用一个作为构造器的函数。当我们用new调用一个构造器，其实就是在克隆一个对象的过程。\n\n\n- 其实对象会记住它的原型，准确来说不是对象真的有一个原型，而是它的构造器有原型。对象把请求委托给它自己的原型其实更准确地说是对象把请求委托给它的构造器的原型。js给对象提供了一个名为*proto*的隐藏属性，chrome和firefox可以向外暴露对象的这个属性，这个属性默认会指向它的构造器的原型对象。\n\n  ``` javascript\n  new a = new Object();\n  console.log(a._proto_ === Object.prototype); //输出true\n  ```\n\n\n- 因为_*proto*记住了构造器的原型，所以我们说对象记住了它的原型，并通过原型来实现了继承。\n- 虽然js的对象最初都是由Object.proptype对象克隆来的，但对象构造器的原型可以动态地指向其他对象。当我们想创建一个继承B的对象A，只要把对象A的构造器的原型指向对象B，就能实现继承的效果。\n- js最常见的继承方式：\n\n``` javascript\nvar obj = { name: 'june'};\nvar A = function() {  }\nA.proptype = obj;\nvar a = new A();\nconsole.log(a.name); //输出：june\n```\n\n``` javascript\n// 一个类继承另外一个类\nvar A = function() {}\nA.prototype = { name: 'sven'};\nvar B = function() {}\nB.prototype = new A();\nvar b = new B();\nb.name; //=> sven\n```\n\n- 上面两端代码的目的是一样的，本质上也没有差别，区别只是一个将B.proptype直接指向一个字面量对象，一个是指向new A()，后者会比前者形成的原型链多了一层。\n\n- Object.create方法：我通常用它来创建一个基于某个现有对象的对象，但准确来说它就是通过原型模式来实现了一个次原型继承。\n\n  该方法实际等同于：\n\n  ```javascript\n  functionO(obj) {\n    var F = function() {\n      F.prototype = obj;\n      return new F();\n    }\n  }\n  var a = Object.create({}); //a.proptype为Object;\n  var b = Object.create(null); //b.proptype为null;\n\n  ```\n\n  #### 思考题\n\n  - prototype和constructor和*proto*傻傻分不清楚？\n\n    - **prototype 属性是可读写的，该属性是函数所特有,但准确来说该属性是为构造函数所量身定造的。** 这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有此构造器实例化出来的实例所共享的属性和方法。\n    - **被构造函数new 出来的对象是 实例对象，实例对象的属性 constructor 指向了构造函数。**对象的请求委托实际上是在对象自己无法应答请求的时候，将请求委托给构造器的原型。\n    - **实例对象的 proto 指向了构造器的原型对象(prototype属性).**\n\n    实践是唯一的真理：\n\n    - [![img](http://ww1.sinaimg.cn/large/63739cabgy1fgpk7qyezxj20ck0ebdgm.jpg)](http://ww1.sinaimg.cn/large/63739cabgy1fgpk7qyezxj20ck0ebdgm.jpg)\n\n      ​\n\n\n    - 为什么说当前的javascript引擎下，通过Object.create来创建对象比通过构造函数创建对象要慢呢？\n\n      待续…\n\n    - javascript创建对象的其它方式有哪些呢？\n\n      待续…\n\n    #### 总结\n\n    之前看红皮书和犀牛书，都不得不被对象继承和原型那一章节搞得晕乎乎。学习了原型模式后，其实现在看来，javascript其实就是依靠原型模式来搭建整个面向对象系统的，js连类的概念都没有，更别说继承了。实际上，为了实现js的继承，我们利用的是原型的机制，所有的js对象都是从某个对象克隆而来的。而原型这两个字其实就是它表面的意思，如果A对象是从B对象克隆而来的，那么B对象就是A对象的原型。","source":"_posts/javascript设计模式-原型模式.md","raw":"---\ntitle: javascript设计模式-原型模式\ndate: 2017-6-23 23:13:58\ntags: 设计模式\n---\n\n之前对设计模式的学习和实践都是基于Java的。虽说设计模式其实无关语言，仅仅是对某一种问题的特定的一种解决方案和设计思想。但是最近看的曾探写的《Javascript设计模式与开发实践》深有体会。一是，认同作者认为设计模式说白了就是对某一种问题的解决方案和设计思路，只是后来被冠之以名。但学习设计模式是必要的，因为知道了有哪些设计模式，才能更清楚地知道自己的代码写得好不好，以及怎么使用适合的设计模式来改善自己的代码。\n\n二是设计模式本质的一样的，但会随着不同语言，根据根据语言本身的特性的不同有不同的实现方式。好比针对Javascript，实现多态，继承和封装就和java不大一样。\n\n通过阅读上面提到的书，整理了关于javaScript的几个设计模式。首先，是原型模式。\n\n### 原型模式\n\n#### 介绍\n\n设计模式中，原型模式是用来创建对象的一种模式，我们可以用原型模式来创建一个一模一样的对象，但是通常目的只是为了更便捷地创建某个类型的对象。在Java中，创建对象的方法是先指定它的类型，然后后通过类的概念来创建对象。而对于Javascript这种没有类的语言，我们创建对象通常是找到一个对象，然后通过克隆它来创建一个对象。\n\n虽然ES6中有了class来创建一个类，但是它本质上还是用原型来创建对象的。\n\n#### 在js中的应用\n\nps：js中没有类的概念，只有对象的概念。但是为了区分不同对象充当的角色，通常用开头大学来标注它是一个“类”（抽象的对象），而开头小写来标注它是个具体的实例。\n\n##### 创建对象，实现继承\n\n- new创建对象，js的构造器其实是一个函数\n\n  js没有类的概念，而函数是js的一等公民，js中的函数可以作为普通函数被调用，也可以作为构造器被调用。我们创建对象使用的new关键词实际上就是在调用一个作为构造器的函数。当我们用new调用一个构造器，其实就是在克隆一个对象的过程。\n\n\n- 其实对象会记住它的原型，准确来说不是对象真的有一个原型，而是它的构造器有原型。对象把请求委托给它自己的原型其实更准确地说是对象把请求委托给它的构造器的原型。js给对象提供了一个名为*proto*的隐藏属性，chrome和firefox可以向外暴露对象的这个属性，这个属性默认会指向它的构造器的原型对象。\n\n  ``` javascript\n  new a = new Object();\n  console.log(a._proto_ === Object.prototype); //输出true\n  ```\n\n\n- 因为_*proto*记住了构造器的原型，所以我们说对象记住了它的原型，并通过原型来实现了继承。\n- 虽然js的对象最初都是由Object.proptype对象克隆来的，但对象构造器的原型可以动态地指向其他对象。当我们想创建一个继承B的对象A，只要把对象A的构造器的原型指向对象B，就能实现继承的效果。\n- js最常见的继承方式：\n\n``` javascript\nvar obj = { name: 'june'};\nvar A = function() {  }\nA.proptype = obj;\nvar a = new A();\nconsole.log(a.name); //输出：june\n```\n\n``` javascript\n// 一个类继承另外一个类\nvar A = function() {}\nA.prototype = { name: 'sven'};\nvar B = function() {}\nB.prototype = new A();\nvar b = new B();\nb.name; //=> sven\n```\n\n- 上面两端代码的目的是一样的，本质上也没有差别，区别只是一个将B.proptype直接指向一个字面量对象，一个是指向new A()，后者会比前者形成的原型链多了一层。\n\n- Object.create方法：我通常用它来创建一个基于某个现有对象的对象，但准确来说它就是通过原型模式来实现了一个次原型继承。\n\n  该方法实际等同于：\n\n  ```javascript\n  functionO(obj) {\n    var F = function() {\n      F.prototype = obj;\n      return new F();\n    }\n  }\n  var a = Object.create({}); //a.proptype为Object;\n  var b = Object.create(null); //b.proptype为null;\n\n  ```\n\n  #### 思考题\n\n  - prototype和constructor和*proto*傻傻分不清楚？\n\n    - **prototype 属性是可读写的，该属性是函数所特有,但准确来说该属性是为构造函数所量身定造的。** 这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有此构造器实例化出来的实例所共享的属性和方法。\n    - **被构造函数new 出来的对象是 实例对象，实例对象的属性 constructor 指向了构造函数。**对象的请求委托实际上是在对象自己无法应答请求的时候，将请求委托给构造器的原型。\n    - **实例对象的 proto 指向了构造器的原型对象(prototype属性).**\n\n    实践是唯一的真理：\n\n    - [![img](http://ww1.sinaimg.cn/large/63739cabgy1fgpk7qyezxj20ck0ebdgm.jpg)](http://ww1.sinaimg.cn/large/63739cabgy1fgpk7qyezxj20ck0ebdgm.jpg)\n\n      ​\n\n\n    - 为什么说当前的javascript引擎下，通过Object.create来创建对象比通过构造函数创建对象要慢呢？\n\n      待续…\n\n    - javascript创建对象的其它方式有哪些呢？\n\n      待续…\n\n    #### 总结\n\n    之前看红皮书和犀牛书，都不得不被对象继承和原型那一章节搞得晕乎乎。学习了原型模式后，其实现在看来，javascript其实就是依靠原型模式来搭建整个面向对象系统的，js连类的概念都没有，更别说继承了。实际上，为了实现js的继承，我们利用的是原型的机制，所有的js对象都是从某个对象克隆而来的。而原型这两个字其实就是它表面的意思，如果A对象是从B对象克隆而来的，那么B对象就是A对象的原型。","slug":"javascript设计模式-原型模式","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwmx000ccgesfztddltn","content":"<p>之前对设计模式的学习和实践都是基于Java的。虽说设计模式其实无关语言，仅仅是对某一种问题的特定的一种解决方案和设计思想。但是最近看的曾探写的《Javascript设计模式与开发实践》深有体会。一是，认同作者认为设计模式说白了就是对某一种问题的解决方案和设计思路，只是后来被冠之以名。但学习设计模式是必要的，因为知道了有哪些设计模式，才能更清楚地知道自己的代码写得好不好，以及怎么使用适合的设计模式来改善自己的代码。</p>\n<p>二是设计模式本质的一样的，但会随着不同语言，根据根据语言本身的特性的不同有不同的实现方式。好比针对Javascript，实现多态，继承和封装就和java不大一样。</p>\n<p>通过阅读上面提到的书，整理了关于javaScript的几个设计模式。首先，是原型模式。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>设计模式中，原型模式是用来创建对象的一种模式，我们可以用原型模式来创建一个一模一样的对象，但是通常目的只是为了更便捷地创建某个类型的对象。在Java中，创建对象的方法是先指定它的类型，然后后通过类的概念来创建对象。而对于Javascript这种没有类的语言，我们创建对象通常是找到一个对象，然后通过克隆它来创建一个对象。</p>\n<p>虽然ES6中有了class来创建一个类，但是它本质上还是用原型来创建对象的。</p>\n<h4 id=\"在js中的应用\"><a href=\"#在js中的应用\" class=\"headerlink\" title=\"在js中的应用\"></a>在js中的应用</h4><p>ps：js中没有类的概念，只有对象的概念。但是为了区分不同对象充当的角色，通常用开头大学来标注它是一个“类”（抽象的对象），而开头小写来标注它是个具体的实例。</p>\n<h5 id=\"创建对象，实现继承\"><a href=\"#创建对象，实现继承\" class=\"headerlink\" title=\"创建对象，实现继承\"></a>创建对象，实现继承</h5><ul>\n<li><p>new创建对象，js的构造器其实是一个函数</p>\n<p>js没有类的概念，而函数是js的一等公民，js中的函数可以作为普通函数被调用，也可以作为构造器被调用。我们创建对象使用的new关键词实际上就是在调用一个作为构造器的函数。当我们用new调用一个构造器，其实就是在克隆一个对象的过程。</p>\n</li>\n</ul>\n<ul>\n<li><p>其实对象会记住它的原型，准确来说不是对象真的有一个原型，而是它的构造器有原型。对象把请求委托给它自己的原型其实更准确地说是对象把请求委托给它的构造器的原型。js给对象提供了一个名为<em>proto</em>的隐藏属性，chrome和firefox可以向外暴露对象的这个属性，这个属性默认会指向它的构造器的原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a._proto_ === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">//输出true</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>因为_<em>proto</em>记住了构造器的原型，所以我们说对象记住了它的原型，并通过原型来实现了继承。</p>\n</li>\n<li>虽然js的对象最初都是由Object.proptype对象克隆来的，但对象构造器的原型可以动态地指向其他对象。当我们想创建一个继承B的对象A，只要把对象A的构造器的原型指向对象B，就能实现继承的效果。</li>\n<li>js最常见的继承方式：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'june'</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  &#125;</div><div class=\"line\">A.proptype = obj;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a.name); <span class=\"comment\">//输出：june</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 一个类继承另外一个类</span></div><div class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">A.prototype = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'sven'</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> B = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">B.prototype = <span class=\"keyword\">new</span> A();</div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> B();</div><div class=\"line\">b.name; <span class=\"comment\">//=&gt; sven</span></div></pre></td></tr></table></figure>\n<ul>\n<li><p>上面两端代码的目的是一样的，本质上也没有差别，区别只是一个将B.proptype直接指向一个字面量对象，一个是指向new A()，后者会比前者形成的原型链多了一层。</p>\n</li>\n<li><p>Object.create方法：我通常用它来创建一个基于某个现有对象的对象，但准确来说它就是通过原型模式来实现了一个次原型继承。</p>\n<p>该方法实际等同于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">functionO(obj) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    F.prototype = obj;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Object</span>.create(&#123;&#125;); <span class=\"comment\">//a.proptype为Object;</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>); <span class=\"comment\">//b.proptype为null;</span></div></pre></td></tr></table></figure>\n<h4 id=\"思考题\"><a href=\"#思考题\" class=\"headerlink\" title=\"思考题\"></a>思考题</h4><ul>\n<li><p>prototype和constructor和<em>proto</em>傻傻分不清楚？</p>\n<ul>\n<li><strong>prototype 属性是可读写的，该属性是函数所特有,但准确来说该属性是为构造函数所量身定造的。</strong> 这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有此构造器实例化出来的实例所共享的属性和方法。</li>\n<li><strong>被构造函数new 出来的对象是 实例对象，实例对象的属性 constructor 指向了构造函数。</strong>对象的请求委托实际上是在对象自己无法应答请求的时候，将请求委托给构造器的原型。</li>\n<li><strong>实例对象的 proto 指向了构造器的原型对象(prototype属性).</strong></li>\n</ul>\n<p>实践是唯一的真理：</p>\n<ul>\n<li><p><a href=\"http://ww1.sinaimg.cn/large/63739cabgy1fgpk7qyezxj20ck0ebdgm.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww1.sinaimg.cn/large/63739cabgy1fgpk7qyezxj20ck0ebdgm.jpg\" alt=\"img\"></a></p>\n<p>​</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>- 为什么说当前的javascript引擎下，通过Object.create来创建对象比通过构造函数创建对象要慢呢？\n\n  待续…\n\n- javascript创建对象的其它方式有哪些呢？\n\n  待续…\n\n#### 总结\n\n之前看红皮书和犀牛书，都不得不被对象继承和原型那一章节搞得晕乎乎。学习了原型模式后，其实现在看来，javascript其实就是依靠原型模式来搭建整个面向对象系统的，js连类的概念都没有，更别说继承了。实际上，为了实现js的继承，我们利用的是原型的机制，所有的js对象都是从某个对象克隆而来的。而原型这两个字其实就是它表面的意思，如果A对象是从B对象克隆而来的，那么B对象就是A对象的原型。\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>之前对设计模式的学习和实践都是基于Java的。虽说设计模式其实无关语言，仅仅是对某一种问题的特定的一种解决方案和设计思想。但是最近看的曾探写的《Javascript设计模式与开发实践》深有体会。一是，认同作者认为设计模式说白了就是对某一种问题的解决方案和设计思路，只是后来被冠之以名。但学习设计模式是必要的，因为知道了有哪些设计模式，才能更清楚地知道自己的代码写得好不好，以及怎么使用适合的设计模式来改善自己的代码。</p>\n<p>二是设计模式本质的一样的，但会随着不同语言，根据根据语言本身的特性的不同有不同的实现方式。好比针对Javascript，实现多态，继承和封装就和java不大一样。</p>\n<p>通过阅读上面提到的书，整理了关于javaScript的几个设计模式。首先，是原型模式。</p>\n<h3 id=\"原型模式\"><a href=\"#原型模式\" class=\"headerlink\" title=\"原型模式\"></a>原型模式</h3><h4 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h4><p>设计模式中，原型模式是用来创建对象的一种模式，我们可以用原型模式来创建一个一模一样的对象，但是通常目的只是为了更便捷地创建某个类型的对象。在Java中，创建对象的方法是先指定它的类型，然后后通过类的概念来创建对象。而对于Javascript这种没有类的语言，我们创建对象通常是找到一个对象，然后通过克隆它来创建一个对象。</p>\n<p>虽然ES6中有了class来创建一个类，但是它本质上还是用原型来创建对象的。</p>\n<h4 id=\"在js中的应用\"><a href=\"#在js中的应用\" class=\"headerlink\" title=\"在js中的应用\"></a>在js中的应用</h4><p>ps：js中没有类的概念，只有对象的概念。但是为了区分不同对象充当的角色，通常用开头大学来标注它是一个“类”（抽象的对象），而开头小写来标注它是个具体的实例。</p>\n<h5 id=\"创建对象，实现继承\"><a href=\"#创建对象，实现继承\" class=\"headerlink\" title=\"创建对象，实现继承\"></a>创建对象，实现继承</h5><ul>\n<li><p>new创建对象，js的构造器其实是一个函数</p>\n<p>js没有类的概念，而函数是js的一等公民，js中的函数可以作为普通函数被调用，也可以作为构造器被调用。我们创建对象使用的new关键词实际上就是在调用一个作为构造器的函数。当我们用new调用一个构造器，其实就是在克隆一个对象的过程。</p>\n</li>\n</ul>\n<ul>\n<li><p>其实对象会记住它的原型，准确来说不是对象真的有一个原型，而是它的构造器有原型。对象把请求委托给它自己的原型其实更准确地说是对象把请求委托给它的构造器的原型。js给对象提供了一个名为<em>proto</em>的隐藏属性，chrome和firefox可以向外暴露对象的这个属性，这个属性默认会指向它的构造器的原型对象。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> a = <span class=\"keyword\">new</span> <span class=\"built_in\">Object</span>();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a._proto_ === <span class=\"built_in\">Object</span>.prototype); <span class=\"comment\">//输出true</span></div></pre></td></tr></table></figure>\n</li>\n<li><p>因为_<em>proto</em>记住了构造器的原型，所以我们说对象记住了它的原型，并通过原型来实现了继承。</p>\n</li>\n<li>虽然js的对象最初都是由Object.proptype对象克隆来的，但对象构造器的原型可以动态地指向其他对象。当我们想创建一个继承B的对象A，只要把对象A的构造器的原型指向对象B，就能实现继承的效果。</li>\n<li>js最常见的继承方式：</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> obj = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'june'</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;  &#125;</div><div class=\"line\">A.proptype = obj;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"keyword\">new</span> A();</div><div class=\"line\"><span class=\"built_in\">console</span>.log(a.name); <span class=\"comment\">//输出：june</span></div></pre></td></tr></table></figure>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 一个类继承另外一个类</span></div><div class=\"line\"><span class=\"keyword\">var</span> A = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">A.prototype = &#123; <span class=\"attr\">name</span>: <span class=\"string\">'sven'</span>&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> B = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;&#125;</div><div class=\"line\">B.prototype = <span class=\"keyword\">new</span> A();</div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"keyword\">new</span> B();</div><div class=\"line\">b.name; <span class=\"comment\">//=&gt; sven</span></div></pre></td></tr></table></figure>\n<ul>\n<li><p>上面两端代码的目的是一样的，本质上也没有差别，区别只是一个将B.proptype直接指向一个字面量对象，一个是指向new A()，后者会比前者形成的原型链多了一层。</p>\n</li>\n<li><p>Object.create方法：我通常用它来创建一个基于某个现有对象的对象，但准确来说它就是通过原型模式来实现了一个次原型继承。</p>\n<p>该方法实际等同于：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">functionO(obj) &#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> F = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">    F.prototype = obj;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> F();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"built_in\">Object</span>.create(&#123;&#125;); <span class=\"comment\">//a.proptype为Object;</span></div><div class=\"line\"><span class=\"keyword\">var</span> b = <span class=\"built_in\">Object</span>.create(<span class=\"literal\">null</span>); <span class=\"comment\">//b.proptype为null;</span></div></pre></td></tr></table></figure>\n<h4 id=\"思考题\"><a href=\"#思考题\" class=\"headerlink\" title=\"思考题\"></a>思考题</h4><ul>\n<li><p>prototype和constructor和<em>proto</em>傻傻分不清楚？</p>\n<ul>\n<li><strong>prototype 属性是可读写的，该属性是函数所特有,但准确来说该属性是为构造函数所量身定造的。</strong> 这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有此构造器实例化出来的实例所共享的属性和方法。</li>\n<li><strong>被构造函数new 出来的对象是 实例对象，实例对象的属性 constructor 指向了构造函数。</strong>对象的请求委托实际上是在对象自己无法应答请求的时候，将请求委托给构造器的原型。</li>\n<li><strong>实例对象的 proto 指向了构造器的原型对象(prototype属性).</strong></li>\n</ul>\n<p>实践是唯一的真理：</p>\n<ul>\n<li><p><a href=\"http://ww1.sinaimg.cn/large/63739cabgy1fgpk7qyezxj20ck0ebdgm.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww1.sinaimg.cn/large/63739cabgy1fgpk7qyezxj20ck0ebdgm.jpg\" alt=\"img\"></a></p>\n<p>​</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<pre><code>- 为什么说当前的javascript引擎下，通过Object.create来创建对象比通过构造函数创建对象要慢呢？\n\n  待续…\n\n- javascript创建对象的其它方式有哪些呢？\n\n  待续…\n\n#### 总结\n\n之前看红皮书和犀牛书，都不得不被对象继承和原型那一章节搞得晕乎乎。学习了原型模式后，其实现在看来，javascript其实就是依靠原型模式来搭建整个面向对象系统的，js连类的概念都没有，更别说继承了。实际上，为了实现js的继承，我们利用的是原型的机制，所有的js对象都是从某个对象克隆而来的。而原型这两个字其实就是它表面的意思，如果A对象是从B对象克隆而来的，那么B对象就是A对象的原型。\n</code></pre>"},{"title":"优化webpack","date":"2017-05-20T15:13:58.000Z","_content":"\n最近的工作不大忙，大致是看看现有的代码，熟悉业务，修复一些小问题。而最近对某个项目代码进行webpack优化，得出了关于webpack优化的几个方法。\n\n1. webpack内置优化工具\n\n   - webpack.optimize.UglifyJsPlugin 代码压缩：配置选项可以参考[uglify-webpack-plugin](https://doc.webpack-china.org/plugins/uglifyjs-webpack-plugin/)\n\n     ```javascript\n     new UglifyJsPlugin({\n         // 最紧凑的输出\n         beautify: false,\n         // 删除所有的注释\n         comments: false,\n         compress: {\n           // 在UglifyJs删除没有用到的代码时不输出警告  \n           warnings: false,\n           // 删除所有的 `console` 语句\n           // 还可以兼容ie浏览器\n           drop_console: true,\n           // 内嵌定义了但是只用到一次的变量\n           collapse_vars: true,\n           // 提取出出现多次但是没有定义成变量去引用的静态值\n           reduce_vars: true,\n         }\n     })\n     ```\n\n\n1. - ​\n\n   - - [DefinePlugin](https://doc.webpack-china.org/plugins/define-plugin/) 替换某些包为生产环境版本，比如react。\n     - [CommonsChunkPlugin](https://doc.webpack-china.org/plugins/commons-chunk-plugin/) 公共模块的拆分，使用于多页面引用了公共模块的情景。\n     - [ExtractTextWebpackPlugin](https://doc.webpack-china.org/plugins/extract-text-webpack-plugin/) 把内嵌在JS bundle的样式放到独立的CSS文件。适用于样式文件较大的情况。\n\n   - 根据打包信息来分析可优化点\n\n     生成stats.json: `webpack --profile --json > stas.json`\n\n     - 可视化分析工具:\n\n       线上web：\n\n       - [webpack chart](https://alexkuz.github.io/webpack-chart/)：适合来总体查看打包的情况（各部分的占用空间）\n       - [webpack analyse](http://webpack.github.io/analyse/):适合用来追踪问题的来源\n\n       插件：\n\n       - [webpack-bundle-analyzer](http://www.opendigg.com/p/webpack-bundle-analyzer): 在webpack.config.json里面配置好，可以在每次build的时候自动在8080端口启动一个服务器显示webpack打包情况\n\n     - 参数\n\n       - stat size: 原始打包的大小\n       - parse size: uglify压缩后的大小\n       - gizp size：启动gizp后的大小\n       - lodash按需加载\n\n   - lodash是个好东西，但是也是个大家伙（500+k），如果可以按需加载，可以大大减少打包的lodash的体积。\n\n     优化方法：\n\n     - 利用webpack2的treeshaking可以一定程度削减没有用到的lodash模块。启动treeshaking的方法\n     - 更彻底的方法是使用[lodash-webpack-plugin](https://github.com/lodash/lodash-webpack-plugin)插件。（ps：如果是使用了typescript的项目，需要用awesome-typescript-loader或者ts-loader+babel-loader来处理ts/tsx文件，因为使用这个插件要用到bebel-plugin-lodash，还要注意它支持module为es2015或者es6的模块机制，设置成commonjs的话是不生效的！！\n\n   - 对于应用目标环境是node的libray,可以采用[[webpack-node-externals](https://www.npmjs.com/package/webpack-node-externals)剔除不必要的包。\n\n     #### 参考资料\n\n     - [Webpack官方文档](https://webpack.js.org/guides/production-build/)\n     - [webpack打包bundle.js体积大小优化](https://github.com/youngwind/blog/issues/65)\n     - [lodash按需加载的几种方式](https://imys.net/20161217/webpack-use-lodash.html)\n     - [webpack2 终极优化- 腾讯Web前端IMWeb 团队社区| blog | 团队博客](http://imweb.io/topic/5868e1abb3ce6d8e3f9f99bb)","source":"_posts/优化webpack.md","raw":"---\ntitle: 优化webpack\ndate: 2017-5-20 23:13:58\ntags: 前端工具\n---\n\n最近的工作不大忙，大致是看看现有的代码，熟悉业务，修复一些小问题。而最近对某个项目代码进行webpack优化，得出了关于webpack优化的几个方法。\n\n1. webpack内置优化工具\n\n   - webpack.optimize.UglifyJsPlugin 代码压缩：配置选项可以参考[uglify-webpack-plugin](https://doc.webpack-china.org/plugins/uglifyjs-webpack-plugin/)\n\n     ```javascript\n     new UglifyJsPlugin({\n         // 最紧凑的输出\n         beautify: false,\n         // 删除所有的注释\n         comments: false,\n         compress: {\n           // 在UglifyJs删除没有用到的代码时不输出警告  \n           warnings: false,\n           // 删除所有的 `console` 语句\n           // 还可以兼容ie浏览器\n           drop_console: true,\n           // 内嵌定义了但是只用到一次的变量\n           collapse_vars: true,\n           // 提取出出现多次但是没有定义成变量去引用的静态值\n           reduce_vars: true,\n         }\n     })\n     ```\n\n\n1. - ​\n\n   - - [DefinePlugin](https://doc.webpack-china.org/plugins/define-plugin/) 替换某些包为生产环境版本，比如react。\n     - [CommonsChunkPlugin](https://doc.webpack-china.org/plugins/commons-chunk-plugin/) 公共模块的拆分，使用于多页面引用了公共模块的情景。\n     - [ExtractTextWebpackPlugin](https://doc.webpack-china.org/plugins/extract-text-webpack-plugin/) 把内嵌在JS bundle的样式放到独立的CSS文件。适用于样式文件较大的情况。\n\n   - 根据打包信息来分析可优化点\n\n     生成stats.json: `webpack --profile --json > stas.json`\n\n     - 可视化分析工具:\n\n       线上web：\n\n       - [webpack chart](https://alexkuz.github.io/webpack-chart/)：适合来总体查看打包的情况（各部分的占用空间）\n       - [webpack analyse](http://webpack.github.io/analyse/):适合用来追踪问题的来源\n\n       插件：\n\n       - [webpack-bundle-analyzer](http://www.opendigg.com/p/webpack-bundle-analyzer): 在webpack.config.json里面配置好，可以在每次build的时候自动在8080端口启动一个服务器显示webpack打包情况\n\n     - 参数\n\n       - stat size: 原始打包的大小\n       - parse size: uglify压缩后的大小\n       - gizp size：启动gizp后的大小\n       - lodash按需加载\n\n   - lodash是个好东西，但是也是个大家伙（500+k），如果可以按需加载，可以大大减少打包的lodash的体积。\n\n     优化方法：\n\n     - 利用webpack2的treeshaking可以一定程度削减没有用到的lodash模块。启动treeshaking的方法\n     - 更彻底的方法是使用[lodash-webpack-plugin](https://github.com/lodash/lodash-webpack-plugin)插件。（ps：如果是使用了typescript的项目，需要用awesome-typescript-loader或者ts-loader+babel-loader来处理ts/tsx文件，因为使用这个插件要用到bebel-plugin-lodash，还要注意它支持module为es2015或者es6的模块机制，设置成commonjs的话是不生效的！！\n\n   - 对于应用目标环境是node的libray,可以采用[[webpack-node-externals](https://www.npmjs.com/package/webpack-node-externals)剔除不必要的包。\n\n     #### 参考资料\n\n     - [Webpack官方文档](https://webpack.js.org/guides/production-build/)\n     - [webpack打包bundle.js体积大小优化](https://github.com/youngwind/blog/issues/65)\n     - [lodash按需加载的几种方式](https://imys.net/20161217/webpack-use-lodash.html)\n     - [webpack2 终极优化- 腾讯Web前端IMWeb 团队社区| blog | 团队博客](http://imweb.io/topic/5868e1abb3ce6d8e3f9f99bb)","slug":"优化webpack","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwmz000dcges64lktmjw","content":"<p>最近的工作不大忙，大致是看看现有的代码，熟悉业务，修复一些小问题。而最近对某个项目代码进行webpack优化，得出了关于webpack优化的几个方法。</p>\n<ol>\n<li><p>webpack内置优化工具</p>\n<ul>\n<li><p>webpack.optimize.UglifyJsPlugin 代码压缩：配置选项可以参考<a href=\"https://doc.webpack-china.org/plugins/uglifyjs-webpack-plugin/\" target=\"_blank\" rel=\"external\">uglify-webpack-plugin</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> UglifyJsPlugin(&#123;</div><div class=\"line\">    <span class=\"comment\">// 最紧凑的输出</span></div><div class=\"line\">    beautify: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"comment\">// 删除所有的注释</span></div><div class=\"line\">    comments: <span class=\"literal\">false</span>,</div><div class=\"line\">    compress: &#123;</div><div class=\"line\">      <span class=\"comment\">// 在UglifyJs删除没有用到的代码时不输出警告  </span></div><div class=\"line\">      warnings: <span class=\"literal\">false</span>,</div><div class=\"line\">      <span class=\"comment\">// 删除所有的 `console` 语句</span></div><div class=\"line\">      <span class=\"comment\">// 还可以兼容ie浏览器</span></div><div class=\"line\">      drop_console: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"comment\">// 内嵌定义了但是只用到一次的变量</span></div><div class=\"line\">      collapse_vars: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"comment\">// 提取出出现多次但是没有定义成变量去引用的静态值</span></div><div class=\"line\">      reduce_vars: <span class=\"literal\">true</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><p>​</p>\n</li>\n<li><ul>\n<li><a href=\"https://doc.webpack-china.org/plugins/define-plugin/\" target=\"_blank\" rel=\"external\">DefinePlugin</a> 替换某些包为生产环境版本，比如react。</li>\n<li><a href=\"https://doc.webpack-china.org/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"external\">CommonsChunkPlugin</a> 公共模块的拆分，使用于多页面引用了公共模块的情景。</li>\n<li><a href=\"https://doc.webpack-china.org/plugins/extract-text-webpack-plugin/\" target=\"_blank\" rel=\"external\">ExtractTextWebpackPlugin</a> 把内嵌在JS bundle的样式放到独立的CSS文件。适用于样式文件较大的情况。</li>\n</ul>\n</li>\n<li><p>根据打包信息来分析可优化点</p>\n<p>生成stats.json: <code>webpack --profile --json &gt; stas.json</code></p>\n<ul>\n<li><p>可视化分析工具:</p>\n<p>线上web：</p>\n<ul>\n<li><a href=\"https://alexkuz.github.io/webpack-chart/\" target=\"_blank\" rel=\"external\">webpack chart</a>：适合来总体查看打包的情况（各部分的占用空间）</li>\n<li><a href=\"http://webpack.github.io/analyse/\" target=\"_blank\" rel=\"external\">webpack analyse</a>:适合用来追踪问题的来源</li>\n</ul>\n<p>插件：</p>\n<ul>\n<li><a href=\"http://www.opendigg.com/p/webpack-bundle-analyzer\" target=\"_blank\" rel=\"external\">webpack-bundle-analyzer</a>: 在webpack.config.json里面配置好，可以在每次build的时候自动在8080端口启动一个服务器显示webpack打包情况</li>\n</ul>\n</li>\n<li><p>参数</p>\n<ul>\n<li>stat size: 原始打包的大小</li>\n<li>parse size: uglify压缩后的大小</li>\n<li>gizp size：启动gizp后的大小</li>\n<li>lodash按需加载</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>lodash是个好东西，但是也是个大家伙（500+k），如果可以按需加载，可以大大减少打包的lodash的体积。</p>\n<p>优化方法：</p>\n<ul>\n<li>利用webpack2的treeshaking可以一定程度削减没有用到的lodash模块。启动treeshaking的方法</li>\n<li>更彻底的方法是使用<a href=\"https://github.com/lodash/lodash-webpack-plugin\" target=\"_blank\" rel=\"external\">lodash-webpack-plugin</a>插件。（ps：如果是使用了typescript的项目，需要用awesome-typescript-loader或者ts-loader+babel-loader来处理ts/tsx文件，因为使用这个插件要用到bebel-plugin-lodash，还要注意它支持module为es2015或者es6的模块机制，设置成commonjs的话是不生效的！！</li>\n</ul>\n</li>\n<li><p>对于应用目标环境是node的libray,可以采用[<a href=\"https://www.npmjs.com/package/webpack-node-externals\" target=\"_blank\" rel=\"external\">webpack-node-externals</a>剔除不必要的包。</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ul>\n<li><a href=\"https://webpack.js.org/guides/production-build/\" target=\"_blank\" rel=\"external\">Webpack官方文档</a></li>\n<li><a href=\"https://github.com/youngwind/blog/issues/65\" target=\"_blank\" rel=\"external\">webpack打包bundle.js体积大小优化</a></li>\n<li><a href=\"https://imys.net/20161217/webpack-use-lodash.html\" target=\"_blank\" rel=\"external\">lodash按需加载的几种方式</a></li>\n<li><a href=\"http://imweb.io/topic/5868e1abb3ce6d8e3f9f99bb\" target=\"_blank\" rel=\"external\">webpack2 终极优化- 腾讯Web前端IMWeb 团队社区| blog | 团队博客</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>最近的工作不大忙，大致是看看现有的代码，熟悉业务，修复一些小问题。而最近对某个项目代码进行webpack优化，得出了关于webpack优化的几个方法。</p>\n<ol>\n<li><p>webpack内置优化工具</p>\n<ul>\n<li><p>webpack.optimize.UglifyJsPlugin 代码压缩：配置选项可以参考<a href=\"https://doc.webpack-china.org/plugins/uglifyjs-webpack-plugin/\" target=\"_blank\" rel=\"external\">uglify-webpack-plugin</a></p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> UglifyJsPlugin(&#123;</div><div class=\"line\">    <span class=\"comment\">// 最紧凑的输出</span></div><div class=\"line\">    beautify: <span class=\"literal\">false</span>,</div><div class=\"line\">    <span class=\"comment\">// 删除所有的注释</span></div><div class=\"line\">    comments: <span class=\"literal\">false</span>,</div><div class=\"line\">    compress: &#123;</div><div class=\"line\">      <span class=\"comment\">// 在UglifyJs删除没有用到的代码时不输出警告  </span></div><div class=\"line\">      warnings: <span class=\"literal\">false</span>,</div><div class=\"line\">      <span class=\"comment\">// 删除所有的 `console` 语句</span></div><div class=\"line\">      <span class=\"comment\">// 还可以兼容ie浏览器</span></div><div class=\"line\">      drop_console: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"comment\">// 内嵌定义了但是只用到一次的变量</span></div><div class=\"line\">      collapse_vars: <span class=\"literal\">true</span>,</div><div class=\"line\">      <span class=\"comment\">// 提取出出现多次但是没有定义成变量去引用的静态值</span></div><div class=\"line\">      reduce_vars: <span class=\"literal\">true</span>,</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n</li>\n</ul>\n</li>\n<li><ul>\n<li><p>​</p>\n</li>\n<li><ul>\n<li><a href=\"https://doc.webpack-china.org/plugins/define-plugin/\" target=\"_blank\" rel=\"external\">DefinePlugin</a> 替换某些包为生产环境版本，比如react。</li>\n<li><a href=\"https://doc.webpack-china.org/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"external\">CommonsChunkPlugin</a> 公共模块的拆分，使用于多页面引用了公共模块的情景。</li>\n<li><a href=\"https://doc.webpack-china.org/plugins/extract-text-webpack-plugin/\" target=\"_blank\" rel=\"external\">ExtractTextWebpackPlugin</a> 把内嵌在JS bundle的样式放到独立的CSS文件。适用于样式文件较大的情况。</li>\n</ul>\n</li>\n<li><p>根据打包信息来分析可优化点</p>\n<p>生成stats.json: <code>webpack --profile --json &gt; stas.json</code></p>\n<ul>\n<li><p>可视化分析工具:</p>\n<p>线上web：</p>\n<ul>\n<li><a href=\"https://alexkuz.github.io/webpack-chart/\" target=\"_blank\" rel=\"external\">webpack chart</a>：适合来总体查看打包的情况（各部分的占用空间）</li>\n<li><a href=\"http://webpack.github.io/analyse/\" target=\"_blank\" rel=\"external\">webpack analyse</a>:适合用来追踪问题的来源</li>\n</ul>\n<p>插件：</p>\n<ul>\n<li><a href=\"http://www.opendigg.com/p/webpack-bundle-analyzer\" target=\"_blank\" rel=\"external\">webpack-bundle-analyzer</a>: 在webpack.config.json里面配置好，可以在每次build的时候自动在8080端口启动一个服务器显示webpack打包情况</li>\n</ul>\n</li>\n<li><p>参数</p>\n<ul>\n<li>stat size: 原始打包的大小</li>\n<li>parse size: uglify压缩后的大小</li>\n<li>gizp size：启动gizp后的大小</li>\n<li>lodash按需加载</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>lodash是个好东西，但是也是个大家伙（500+k），如果可以按需加载，可以大大减少打包的lodash的体积。</p>\n<p>优化方法：</p>\n<ul>\n<li>利用webpack2的treeshaking可以一定程度削减没有用到的lodash模块。启动treeshaking的方法</li>\n<li>更彻底的方法是使用<a href=\"https://github.com/lodash/lodash-webpack-plugin\" target=\"_blank\" rel=\"external\">lodash-webpack-plugin</a>插件。（ps：如果是使用了typescript的项目，需要用awesome-typescript-loader或者ts-loader+babel-loader来处理ts/tsx文件，因为使用这个插件要用到bebel-plugin-lodash，还要注意它支持module为es2015或者es6的模块机制，设置成commonjs的话是不生效的！！</li>\n</ul>\n</li>\n<li><p>对于应用目标环境是node的libray,可以采用[<a href=\"https://www.npmjs.com/package/webpack-node-externals\" target=\"_blank\" rel=\"external\">webpack-node-externals</a>剔除不必要的包。</p>\n<h4 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h4><ul>\n<li><a href=\"https://webpack.js.org/guides/production-build/\" target=\"_blank\" rel=\"external\">Webpack官方文档</a></li>\n<li><a href=\"https://github.com/youngwind/blog/issues/65\" target=\"_blank\" rel=\"external\">webpack打包bundle.js体积大小优化</a></li>\n<li><a href=\"https://imys.net/20161217/webpack-use-lodash.html\" target=\"_blank\" rel=\"external\">lodash按需加载的几种方式</a></li>\n<li><a href=\"http://imweb.io/topic/5868e1abb3ce6d8e3f9f99bb\" target=\"_blank\" rel=\"external\">webpack2 终极优化- 腾讯Web前端IMWeb 团队社区| blog | 团队博客</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n"},{"title":"关于时间管理","date":"2017-01-02T15:13:58.000Z","_content":"\n这个月，感觉忙得焦头烂额，但是忙碌过后却觉得成效不大。原本制定的学习计划，却没能实施。只忙着工作的事情，没有预留时间去学习，最终自己的压力如滚雪球般越来越大，不知不觉便陷入恶性循环。直到，时间管理这个词跳了出来。\n\n### 时间管理\n\n> the way that you organize and plan how long you spend on specific activities.\n\n这是时间管理的定义。缺乏时间管理，自己的时间便永远被外在事物所支配，永远觉得没时间去做自己想做的事情，永远觉得有做不完的事情。\n学会时间管理，掌握主宰时间的技能，虽然事情很多，但你知道这一切都有条理地进行，随之自己也变得比较安心。\n\n### 理想与现实–为什么要进行时间管理\n\n没有意识到时间管理，其实是没有意识到许多事实，就我个人而言，我之前没有意识到的就要以下几点：\n\n1.理想总是美好的，我们有好多想看的书，想做的事情，想在工作上高效完工，想去约会吃饭。但是，一天只有24小时，一个月只有30天左右。时间很短，而自己可支配的时间更是少之又少。\n\n2.多数人只是个普通人，不能像超人一样，每遇到一件事都能立刻顺利解决。工作上，有许多不懂的地方，需要自己却学习研究出解决方案。学习上，也并非一朝一夕能见到成效，很多东西，都少不了坚持。\n\n3.工作不同于写作业。写作业，你可以做完这一个作业然后做下一个作业，做完了就去放肆玩耍。工作就是每天都有不同的任务，即使你做完了这个任务，永远会有下一个工作任务给你。\n\n4.勤奋有时并无卵用。应试教育下，许多人都习惯用表象或者任务型导向的思维来麻痹自己，却没真正去找到问题所在和真正的解决方法。如果你花了两天去看书，但是两天过去了书也看完了，但自己发现其实完全没看进去，那就是在浪费时间。要清楚你做的事情是否真的有意义。\n\n5.最后，要明白你不止需要工作，你还需要生活。\n\n### 开始改变\n\n#### 时间管理从计划开始\n\n##### 不仅仅是todolist\n\n很多人，虽然有制定todo List的习惯，但是经常一天下来，发现没有完成多少个todo。原因是制定时自己只想着今天要做什么，一股脑把想到的都列下来了，却没想过每个事情要花多少时间才能完成，今天应该先完成哪些事情。\n\n另外，许多人抱怨计划赶不上变化。对于一成不变，想要一劳永逸的计划来说的确如此，但实际上要明白计划不应该是一成不变的，为了赶上变化，它也是在不停调整和变化。\n\n##### 计划前要思考一些问题\n\n- 每天可支配的时间有多少？除去吃饭，睡觉，开会，放松娱乐的时间，真正可以被计划的时间有多少？\n- 自己要做的事情的有些？自己想做的事情有哪些？自己不得不做的事情有哪些？那些事情是亟待解决的？哪些事情是需要慢活出细工的？\n- 根据自己的经验或者对自己能力的评估，要做的事情要花多少时间？可能会遇到哪些瓶颈？如果做不完该怎么办？是必须要在今天加班做完，还是可以调整计划，推到明天做？\n- 怎么判断自己这一天达到了自己时间管理的计划？\n\n##### 时间计划包括哪些\n\n- 要做的事情\n- 事情的优先级\n- 每件事需要花费多少时间\n- 对于比较费时的任务，划分成子任务\n- 对于较难把握花多久时间完成的事情，把可能遇到的瓶颈列出来，以及解决途径和思路。\n- 完成的指标，便于一天下来回馈自己的完成进度。\n\n#### 实施与反馈\n\n- 严格按照时间计划进行，对于突如起来的事情或者变化，记录下来，便于之后调整计划。\n- 拒绝拖延，排除各种干扰，在进行一件事情时尽量投入。\n- 及时做总结。一天结束，给自己打个分。对于没有实施或者做完的事情，找出原因所在，如何解决或者改善，调整计划。\n\n最后，祝愿大家每天都过得妥妥的~","source":"_posts/关于时间管理.md","raw":"---\ntitle: 关于时间管理\ndate: 2017-1-2 23:13:58\ntags: 杂谈\n---\n\n这个月，感觉忙得焦头烂额，但是忙碌过后却觉得成效不大。原本制定的学习计划，却没能实施。只忙着工作的事情，没有预留时间去学习，最终自己的压力如滚雪球般越来越大，不知不觉便陷入恶性循环。直到，时间管理这个词跳了出来。\n\n### 时间管理\n\n> the way that you organize and plan how long you spend on specific activities.\n\n这是时间管理的定义。缺乏时间管理，自己的时间便永远被外在事物所支配，永远觉得没时间去做自己想做的事情，永远觉得有做不完的事情。\n学会时间管理，掌握主宰时间的技能，虽然事情很多，但你知道这一切都有条理地进行，随之自己也变得比较安心。\n\n### 理想与现实–为什么要进行时间管理\n\n没有意识到时间管理，其实是没有意识到许多事实，就我个人而言，我之前没有意识到的就要以下几点：\n\n1.理想总是美好的，我们有好多想看的书，想做的事情，想在工作上高效完工，想去约会吃饭。但是，一天只有24小时，一个月只有30天左右。时间很短，而自己可支配的时间更是少之又少。\n\n2.多数人只是个普通人，不能像超人一样，每遇到一件事都能立刻顺利解决。工作上，有许多不懂的地方，需要自己却学习研究出解决方案。学习上，也并非一朝一夕能见到成效，很多东西，都少不了坚持。\n\n3.工作不同于写作业。写作业，你可以做完这一个作业然后做下一个作业，做完了就去放肆玩耍。工作就是每天都有不同的任务，即使你做完了这个任务，永远会有下一个工作任务给你。\n\n4.勤奋有时并无卵用。应试教育下，许多人都习惯用表象或者任务型导向的思维来麻痹自己，却没真正去找到问题所在和真正的解决方法。如果你花了两天去看书，但是两天过去了书也看完了，但自己发现其实完全没看进去，那就是在浪费时间。要清楚你做的事情是否真的有意义。\n\n5.最后，要明白你不止需要工作，你还需要生活。\n\n### 开始改变\n\n#### 时间管理从计划开始\n\n##### 不仅仅是todolist\n\n很多人，虽然有制定todo List的习惯，但是经常一天下来，发现没有完成多少个todo。原因是制定时自己只想着今天要做什么，一股脑把想到的都列下来了，却没想过每个事情要花多少时间才能完成，今天应该先完成哪些事情。\n\n另外，许多人抱怨计划赶不上变化。对于一成不变，想要一劳永逸的计划来说的确如此，但实际上要明白计划不应该是一成不变的，为了赶上变化，它也是在不停调整和变化。\n\n##### 计划前要思考一些问题\n\n- 每天可支配的时间有多少？除去吃饭，睡觉，开会，放松娱乐的时间，真正可以被计划的时间有多少？\n- 自己要做的事情的有些？自己想做的事情有哪些？自己不得不做的事情有哪些？那些事情是亟待解决的？哪些事情是需要慢活出细工的？\n- 根据自己的经验或者对自己能力的评估，要做的事情要花多少时间？可能会遇到哪些瓶颈？如果做不完该怎么办？是必须要在今天加班做完，还是可以调整计划，推到明天做？\n- 怎么判断自己这一天达到了自己时间管理的计划？\n\n##### 时间计划包括哪些\n\n- 要做的事情\n- 事情的优先级\n- 每件事需要花费多少时间\n- 对于比较费时的任务，划分成子任务\n- 对于较难把握花多久时间完成的事情，把可能遇到的瓶颈列出来，以及解决途径和思路。\n- 完成的指标，便于一天下来回馈自己的完成进度。\n\n#### 实施与反馈\n\n- 严格按照时间计划进行，对于突如起来的事情或者变化，记录下来，便于之后调整计划。\n- 拒绝拖延，排除各种干扰，在进行一件事情时尽量投入。\n- 及时做总结。一天结束，给自己打个分。对于没有实施或者做完的事情，找出原因所在，如何解决或者改善，调整计划。\n\n最后，祝愿大家每天都过得妥妥的~","slug":"关于时间管理","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwn0000gcgesslcjuvsv","content":"<p>这个月，感觉忙得焦头烂额，但是忙碌过后却觉得成效不大。原本制定的学习计划，却没能实施。只忙着工作的事情，没有预留时间去学习，最终自己的压力如滚雪球般越来越大，不知不觉便陷入恶性循环。直到，时间管理这个词跳了出来。</p>\n<h3 id=\"时间管理\"><a href=\"#时间管理\" class=\"headerlink\" title=\"时间管理\"></a>时间管理</h3><blockquote>\n<p>the way that you organize and plan how long you spend on specific activities.</p>\n</blockquote>\n<p>这是时间管理的定义。缺乏时间管理，自己的时间便永远被外在事物所支配，永远觉得没时间去做自己想做的事情，永远觉得有做不完的事情。<br>学会时间管理，掌握主宰时间的技能，虽然事情很多，但你知道这一切都有条理地进行，随之自己也变得比较安心。</p>\n<h3 id=\"理想与现实–为什么要进行时间管理\"><a href=\"#理想与现实–为什么要进行时间管理\" class=\"headerlink\" title=\"理想与现实–为什么要进行时间管理\"></a>理想与现实–为什么要进行时间管理</h3><p>没有意识到时间管理，其实是没有意识到许多事实，就我个人而言，我之前没有意识到的就要以下几点：</p>\n<p>1.理想总是美好的，我们有好多想看的书，想做的事情，想在工作上高效完工，想去约会吃饭。但是，一天只有24小时，一个月只有30天左右。时间很短，而自己可支配的时间更是少之又少。</p>\n<p>2.多数人只是个普通人，不能像超人一样，每遇到一件事都能立刻顺利解决。工作上，有许多不懂的地方，需要自己却学习研究出解决方案。学习上，也并非一朝一夕能见到成效，很多东西，都少不了坚持。</p>\n<p>3.工作不同于写作业。写作业，你可以做完这一个作业然后做下一个作业，做完了就去放肆玩耍。工作就是每天都有不同的任务，即使你做完了这个任务，永远会有下一个工作任务给你。</p>\n<p>4.勤奋有时并无卵用。应试教育下，许多人都习惯用表象或者任务型导向的思维来麻痹自己，却没真正去找到问题所在和真正的解决方法。如果你花了两天去看书，但是两天过去了书也看完了，但自己发现其实完全没看进去，那就是在浪费时间。要清楚你做的事情是否真的有意义。</p>\n<p>5.最后，要明白你不止需要工作，你还需要生活。</p>\n<h3 id=\"开始改变\"><a href=\"#开始改变\" class=\"headerlink\" title=\"开始改变\"></a>开始改变</h3><h4 id=\"时间管理从计划开始\"><a href=\"#时间管理从计划开始\" class=\"headerlink\" title=\"时间管理从计划开始\"></a>时间管理从计划开始</h4><h5 id=\"不仅仅是todolist\"><a href=\"#不仅仅是todolist\" class=\"headerlink\" title=\"不仅仅是todolist\"></a>不仅仅是todolist</h5><p>很多人，虽然有制定todo List的习惯，但是经常一天下来，发现没有完成多少个todo。原因是制定时自己只想着今天要做什么，一股脑把想到的都列下来了，却没想过每个事情要花多少时间才能完成，今天应该先完成哪些事情。</p>\n<p>另外，许多人抱怨计划赶不上变化。对于一成不变，想要一劳永逸的计划来说的确如此，但实际上要明白计划不应该是一成不变的，为了赶上变化，它也是在不停调整和变化。</p>\n<h5 id=\"计划前要思考一些问题\"><a href=\"#计划前要思考一些问题\" class=\"headerlink\" title=\"计划前要思考一些问题\"></a>计划前要思考一些问题</h5><ul>\n<li>每天可支配的时间有多少？除去吃饭，睡觉，开会，放松娱乐的时间，真正可以被计划的时间有多少？</li>\n<li>自己要做的事情的有些？自己想做的事情有哪些？自己不得不做的事情有哪些？那些事情是亟待解决的？哪些事情是需要慢活出细工的？</li>\n<li>根据自己的经验或者对自己能力的评估，要做的事情要花多少时间？可能会遇到哪些瓶颈？如果做不完该怎么办？是必须要在今天加班做完，还是可以调整计划，推到明天做？</li>\n<li>怎么判断自己这一天达到了自己时间管理的计划？</li>\n</ul>\n<h5 id=\"时间计划包括哪些\"><a href=\"#时间计划包括哪些\" class=\"headerlink\" title=\"时间计划包括哪些\"></a>时间计划包括哪些</h5><ul>\n<li>要做的事情</li>\n<li>事情的优先级</li>\n<li>每件事需要花费多少时间</li>\n<li>对于比较费时的任务，划分成子任务</li>\n<li>对于较难把握花多久时间完成的事情，把可能遇到的瓶颈列出来，以及解决途径和思路。</li>\n<li>完成的指标，便于一天下来回馈自己的完成进度。</li>\n</ul>\n<h4 id=\"实施与反馈\"><a href=\"#实施与反馈\" class=\"headerlink\" title=\"实施与反馈\"></a>实施与反馈</h4><ul>\n<li>严格按照时间计划进行，对于突如起来的事情或者变化，记录下来，便于之后调整计划。</li>\n<li>拒绝拖延，排除各种干扰，在进行一件事情时尽量投入。</li>\n<li>及时做总结。一天结束，给自己打个分。对于没有实施或者做完的事情，找出原因所在，如何解决或者改善，调整计划。</li>\n</ul>\n<p>最后，祝愿大家每天都过得妥妥的~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这个月，感觉忙得焦头烂额，但是忙碌过后却觉得成效不大。原本制定的学习计划，却没能实施。只忙着工作的事情，没有预留时间去学习，最终自己的压力如滚雪球般越来越大，不知不觉便陷入恶性循环。直到，时间管理这个词跳了出来。</p>\n<h3 id=\"时间管理\"><a href=\"#时间管理\" class=\"headerlink\" title=\"时间管理\"></a>时间管理</h3><blockquote>\n<p>the way that you organize and plan how long you spend on specific activities.</p>\n</blockquote>\n<p>这是时间管理的定义。缺乏时间管理，自己的时间便永远被外在事物所支配，永远觉得没时间去做自己想做的事情，永远觉得有做不完的事情。<br>学会时间管理，掌握主宰时间的技能，虽然事情很多，但你知道这一切都有条理地进行，随之自己也变得比较安心。</p>\n<h3 id=\"理想与现实–为什么要进行时间管理\"><a href=\"#理想与现实–为什么要进行时间管理\" class=\"headerlink\" title=\"理想与现实–为什么要进行时间管理\"></a>理想与现实–为什么要进行时间管理</h3><p>没有意识到时间管理，其实是没有意识到许多事实，就我个人而言，我之前没有意识到的就要以下几点：</p>\n<p>1.理想总是美好的，我们有好多想看的书，想做的事情，想在工作上高效完工，想去约会吃饭。但是，一天只有24小时，一个月只有30天左右。时间很短，而自己可支配的时间更是少之又少。</p>\n<p>2.多数人只是个普通人，不能像超人一样，每遇到一件事都能立刻顺利解决。工作上，有许多不懂的地方，需要自己却学习研究出解决方案。学习上，也并非一朝一夕能见到成效，很多东西，都少不了坚持。</p>\n<p>3.工作不同于写作业。写作业，你可以做完这一个作业然后做下一个作业，做完了就去放肆玩耍。工作就是每天都有不同的任务，即使你做完了这个任务，永远会有下一个工作任务给你。</p>\n<p>4.勤奋有时并无卵用。应试教育下，许多人都习惯用表象或者任务型导向的思维来麻痹自己，却没真正去找到问题所在和真正的解决方法。如果你花了两天去看书，但是两天过去了书也看完了，但自己发现其实完全没看进去，那就是在浪费时间。要清楚你做的事情是否真的有意义。</p>\n<p>5.最后，要明白你不止需要工作，你还需要生活。</p>\n<h3 id=\"开始改变\"><a href=\"#开始改变\" class=\"headerlink\" title=\"开始改变\"></a>开始改变</h3><h4 id=\"时间管理从计划开始\"><a href=\"#时间管理从计划开始\" class=\"headerlink\" title=\"时间管理从计划开始\"></a>时间管理从计划开始</h4><h5 id=\"不仅仅是todolist\"><a href=\"#不仅仅是todolist\" class=\"headerlink\" title=\"不仅仅是todolist\"></a>不仅仅是todolist</h5><p>很多人，虽然有制定todo List的习惯，但是经常一天下来，发现没有完成多少个todo。原因是制定时自己只想着今天要做什么，一股脑把想到的都列下来了，却没想过每个事情要花多少时间才能完成，今天应该先完成哪些事情。</p>\n<p>另外，许多人抱怨计划赶不上变化。对于一成不变，想要一劳永逸的计划来说的确如此，但实际上要明白计划不应该是一成不变的，为了赶上变化，它也是在不停调整和变化。</p>\n<h5 id=\"计划前要思考一些问题\"><a href=\"#计划前要思考一些问题\" class=\"headerlink\" title=\"计划前要思考一些问题\"></a>计划前要思考一些问题</h5><ul>\n<li>每天可支配的时间有多少？除去吃饭，睡觉，开会，放松娱乐的时间，真正可以被计划的时间有多少？</li>\n<li>自己要做的事情的有些？自己想做的事情有哪些？自己不得不做的事情有哪些？那些事情是亟待解决的？哪些事情是需要慢活出细工的？</li>\n<li>根据自己的经验或者对自己能力的评估，要做的事情要花多少时间？可能会遇到哪些瓶颈？如果做不完该怎么办？是必须要在今天加班做完，还是可以调整计划，推到明天做？</li>\n<li>怎么判断自己这一天达到了自己时间管理的计划？</li>\n</ul>\n<h5 id=\"时间计划包括哪些\"><a href=\"#时间计划包括哪些\" class=\"headerlink\" title=\"时间计划包括哪些\"></a>时间计划包括哪些</h5><ul>\n<li>要做的事情</li>\n<li>事情的优先级</li>\n<li>每件事需要花费多少时间</li>\n<li>对于比较费时的任务，划分成子任务</li>\n<li>对于较难把握花多久时间完成的事情，把可能遇到的瓶颈列出来，以及解决途径和思路。</li>\n<li>完成的指标，便于一天下来回馈自己的完成进度。</li>\n</ul>\n<h4 id=\"实施与反馈\"><a href=\"#实施与反馈\" class=\"headerlink\" title=\"实施与反馈\"></a>实施与反馈</h4><ul>\n<li>严格按照时间计划进行，对于突如起来的事情或者变化，记录下来，便于之后调整计划。</li>\n<li>拒绝拖延，排除各种干扰，在进行一件事情时尽量投入。</li>\n<li>及时做总结。一天结束，给自己打个分。对于没有实施或者做完的事情，找出原因所在，如何解决或者改善，调整计划。</li>\n</ul>\n<p>最后，祝愿大家每天都过得妥妥的~</p>\n"},{"title":"前端工程化-gulp应用篇1","date":"2016-08-23T15:13:58.000Z","_content":"\n实习了一个星期，给我的工作还是比较简单的。根据设计稿来实现宣传页面。如果时间回退，接手这类工作，也许我会立刻开始切图，然后写html，css和js，并且在改样式的过程，少不了改完代码，为了看看效果，手动刷新页面。这样循环往复，等到大致完成了，再看看代码有什么要优化的，比如去掉无用的代码，顺便在压缩一下图片….终于完成的时候，感叹一声，前端真是个体力活啊！\n\n然而，现在的前端已经今非昔比，为了让前端的工作更加自动化，减少体力活，并且进一步优化，在开始一个项目之前，我们要搭建一个适合自己和这个项目的前端工作流。利用着空余时间，我学习了怎么去搭建这次项目的工作流，最终找到了真命天子gulp。下面我会根据我看到的一篇给[初学者的gulp教程](https://css-tricks.com/gulp-for-beginners/)来讲下如何搭建一个基础的前端工作流（你们把我下面的内容看成对上面的外文的一个简要的翻译版8）\n、\n\n## 正文\n\n> gulp是一个帮助web开发者来完成多个任务的工具，目的在于简化前端工作。\n\n### 为什么选择gulp？\n\ngulp通常被称为“前端构建工具”，流行的前端构建工具除了gulp还有grunt等等。gulp和grunt的目的都是一样的，它们的主要区别在于配置，gulp的配置通常更加简洁和简单，而且运行起来也更加快。现在，让我们来继续看看如何用gulp来搭建一个工作流。\n\n### 此次工作流的目标\n\n- 在本地服务器跑我们的前端项目\n- 将sass编译成css\n- 当修改文件时浏览器可以自动刷新\n- 优化各种资源（css，js，fonts，images），让其用于生产环境。\n\n### 安装gulp\n\n首先在安装gulp前，你必须安装了node.js。安装好了node的话，你就可以打开命令行，输入下面的命令来安装gulp：\n\n```\nnpm install gulp -g\n\n```\n\n### 建立项目目录\n\n新建一个文件夹，我取名叫`project`，在该目录运行`npm install`来为项目进行初始化建立一个`package.json`，该文件记录了文件所需的依赖，\n\n```\nnpm init\n\n```\n\n一路回车下来结束就可以看到package.json这个文件从天而降了。于是乎，就可以开始安装gulp了。\n\n```\nnpm install gulp --save-dev\n\n```\n\n`--save-dev`是用于把gulp作为开发需要的依赖模块记录在package.json中。安装完了之后，就可以看到项目目录中又有一个叫`node_modules`的文件从天而降。里面存储了gulp模块。\n\n对于不同的项目，可能有不同的项目目录。不过开发者应该根据自己项目的情况和需求来建立自己的项目结构。对于本次项目，采用的是以下的目录结构：\n[![img](http://ww2.sinaimg.cn/large/63739cabjw1f6k4hxza1aj20d209fmxt.jpg)](http://ww2.sinaimg.cn/large/63739cabjw1f6k4hxza1aj20d209fmxt.jpg)\n其中`app`目录用于开发目的，保存我们开发书写的所有代码和文件，`dist`目录用于保存用于生产环境的经过优化的资源。\n\n### 开始配置gulp来完成我们的第一个任务\n\n打开新建的gulpfile.js文件，第一步就是引入gulp模块\n\n```\nvar gulp = require('gulp');\n\n```\n\n然后就可以开始写第一个gulp任务，gulp之所以使用简单就是api的方法不多，官方的api就只列出了5个方法。现在我们即将使用的就是`gulp.task()`这个接口。这个方法的使用方法如下：\n\n```\ngulp.task('task-name', function() {\n      // Stuff here\n    });\n\n```\n\n`task-name`是任务的名字，你可以在文件中进行二次使用，也可以通过在命令行输入 `gulp task-name`来运行这个任务。\n为了来体验gulp最基本的一个运作，我们来建立一个hello world任务吧。\n\n```\ngulp.task('hello', function() {\n      console.log('hello world');\n    });、\n\n```\n\n保存文件后在命令行运行`gulp hello`，如无意外你会看到命令行输出`hello world`\n\n当然，gulp task通常会比这个复杂一点，比如你为了完成一个任务，可能会用到多个gulp插件，通常一个真正的gulp task看起来会是这样的：\n\n```\ngulp.task('task-name', function () {\n  return gulp.src('source-files') // Get source files with gulp.src\n.pipe(aGulpPlugin()) // Sends it through a gulp plugin\n.pipe(gulp.dest('destination')) // Outputs the file in the destination folder\n})\n\n```\n\n如你所见，一个实际的gulp task通常还会用到另外两个gulp的方法：`gulp.src`和`gulp.dest`。前者来告诉gulp task要应用在哪些文件上，后者则是告诉gulp要把任务处理的结果输出到哪里。\n\n### 利用gulp来进行css预编译\n\n为了把sass编译成css，我们需要利用一个模块叫`gulp-sass`。所以，先进行模块的安装\n\n```\nnpm install gulp-sass --save-dev\n\n```\n\n并且在文件中引入\nvar sass = require(‘gulp-sass’);\n建立一个叫做`sass`的任务来完成sass编译成css\n\n```\ngulp.task('sass', function(){\n      return gulp.src('source-files')\n        .pipe(sass()) // Using gulp-sass\n     .pipe(gulp.dest('destination'))\n});\n\n```\n\n为了试验一番，我们在`app/sass`目录下建立个sass文件sytles.scss，然后计划把编译得出的css文件放在`app/css`下面。所以修改代码如下：\n\n```\ngulp.task('sass', function(){\n      return gulp.src('app/scss/styles.scss')\n    .pipe(sass()) // Converts Sass to CSS with gulp-sass\n    .pipe(gulp.dest('app/css'))\n    });\n\n```\n\n试着在scss文件写个样式然后在命令行运行`gulp sass`。运行结束，你就可以看到app/css文件下出现了一个编译好的css文件`styles.css`啦~但是，有人会问，如果我需要对多个sass文件一次性进行编译呢？那我们就需要`Node globs`来帮助了\n\n### Globbing in Node\n\nGlobs用来匹配文件s，它类似正则表达式，但是通常用于文件匹配。\n\n多数基于gulp的工作流常常会用到一下四种glob表达式：\n\n1. `*.scss`：匹配当前项目目录下所有以scss为文件后缀的文件。\n2. `**/*.scss`:匹配在当前目录下和任何子目录下的以scss为文件后缀的文件。\n3. `！not-me.scss`：匹配中剔除not-me.scss，\n4. `*.+(scss|sass):`:匹配项目目录下任何以scss或者sass为文件后缀的文件。\n\n了解了这么多后，就可以修改我们上面的代码来达到编译多个sass文件的目的了：\n\n```\ngulp.task('sass', function() {\n      return gulp.src('app/scss/**/*.scss') // Gets all files ending with .scss in app/scss and children dirs\n    .pipe(sass())\n    .pipe(gulp.dest('app/css'))\n})\n\n```\n\n不过，如果我们每次修改了sass文件，都要手动去命令行运行以下gulp sass的话其实也够呛。幸运的是，gulp提供了一个方法来监听文件的变化。\n\n### 监听sass文件的变化\n\ngulp的watch方法可以来帮我们监听文件是否发生了变化。该方法的用法大概如下：\n\n```\n// Gulp watch syntax\ngulp.watch('files-to-watch', ['tasks', 'to', 'run']);\n\n```\n\n为了让gulp在我们对sass文件进行修改了之后自动帮我们进行编译，我们可以写上如下的代码：\n\n```\ngulp.watch('app/scss/**/*.scss', ['sass']); \n\n```\n\n但是，我们往往需要对多个文件进行监听并且做不同的处理，所以，更长远的方法应该是建立一个gulp任务来负责进行监听的工作：\n\n```\ngulp.task('watch', function(){\n  gulp.watch('app/scss/**/*.scss', ['sass']); \n  // Other watchers\n})\n\n```\n\n### 实现浏览器实时更新\n\n开发的过程如果我们修改了样式或者某个文件的代码，浏览器可以自动刷新方便我们观察变化就好了。利用gulp发现这其实小菜一碟。`browser-sync`模块可以帮助我们的项目在本地服务器跑起来，还支持浏览器自动刷新。接下来我们就来试试：\n\n```\nnpm install browser-sync --save-dev\n\n```\n\ngulpfile.js配置文件中进行引入和创建任务：\n\n```\nvar browserSync = require('browser-sync').create();\n...\ngulp.task('browserSync', function() {\n      browserSync.init({\n    server: {\n      baseDir: 'app'\n    },\n  })\n})\n\n```\n\n该任务gulp会为我们在本地运行服务器，为了让browser Sync知道服务器的根目录，在baseDir里面写上我们的app目录。另外，对于我们之前写的sass任务也要做一些修改，这样当每次执行sass任务时，Browser Sync就能将新的css样式在浏览器进行更新。\n\n```\ngulp.task('sass', function() {\n  return gulp.src('app/scss/**/*.scss') // Gets all files ending with .scss in app/scss\n.pipe(sass())\n.pipe(gulp.dest('app/css'))\n.pipe(browserSync.reload({\n  stream: true\n}))\n});\n\n```\n\n让我们打开两个命令行分别来运行browserSync和watch是麻烦的事情，还好，只要给watch任务添加第二个参数就可以让gulp先运行browserSync后立刻运行watch。\n\n```\ngulp.task('watch', ['browserSync'], function (){\n  gulp.watch('app/scss/**/*.scss', ['sass']); \n  // Other watchers\n})\n\n```\n\n我们还要确保sass在watch之前运行，所以再对代码进行下修改：\n\n```\ngulp.task('watch', ['browserSync', 'sass'], function (){\n  gulp.watch('app/scss/**/*.scss', ['sass']); \n  // Other watchers\n});\n\n```\n\n现在，在命令行运行`gulp watch`，试着修改sass，发现样式在浏览器上得到了实时更新。so amazing\n[![img](https://cdn.css-tricks.com/wp-content/uploads/2015/08/bs-change-bg.gif)](https://cdn.css-tricks.com/wp-content/uploads/2015/08/bs-change-bg.gif)\n如果我们希望修改html，js文件也能在浏览器上实时更新呢？加上两条代码就行拉：\n\n```\ngulp.task('watch', ['browserSync', 'sass'], function (){\n      gulp.watch('app/scss/**/*.scss', ['sass']); \n    // Reloads the browser whenever HTML or JS files change\n    gulp.watch('app/*.html', browserSync.reload); \n     gulp.watch('app/js/**/*.js', browserSync.reload); \n});\n\n```\n\n至今我们已经完成了三件事了：\n\n1. 为开发需要跑一个本地服务器\n2. 使用sass预编译\n3. 文件修改保存后浏览器可以实时刷新\n\n下篇文章将会讲述解决如何优化生产环境用的资源，请听下回分解~","source":"_posts/前端工程化-gulp应用篇1.md","raw":"---\ntitle: 前端工程化-gulp应用篇1\ndate: 2016-8-23 23:13:58\ntags: 前端工具\n---\n\n实习了一个星期，给我的工作还是比较简单的。根据设计稿来实现宣传页面。如果时间回退，接手这类工作，也许我会立刻开始切图，然后写html，css和js，并且在改样式的过程，少不了改完代码，为了看看效果，手动刷新页面。这样循环往复，等到大致完成了，再看看代码有什么要优化的，比如去掉无用的代码，顺便在压缩一下图片….终于完成的时候，感叹一声，前端真是个体力活啊！\n\n然而，现在的前端已经今非昔比，为了让前端的工作更加自动化，减少体力活，并且进一步优化，在开始一个项目之前，我们要搭建一个适合自己和这个项目的前端工作流。利用着空余时间，我学习了怎么去搭建这次项目的工作流，最终找到了真命天子gulp。下面我会根据我看到的一篇给[初学者的gulp教程](https://css-tricks.com/gulp-for-beginners/)来讲下如何搭建一个基础的前端工作流（你们把我下面的内容看成对上面的外文的一个简要的翻译版8）\n、\n\n## 正文\n\n> gulp是一个帮助web开发者来完成多个任务的工具，目的在于简化前端工作。\n\n### 为什么选择gulp？\n\ngulp通常被称为“前端构建工具”，流行的前端构建工具除了gulp还有grunt等等。gulp和grunt的目的都是一样的，它们的主要区别在于配置，gulp的配置通常更加简洁和简单，而且运行起来也更加快。现在，让我们来继续看看如何用gulp来搭建一个工作流。\n\n### 此次工作流的目标\n\n- 在本地服务器跑我们的前端项目\n- 将sass编译成css\n- 当修改文件时浏览器可以自动刷新\n- 优化各种资源（css，js，fonts，images），让其用于生产环境。\n\n### 安装gulp\n\n首先在安装gulp前，你必须安装了node.js。安装好了node的话，你就可以打开命令行，输入下面的命令来安装gulp：\n\n```\nnpm install gulp -g\n\n```\n\n### 建立项目目录\n\n新建一个文件夹，我取名叫`project`，在该目录运行`npm install`来为项目进行初始化建立一个`package.json`，该文件记录了文件所需的依赖，\n\n```\nnpm init\n\n```\n\n一路回车下来结束就可以看到package.json这个文件从天而降了。于是乎，就可以开始安装gulp了。\n\n```\nnpm install gulp --save-dev\n\n```\n\n`--save-dev`是用于把gulp作为开发需要的依赖模块记录在package.json中。安装完了之后，就可以看到项目目录中又有一个叫`node_modules`的文件从天而降。里面存储了gulp模块。\n\n对于不同的项目，可能有不同的项目目录。不过开发者应该根据自己项目的情况和需求来建立自己的项目结构。对于本次项目，采用的是以下的目录结构：\n[![img](http://ww2.sinaimg.cn/large/63739cabjw1f6k4hxza1aj20d209fmxt.jpg)](http://ww2.sinaimg.cn/large/63739cabjw1f6k4hxza1aj20d209fmxt.jpg)\n其中`app`目录用于开发目的，保存我们开发书写的所有代码和文件，`dist`目录用于保存用于生产环境的经过优化的资源。\n\n### 开始配置gulp来完成我们的第一个任务\n\n打开新建的gulpfile.js文件，第一步就是引入gulp模块\n\n```\nvar gulp = require('gulp');\n\n```\n\n然后就可以开始写第一个gulp任务，gulp之所以使用简单就是api的方法不多，官方的api就只列出了5个方法。现在我们即将使用的就是`gulp.task()`这个接口。这个方法的使用方法如下：\n\n```\ngulp.task('task-name', function() {\n      // Stuff here\n    });\n\n```\n\n`task-name`是任务的名字，你可以在文件中进行二次使用，也可以通过在命令行输入 `gulp task-name`来运行这个任务。\n为了来体验gulp最基本的一个运作，我们来建立一个hello world任务吧。\n\n```\ngulp.task('hello', function() {\n      console.log('hello world');\n    });、\n\n```\n\n保存文件后在命令行运行`gulp hello`，如无意外你会看到命令行输出`hello world`\n\n当然，gulp task通常会比这个复杂一点，比如你为了完成一个任务，可能会用到多个gulp插件，通常一个真正的gulp task看起来会是这样的：\n\n```\ngulp.task('task-name', function () {\n  return gulp.src('source-files') // Get source files with gulp.src\n.pipe(aGulpPlugin()) // Sends it through a gulp plugin\n.pipe(gulp.dest('destination')) // Outputs the file in the destination folder\n})\n\n```\n\n如你所见，一个实际的gulp task通常还会用到另外两个gulp的方法：`gulp.src`和`gulp.dest`。前者来告诉gulp task要应用在哪些文件上，后者则是告诉gulp要把任务处理的结果输出到哪里。\n\n### 利用gulp来进行css预编译\n\n为了把sass编译成css，我们需要利用一个模块叫`gulp-sass`。所以，先进行模块的安装\n\n```\nnpm install gulp-sass --save-dev\n\n```\n\n并且在文件中引入\nvar sass = require(‘gulp-sass’);\n建立一个叫做`sass`的任务来完成sass编译成css\n\n```\ngulp.task('sass', function(){\n      return gulp.src('source-files')\n        .pipe(sass()) // Using gulp-sass\n     .pipe(gulp.dest('destination'))\n});\n\n```\n\n为了试验一番，我们在`app/sass`目录下建立个sass文件sytles.scss，然后计划把编译得出的css文件放在`app/css`下面。所以修改代码如下：\n\n```\ngulp.task('sass', function(){\n      return gulp.src('app/scss/styles.scss')\n    .pipe(sass()) // Converts Sass to CSS with gulp-sass\n    .pipe(gulp.dest('app/css'))\n    });\n\n```\n\n试着在scss文件写个样式然后在命令行运行`gulp sass`。运行结束，你就可以看到app/css文件下出现了一个编译好的css文件`styles.css`啦~但是，有人会问，如果我需要对多个sass文件一次性进行编译呢？那我们就需要`Node globs`来帮助了\n\n### Globbing in Node\n\nGlobs用来匹配文件s，它类似正则表达式，但是通常用于文件匹配。\n\n多数基于gulp的工作流常常会用到一下四种glob表达式：\n\n1. `*.scss`：匹配当前项目目录下所有以scss为文件后缀的文件。\n2. `**/*.scss`:匹配在当前目录下和任何子目录下的以scss为文件后缀的文件。\n3. `！not-me.scss`：匹配中剔除not-me.scss，\n4. `*.+(scss|sass):`:匹配项目目录下任何以scss或者sass为文件后缀的文件。\n\n了解了这么多后，就可以修改我们上面的代码来达到编译多个sass文件的目的了：\n\n```\ngulp.task('sass', function() {\n      return gulp.src('app/scss/**/*.scss') // Gets all files ending with .scss in app/scss and children dirs\n    .pipe(sass())\n    .pipe(gulp.dest('app/css'))\n})\n\n```\n\n不过，如果我们每次修改了sass文件，都要手动去命令行运行以下gulp sass的话其实也够呛。幸运的是，gulp提供了一个方法来监听文件的变化。\n\n### 监听sass文件的变化\n\ngulp的watch方法可以来帮我们监听文件是否发生了变化。该方法的用法大概如下：\n\n```\n// Gulp watch syntax\ngulp.watch('files-to-watch', ['tasks', 'to', 'run']);\n\n```\n\n为了让gulp在我们对sass文件进行修改了之后自动帮我们进行编译，我们可以写上如下的代码：\n\n```\ngulp.watch('app/scss/**/*.scss', ['sass']); \n\n```\n\n但是，我们往往需要对多个文件进行监听并且做不同的处理，所以，更长远的方法应该是建立一个gulp任务来负责进行监听的工作：\n\n```\ngulp.task('watch', function(){\n  gulp.watch('app/scss/**/*.scss', ['sass']); \n  // Other watchers\n})\n\n```\n\n### 实现浏览器实时更新\n\n开发的过程如果我们修改了样式或者某个文件的代码，浏览器可以自动刷新方便我们观察变化就好了。利用gulp发现这其实小菜一碟。`browser-sync`模块可以帮助我们的项目在本地服务器跑起来，还支持浏览器自动刷新。接下来我们就来试试：\n\n```\nnpm install browser-sync --save-dev\n\n```\n\ngulpfile.js配置文件中进行引入和创建任务：\n\n```\nvar browserSync = require('browser-sync').create();\n...\ngulp.task('browserSync', function() {\n      browserSync.init({\n    server: {\n      baseDir: 'app'\n    },\n  })\n})\n\n```\n\n该任务gulp会为我们在本地运行服务器，为了让browser Sync知道服务器的根目录，在baseDir里面写上我们的app目录。另外，对于我们之前写的sass任务也要做一些修改，这样当每次执行sass任务时，Browser Sync就能将新的css样式在浏览器进行更新。\n\n```\ngulp.task('sass', function() {\n  return gulp.src('app/scss/**/*.scss') // Gets all files ending with .scss in app/scss\n.pipe(sass())\n.pipe(gulp.dest('app/css'))\n.pipe(browserSync.reload({\n  stream: true\n}))\n});\n\n```\n\n让我们打开两个命令行分别来运行browserSync和watch是麻烦的事情，还好，只要给watch任务添加第二个参数就可以让gulp先运行browserSync后立刻运行watch。\n\n```\ngulp.task('watch', ['browserSync'], function (){\n  gulp.watch('app/scss/**/*.scss', ['sass']); \n  // Other watchers\n})\n\n```\n\n我们还要确保sass在watch之前运行，所以再对代码进行下修改：\n\n```\ngulp.task('watch', ['browserSync', 'sass'], function (){\n  gulp.watch('app/scss/**/*.scss', ['sass']); \n  // Other watchers\n});\n\n```\n\n现在，在命令行运行`gulp watch`，试着修改sass，发现样式在浏览器上得到了实时更新。so amazing\n[![img](https://cdn.css-tricks.com/wp-content/uploads/2015/08/bs-change-bg.gif)](https://cdn.css-tricks.com/wp-content/uploads/2015/08/bs-change-bg.gif)\n如果我们希望修改html，js文件也能在浏览器上实时更新呢？加上两条代码就行拉：\n\n```\ngulp.task('watch', ['browserSync', 'sass'], function (){\n      gulp.watch('app/scss/**/*.scss', ['sass']); \n    // Reloads the browser whenever HTML or JS files change\n    gulp.watch('app/*.html', browserSync.reload); \n     gulp.watch('app/js/**/*.js', browserSync.reload); \n});\n\n```\n\n至今我们已经完成了三件事了：\n\n1. 为开发需要跑一个本地服务器\n2. 使用sass预编译\n3. 文件修改保存后浏览器可以实时刷新\n\n下篇文章将会讲述解决如何优化生产环境用的资源，请听下回分解~","slug":"前端工程化-gulp应用篇1","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwn1000hcges6redobeg","content":"<p>实习了一个星期，给我的工作还是比较简单的。根据设计稿来实现宣传页面。如果时间回退，接手这类工作，也许我会立刻开始切图，然后写html，css和js，并且在改样式的过程，少不了改完代码，为了看看效果，手动刷新页面。这样循环往复，等到大致完成了，再看看代码有什么要优化的，比如去掉无用的代码，顺便在压缩一下图片….终于完成的时候，感叹一声，前端真是个体力活啊！</p>\n<p>然而，现在的前端已经今非昔比，为了让前端的工作更加自动化，减少体力活，并且进一步优化，在开始一个项目之前，我们要搭建一个适合自己和这个项目的前端工作流。利用着空余时间，我学习了怎么去搭建这次项目的工作流，最终找到了真命天子gulp。下面我会根据我看到的一篇给<a href=\"https://css-tricks.com/gulp-for-beginners/\" target=\"_blank\" rel=\"external\">初学者的gulp教程</a>来讲下如何搭建一个基础的前端工作流（你们把我下面的内容看成对上面的外文的一个简要的翻译版8）<br>、</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><blockquote>\n<p>gulp是一个帮助web开发者来完成多个任务的工具，目的在于简化前端工作。</p>\n</blockquote>\n<h3 id=\"为什么选择gulp？\"><a href=\"#为什么选择gulp？\" class=\"headerlink\" title=\"为什么选择gulp？\"></a>为什么选择gulp？</h3><p>gulp通常被称为“前端构建工具”，流行的前端构建工具除了gulp还有grunt等等。gulp和grunt的目的都是一样的，它们的主要区别在于配置，gulp的配置通常更加简洁和简单，而且运行起来也更加快。现在，让我们来继续看看如何用gulp来搭建一个工作流。</p>\n<h3 id=\"此次工作流的目标\"><a href=\"#此次工作流的目标\" class=\"headerlink\" title=\"此次工作流的目标\"></a>此次工作流的目标</h3><ul>\n<li>在本地服务器跑我们的前端项目</li>\n<li>将sass编译成css</li>\n<li>当修改文件时浏览器可以自动刷新</li>\n<li>优化各种资源（css，js，fonts，images），让其用于生产环境。</li>\n</ul>\n<h3 id=\"安装gulp\"><a href=\"#安装gulp\" class=\"headerlink\" title=\"安装gulp\"></a>安装gulp</h3><p>首先在安装gulp前，你必须安装了node.js。安装好了node的话，你就可以打开命令行，输入下面的命令来安装gulp：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install gulp -g</div></pre></td></tr></table></figure>\n<h3 id=\"建立项目目录\"><a href=\"#建立项目目录\" class=\"headerlink\" title=\"建立项目目录\"></a>建立项目目录</h3><p>新建一个文件夹，我取名叫<code>project</code>，在该目录运行<code>npm install</code>来为项目进行初始化建立一个<code>package.json</code>，该文件记录了文件所需的依赖，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm init</div></pre></td></tr></table></figure>\n<p>一路回车下来结束就可以看到package.json这个文件从天而降了。于是乎，就可以开始安装gulp了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install gulp --save-dev</div></pre></td></tr></table></figure>\n<p><code>--save-dev</code>是用于把gulp作为开发需要的依赖模块记录在package.json中。安装完了之后，就可以看到项目目录中又有一个叫<code>node_modules</code>的文件从天而降。里面存储了gulp模块。</p>\n<p>对于不同的项目，可能有不同的项目目录。不过开发者应该根据自己项目的情况和需求来建立自己的项目结构。对于本次项目，采用的是以下的目录结构：<br><a href=\"http://ww2.sinaimg.cn/large/63739cabjw1f6k4hxza1aj20d209fmxt.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww2.sinaimg.cn/large/63739cabjw1f6k4hxza1aj20d209fmxt.jpg\" alt=\"img\"></a><br>其中<code>app</code>目录用于开发目的，保存我们开发书写的所有代码和文件，<code>dist</code>目录用于保存用于生产环境的经过优化的资源。</p>\n<h3 id=\"开始配置gulp来完成我们的第一个任务\"><a href=\"#开始配置gulp来完成我们的第一个任务\" class=\"headerlink\" title=\"开始配置gulp来完成我们的第一个任务\"></a>开始配置gulp来完成我们的第一个任务</h3><p>打开新建的gulpfile.js文件，第一步就是引入gulp模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var gulp = require(&apos;gulp&apos;);</div></pre></td></tr></table></figure>\n<p>然后就可以开始写第一个gulp任务，gulp之所以使用简单就是api的方法不多，官方的api就只列出了5个方法。现在我们即将使用的就是<code>gulp.task()</code>这个接口。这个方法的使用方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;task-name&apos;, function() &#123;</div><div class=\"line\">      // Stuff here</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p><code>task-name</code>是任务的名字，你可以在文件中进行二次使用，也可以通过在命令行输入 <code>gulp task-name</code>来运行这个任务。<br>为了来体验gulp最基本的一个运作，我们来建立一个hello world任务吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;hello&apos;, function() &#123;</div><div class=\"line\">      console.log(&apos;hello world&apos;);</div><div class=\"line\">    &#125;);、</div></pre></td></tr></table></figure>\n<p>保存文件后在命令行运行<code>gulp hello</code>，如无意外你会看到命令行输出<code>hello world</code></p>\n<p>当然，gulp task通常会比这个复杂一点，比如你为了完成一个任务，可能会用到多个gulp插件，通常一个真正的gulp task看起来会是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;task-name&apos;, function () &#123;</div><div class=\"line\">  return gulp.src(&apos;source-files&apos;) // Get source files with gulp.src</div><div class=\"line\">.pipe(aGulpPlugin()) // Sends it through a gulp plugin</div><div class=\"line\">.pipe(gulp.dest(&apos;destination&apos;)) // Outputs the file in the destination folder</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>如你所见，一个实际的gulp task通常还会用到另外两个gulp的方法：<code>gulp.src</code>和<code>gulp.dest</code>。前者来告诉gulp task要应用在哪些文件上，后者则是告诉gulp要把任务处理的结果输出到哪里。</p>\n<h3 id=\"利用gulp来进行css预编译\"><a href=\"#利用gulp来进行css预编译\" class=\"headerlink\" title=\"利用gulp来进行css预编译\"></a>利用gulp来进行css预编译</h3><p>为了把sass编译成css，我们需要利用一个模块叫<code>gulp-sass</code>。所以，先进行模块的安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install gulp-sass --save-dev</div></pre></td></tr></table></figure>\n<p>并且在文件中引入<br>var sass = require(‘gulp-sass’);<br>建立一个叫做<code>sass</code>的任务来完成sass编译成css</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;sass&apos;, function()&#123;</div><div class=\"line\">      return gulp.src(&apos;source-files&apos;)</div><div class=\"line\">        .pipe(sass()) // Using gulp-sass</div><div class=\"line\">     .pipe(gulp.dest(&apos;destination&apos;))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>为了试验一番，我们在<code>app/sass</code>目录下建立个sass文件sytles.scss，然后计划把编译得出的css文件放在<code>app/css</code>下面。所以修改代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;sass&apos;, function()&#123;</div><div class=\"line\">      return gulp.src(&apos;app/scss/styles.scss&apos;)</div><div class=\"line\">    .pipe(sass()) // Converts Sass to CSS with gulp-sass</div><div class=\"line\">    .pipe(gulp.dest(&apos;app/css&apos;))</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>试着在scss文件写个样式然后在命令行运行<code>gulp sass</code>。运行结束，你就可以看到app/css文件下出现了一个编译好的css文件<code>styles.css</code>啦~但是，有人会问，如果我需要对多个sass文件一次性进行编译呢？那我们就需要<code>Node globs</code>来帮助了</p>\n<h3 id=\"Globbing-in-Node\"><a href=\"#Globbing-in-Node\" class=\"headerlink\" title=\"Globbing in Node\"></a>Globbing in Node</h3><p>Globs用来匹配文件s，它类似正则表达式，但是通常用于文件匹配。</p>\n<p>多数基于gulp的工作流常常会用到一下四种glob表达式：</p>\n<ol>\n<li><code>*.scss</code>：匹配当前项目目录下所有以scss为文件后缀的文件。</li>\n<li><code>**/*.scss</code>:匹配在当前目录下和任何子目录下的以scss为文件后缀的文件。</li>\n<li><code>！not-me.scss</code>：匹配中剔除not-me.scss，</li>\n<li><code>*.+(scss|sass):</code>:匹配项目目录下任何以scss或者sass为文件后缀的文件。</li>\n</ol>\n<p>了解了这么多后，就可以修改我们上面的代码来达到编译多个sass文件的目的了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;sass&apos;, function() &#123;</div><div class=\"line\">      return gulp.src(&apos;app/scss/**/*.scss&apos;) // Gets all files ending with .scss in app/scss and children dirs</div><div class=\"line\">    .pipe(sass())</div><div class=\"line\">    .pipe(gulp.dest(&apos;app/css&apos;))</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>不过，如果我们每次修改了sass文件，都要手动去命令行运行以下gulp sass的话其实也够呛。幸运的是，gulp提供了一个方法来监听文件的变化。</p>\n<h3 id=\"监听sass文件的变化\"><a href=\"#监听sass文件的变化\" class=\"headerlink\" title=\"监听sass文件的变化\"></a>监听sass文件的变化</h3><p>gulp的watch方法可以来帮我们监听文件是否发生了变化。该方法的用法大概如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Gulp watch syntax</div><div class=\"line\">gulp.watch(&apos;files-to-watch&apos;, [&apos;tasks&apos;, &apos;to&apos;, &apos;run&apos;]);</div></pre></td></tr></table></figure>\n<p>为了让gulp在我们对sass文件进行修改了之后自动帮我们进行编译，我们可以写上如下的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]);</div></pre></td></tr></table></figure>\n<p>但是，我们往往需要对多个文件进行监听并且做不同的处理，所以，更长远的方法应该是建立一个gulp任务来负责进行监听的工作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;watch&apos;, function()&#123;</div><div class=\"line\">  gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]); </div><div class=\"line\">  // Other watchers</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"实现浏览器实时更新\"><a href=\"#实现浏览器实时更新\" class=\"headerlink\" title=\"实现浏览器实时更新\"></a>实现浏览器实时更新</h3><p>开发的过程如果我们修改了样式或者某个文件的代码，浏览器可以自动刷新方便我们观察变化就好了。利用gulp发现这其实小菜一碟。<code>browser-sync</code>模块可以帮助我们的项目在本地服务器跑起来，还支持浏览器自动刷新。接下来我们就来试试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install browser-sync --save-dev</div></pre></td></tr></table></figure>\n<p>gulpfile.js配置文件中进行引入和创建任务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var browserSync = require(&apos;browser-sync&apos;).create();</div><div class=\"line\">...</div><div class=\"line\">gulp.task(&apos;browserSync&apos;, function() &#123;</div><div class=\"line\">      browserSync.init(&#123;</div><div class=\"line\">    server: &#123;</div><div class=\"line\">      baseDir: &apos;app&apos;</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>该任务gulp会为我们在本地运行服务器，为了让browser Sync知道服务器的根目录，在baseDir里面写上我们的app目录。另外，对于我们之前写的sass任务也要做一些修改，这样当每次执行sass任务时，Browser Sync就能将新的css样式在浏览器进行更新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;sass&apos;, function() &#123;</div><div class=\"line\">  return gulp.src(&apos;app/scss/**/*.scss&apos;) // Gets all files ending with .scss in app/scss</div><div class=\"line\">.pipe(sass())</div><div class=\"line\">.pipe(gulp.dest(&apos;app/css&apos;))</div><div class=\"line\">.pipe(browserSync.reload(&#123;</div><div class=\"line\">  stream: true</div><div class=\"line\">&#125;))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>让我们打开两个命令行分别来运行browserSync和watch是麻烦的事情，还好，只要给watch任务添加第二个参数就可以让gulp先运行browserSync后立刻运行watch。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;watch&apos;, [&apos;browserSync&apos;], function ()&#123;</div><div class=\"line\">  gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]); </div><div class=\"line\">  // Other watchers</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们还要确保sass在watch之前运行，所以再对代码进行下修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;watch&apos;, [&apos;browserSync&apos;, &apos;sass&apos;], function ()&#123;</div><div class=\"line\">  gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]); </div><div class=\"line\">  // Other watchers</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>现在，在命令行运行<code>gulp watch</code>，试着修改sass，发现样式在浏览器上得到了实时更新。so amazing<br><a href=\"https://cdn.css-tricks.com/wp-content/uploads/2015/08/bs-change-bg.gif\" target=\"_blank\" rel=\"external\"><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2015/08/bs-change-bg.gif\" alt=\"img\"></a><br>如果我们希望修改html，js文件也能在浏览器上实时更新呢？加上两条代码就行拉：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;watch&apos;, [&apos;browserSync&apos;, &apos;sass&apos;], function ()&#123;</div><div class=\"line\">      gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]); </div><div class=\"line\">    // Reloads the browser whenever HTML or JS files change</div><div class=\"line\">    gulp.watch(&apos;app/*.html&apos;, browserSync.reload); </div><div class=\"line\">     gulp.watch(&apos;app/js/**/*.js&apos;, browserSync.reload); </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>至今我们已经完成了三件事了：</p>\n<ol>\n<li>为开发需要跑一个本地服务器</li>\n<li>使用sass预编译</li>\n<li>文件修改保存后浏览器可以实时刷新</li>\n</ol>\n<p>下篇文章将会讲述解决如何优化生产环境用的资源，请听下回分解~</p>\n","site":{"data":{}},"excerpt":"","more":"<p>实习了一个星期，给我的工作还是比较简单的。根据设计稿来实现宣传页面。如果时间回退，接手这类工作，也许我会立刻开始切图，然后写html，css和js，并且在改样式的过程，少不了改完代码，为了看看效果，手动刷新页面。这样循环往复，等到大致完成了，再看看代码有什么要优化的，比如去掉无用的代码，顺便在压缩一下图片….终于完成的时候，感叹一声，前端真是个体力活啊！</p>\n<p>然而，现在的前端已经今非昔比，为了让前端的工作更加自动化，减少体力活，并且进一步优化，在开始一个项目之前，我们要搭建一个适合自己和这个项目的前端工作流。利用着空余时间，我学习了怎么去搭建这次项目的工作流，最终找到了真命天子gulp。下面我会根据我看到的一篇给<a href=\"https://css-tricks.com/gulp-for-beginners/\" target=\"_blank\" rel=\"external\">初学者的gulp教程</a>来讲下如何搭建一个基础的前端工作流（你们把我下面的内容看成对上面的外文的一个简要的翻译版8）<br>、</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><blockquote>\n<p>gulp是一个帮助web开发者来完成多个任务的工具，目的在于简化前端工作。</p>\n</blockquote>\n<h3 id=\"为什么选择gulp？\"><a href=\"#为什么选择gulp？\" class=\"headerlink\" title=\"为什么选择gulp？\"></a>为什么选择gulp？</h3><p>gulp通常被称为“前端构建工具”，流行的前端构建工具除了gulp还有grunt等等。gulp和grunt的目的都是一样的，它们的主要区别在于配置，gulp的配置通常更加简洁和简单，而且运行起来也更加快。现在，让我们来继续看看如何用gulp来搭建一个工作流。</p>\n<h3 id=\"此次工作流的目标\"><a href=\"#此次工作流的目标\" class=\"headerlink\" title=\"此次工作流的目标\"></a>此次工作流的目标</h3><ul>\n<li>在本地服务器跑我们的前端项目</li>\n<li>将sass编译成css</li>\n<li>当修改文件时浏览器可以自动刷新</li>\n<li>优化各种资源（css，js，fonts，images），让其用于生产环境。</li>\n</ul>\n<h3 id=\"安装gulp\"><a href=\"#安装gulp\" class=\"headerlink\" title=\"安装gulp\"></a>安装gulp</h3><p>首先在安装gulp前，你必须安装了node.js。安装好了node的话，你就可以打开命令行，输入下面的命令来安装gulp：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install gulp -g</div></pre></td></tr></table></figure>\n<h3 id=\"建立项目目录\"><a href=\"#建立项目目录\" class=\"headerlink\" title=\"建立项目目录\"></a>建立项目目录</h3><p>新建一个文件夹，我取名叫<code>project</code>，在该目录运行<code>npm install</code>来为项目进行初始化建立一个<code>package.json</code>，该文件记录了文件所需的依赖，</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm init</div></pre></td></tr></table></figure>\n<p>一路回车下来结束就可以看到package.json这个文件从天而降了。于是乎，就可以开始安装gulp了。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install gulp --save-dev</div></pre></td></tr></table></figure>\n<p><code>--save-dev</code>是用于把gulp作为开发需要的依赖模块记录在package.json中。安装完了之后，就可以看到项目目录中又有一个叫<code>node_modules</code>的文件从天而降。里面存储了gulp模块。</p>\n<p>对于不同的项目，可能有不同的项目目录。不过开发者应该根据自己项目的情况和需求来建立自己的项目结构。对于本次项目，采用的是以下的目录结构：<br><a href=\"http://ww2.sinaimg.cn/large/63739cabjw1f6k4hxza1aj20d209fmxt.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww2.sinaimg.cn/large/63739cabjw1f6k4hxza1aj20d209fmxt.jpg\" alt=\"img\"></a><br>其中<code>app</code>目录用于开发目的，保存我们开发书写的所有代码和文件，<code>dist</code>目录用于保存用于生产环境的经过优化的资源。</p>\n<h3 id=\"开始配置gulp来完成我们的第一个任务\"><a href=\"#开始配置gulp来完成我们的第一个任务\" class=\"headerlink\" title=\"开始配置gulp来完成我们的第一个任务\"></a>开始配置gulp来完成我们的第一个任务</h3><p>打开新建的gulpfile.js文件，第一步就是引入gulp模块</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">var gulp = require(&apos;gulp&apos;);</div></pre></td></tr></table></figure>\n<p>然后就可以开始写第一个gulp任务，gulp之所以使用简单就是api的方法不多，官方的api就只列出了5个方法。现在我们即将使用的就是<code>gulp.task()</code>这个接口。这个方法的使用方法如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;task-name&apos;, function() &#123;</div><div class=\"line\">      // Stuff here</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p><code>task-name</code>是任务的名字，你可以在文件中进行二次使用，也可以通过在命令行输入 <code>gulp task-name</code>来运行这个任务。<br>为了来体验gulp最基本的一个运作，我们来建立一个hello world任务吧。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;hello&apos;, function() &#123;</div><div class=\"line\">      console.log(&apos;hello world&apos;);</div><div class=\"line\">    &#125;);、</div></pre></td></tr></table></figure>\n<p>保存文件后在命令行运行<code>gulp hello</code>，如无意外你会看到命令行输出<code>hello world</code></p>\n<p>当然，gulp task通常会比这个复杂一点，比如你为了完成一个任务，可能会用到多个gulp插件，通常一个真正的gulp task看起来会是这样的：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;task-name&apos;, function () &#123;</div><div class=\"line\">  return gulp.src(&apos;source-files&apos;) // Get source files with gulp.src</div><div class=\"line\">.pipe(aGulpPlugin()) // Sends it through a gulp plugin</div><div class=\"line\">.pipe(gulp.dest(&apos;destination&apos;)) // Outputs the file in the destination folder</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>如你所见，一个实际的gulp task通常还会用到另外两个gulp的方法：<code>gulp.src</code>和<code>gulp.dest</code>。前者来告诉gulp task要应用在哪些文件上，后者则是告诉gulp要把任务处理的结果输出到哪里。</p>\n<h3 id=\"利用gulp来进行css预编译\"><a href=\"#利用gulp来进行css预编译\" class=\"headerlink\" title=\"利用gulp来进行css预编译\"></a>利用gulp来进行css预编译</h3><p>为了把sass编译成css，我们需要利用一个模块叫<code>gulp-sass</code>。所以，先进行模块的安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install gulp-sass --save-dev</div></pre></td></tr></table></figure>\n<p>并且在文件中引入<br>var sass = require(‘gulp-sass’);<br>建立一个叫做<code>sass</code>的任务来完成sass编译成css</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;sass&apos;, function()&#123;</div><div class=\"line\">      return gulp.src(&apos;source-files&apos;)</div><div class=\"line\">        .pipe(sass()) // Using gulp-sass</div><div class=\"line\">     .pipe(gulp.dest(&apos;destination&apos;))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>为了试验一番，我们在<code>app/sass</code>目录下建立个sass文件sytles.scss，然后计划把编译得出的css文件放在<code>app/css</code>下面。所以修改代码如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;sass&apos;, function()&#123;</div><div class=\"line\">      return gulp.src(&apos;app/scss/styles.scss&apos;)</div><div class=\"line\">    .pipe(sass()) // Converts Sass to CSS with gulp-sass</div><div class=\"line\">    .pipe(gulp.dest(&apos;app/css&apos;))</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>试着在scss文件写个样式然后在命令行运行<code>gulp sass</code>。运行结束，你就可以看到app/css文件下出现了一个编译好的css文件<code>styles.css</code>啦~但是，有人会问，如果我需要对多个sass文件一次性进行编译呢？那我们就需要<code>Node globs</code>来帮助了</p>\n<h3 id=\"Globbing-in-Node\"><a href=\"#Globbing-in-Node\" class=\"headerlink\" title=\"Globbing in Node\"></a>Globbing in Node</h3><p>Globs用来匹配文件s，它类似正则表达式，但是通常用于文件匹配。</p>\n<p>多数基于gulp的工作流常常会用到一下四种glob表达式：</p>\n<ol>\n<li><code>*.scss</code>：匹配当前项目目录下所有以scss为文件后缀的文件。</li>\n<li><code>**/*.scss</code>:匹配在当前目录下和任何子目录下的以scss为文件后缀的文件。</li>\n<li><code>！not-me.scss</code>：匹配中剔除not-me.scss，</li>\n<li><code>*.+(scss|sass):</code>:匹配项目目录下任何以scss或者sass为文件后缀的文件。</li>\n</ol>\n<p>了解了这么多后，就可以修改我们上面的代码来达到编译多个sass文件的目的了：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;sass&apos;, function() &#123;</div><div class=\"line\">      return gulp.src(&apos;app/scss/**/*.scss&apos;) // Gets all files ending with .scss in app/scss and children dirs</div><div class=\"line\">    .pipe(sass())</div><div class=\"line\">    .pipe(gulp.dest(&apos;app/css&apos;))</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>不过，如果我们每次修改了sass文件，都要手动去命令行运行以下gulp sass的话其实也够呛。幸运的是，gulp提供了一个方法来监听文件的变化。</p>\n<h3 id=\"监听sass文件的变化\"><a href=\"#监听sass文件的变化\" class=\"headerlink\" title=\"监听sass文件的变化\"></a>监听sass文件的变化</h3><p>gulp的watch方法可以来帮我们监听文件是否发生了变化。该方法的用法大概如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Gulp watch syntax</div><div class=\"line\">gulp.watch(&apos;files-to-watch&apos;, [&apos;tasks&apos;, &apos;to&apos;, &apos;run&apos;]);</div></pre></td></tr></table></figure>\n<p>为了让gulp在我们对sass文件进行修改了之后自动帮我们进行编译，我们可以写上如下的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]);</div></pre></td></tr></table></figure>\n<p>但是，我们往往需要对多个文件进行监听并且做不同的处理，所以，更长远的方法应该是建立一个gulp任务来负责进行监听的工作：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;watch&apos;, function()&#123;</div><div class=\"line\">  gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]); </div><div class=\"line\">  // Other watchers</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"实现浏览器实时更新\"><a href=\"#实现浏览器实时更新\" class=\"headerlink\" title=\"实现浏览器实时更新\"></a>实现浏览器实时更新</h3><p>开发的过程如果我们修改了样式或者某个文件的代码，浏览器可以自动刷新方便我们观察变化就好了。利用gulp发现这其实小菜一碟。<code>browser-sync</code>模块可以帮助我们的项目在本地服务器跑起来，还支持浏览器自动刷新。接下来我们就来试试：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install browser-sync --save-dev</div></pre></td></tr></table></figure>\n<p>gulpfile.js配置文件中进行引入和创建任务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">var browserSync = require(&apos;browser-sync&apos;).create();</div><div class=\"line\">...</div><div class=\"line\">gulp.task(&apos;browserSync&apos;, function() &#123;</div><div class=\"line\">      browserSync.init(&#123;</div><div class=\"line\">    server: &#123;</div><div class=\"line\">      baseDir: &apos;app&apos;</div><div class=\"line\">    &#125;,</div><div class=\"line\">  &#125;)</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>该任务gulp会为我们在本地运行服务器，为了让browser Sync知道服务器的根目录，在baseDir里面写上我们的app目录。另外，对于我们之前写的sass任务也要做一些修改，这样当每次执行sass任务时，Browser Sync就能将新的css样式在浏览器进行更新。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;sass&apos;, function() &#123;</div><div class=\"line\">  return gulp.src(&apos;app/scss/**/*.scss&apos;) // Gets all files ending with .scss in app/scss</div><div class=\"line\">.pipe(sass())</div><div class=\"line\">.pipe(gulp.dest(&apos;app/css&apos;))</div><div class=\"line\">.pipe(browserSync.reload(&#123;</div><div class=\"line\">  stream: true</div><div class=\"line\">&#125;))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>让我们打开两个命令行分别来运行browserSync和watch是麻烦的事情，还好，只要给watch任务添加第二个参数就可以让gulp先运行browserSync后立刻运行watch。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;watch&apos;, [&apos;browserSync&apos;], function ()&#123;</div><div class=\"line\">  gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]); </div><div class=\"line\">  // Other watchers</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>我们还要确保sass在watch之前运行，所以再对代码进行下修改：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;watch&apos;, [&apos;browserSync&apos;, &apos;sass&apos;], function ()&#123;</div><div class=\"line\">  gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]); </div><div class=\"line\">  // Other watchers</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>现在，在命令行运行<code>gulp watch</code>，试着修改sass，发现样式在浏览器上得到了实时更新。so amazing<br><a href=\"https://cdn.css-tricks.com/wp-content/uploads/2015/08/bs-change-bg.gif\" target=\"_blank\" rel=\"external\"><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2015/08/bs-change-bg.gif\" alt=\"img\"></a><br>如果我们希望修改html，js文件也能在浏览器上实时更新呢？加上两条代码就行拉：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;watch&apos;, [&apos;browserSync&apos;, &apos;sass&apos;], function ()&#123;</div><div class=\"line\">      gulp.watch(&apos;app/scss/**/*.scss&apos;, [&apos;sass&apos;]); </div><div class=\"line\">    // Reloads the browser whenever HTML or JS files change</div><div class=\"line\">    gulp.watch(&apos;app/*.html&apos;, browserSync.reload); </div><div class=\"line\">     gulp.watch(&apos;app/js/**/*.js&apos;, browserSync.reload); </div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>至今我们已经完成了三件事了：</p>\n<ol>\n<li>为开发需要跑一个本地服务器</li>\n<li>使用sass预编译</li>\n<li>文件修改保存后浏览器可以实时刷新</li>\n</ol>\n<p>下篇文章将会讲述解决如何优化生产环境用的资源，请听下回分解~</p>\n"},{"title":"原来除了box-shadow,还有drop-shadow","date":"2017-06-01T15:13:58.000Z","_content":"\n 上周写样式，UI小哥给我了一张png图，但是要实现阴影。然后，第一想到的就是用box-shadow，然而写好之后才发现图片虽然是一个类圆形的图案，但是在css中它是个盒子，也就是在css中它是个矩形，所以出现的效果的阴影是与图形分离开来的长方形（尴尬）。后来在网上发现了一个drop-shadow的东西可以用来解决这个问题。\n\ndrop-shadow并不是css的一个属性，它属于CSS滤镜中的一种。\n\n##### 使用\n\n`filter: drop-shadow(<offset-x> <offset-y> <?blur-radius> <?spread-radiue> <?color>)`\n\n参数如下：\n\noffset-x ：水平方向的偏移量，负值向左。\n\noffset-y：垂直方向的偏移量，负值向上。\n\nblur-radius：值越大越模糊。\n\nspread-radius：阴影扩张大小。\n\ncolor：阴影颜色。\n\n##### 缺点\n\nCSS标准里虽然已经包含了一些已实现预定义效果的函数，但是如果你需要兼容多个浏览器，包括旧版本IE，那就要慎重啦。因为旧版本（4-9）的IE支持它们自己的，非标准的filter。\n\n##### 资料\n\n[MDN-CSS:filter](https://developer.mozilla.org/en-US/docs/Web/CSS/filter?v=control)\n\n[CSS3 filter:drop-shadow滤镜与box-shadow区别应用](http://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/)","source":"_posts/原来除了box-shadow,还有drop-shadow.md","raw":"---\ntitle: 原来除了box-shadow,还有drop-shadow\ndate: 2017-6-01 23:13:58\ntags: CSS\n---\n\n 上周写样式，UI小哥给我了一张png图，但是要实现阴影。然后，第一想到的就是用box-shadow，然而写好之后才发现图片虽然是一个类圆形的图案，但是在css中它是个盒子，也就是在css中它是个矩形，所以出现的效果的阴影是与图形分离开来的长方形（尴尬）。后来在网上发现了一个drop-shadow的东西可以用来解决这个问题。\n\ndrop-shadow并不是css的一个属性，它属于CSS滤镜中的一种。\n\n##### 使用\n\n`filter: drop-shadow(<offset-x> <offset-y> <?blur-radius> <?spread-radiue> <?color>)`\n\n参数如下：\n\noffset-x ：水平方向的偏移量，负值向左。\n\noffset-y：垂直方向的偏移量，负值向上。\n\nblur-radius：值越大越模糊。\n\nspread-radius：阴影扩张大小。\n\ncolor：阴影颜色。\n\n##### 缺点\n\nCSS标准里虽然已经包含了一些已实现预定义效果的函数，但是如果你需要兼容多个浏览器，包括旧版本IE，那就要慎重啦。因为旧版本（4-9）的IE支持它们自己的，非标准的filter。\n\n##### 资料\n\n[MDN-CSS:filter](https://developer.mozilla.org/en-US/docs/Web/CSS/filter?v=control)\n\n[CSS3 filter:drop-shadow滤镜与box-shadow区别应用](http://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/)","slug":"原来除了box-shadow,还有drop-shadow","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwn3000jcgesovs78shm","content":"<p> 上周写样式，UI小哥给我了一张png图，但是要实现阴影。然后，第一想到的就是用box-shadow，然而写好之后才发现图片虽然是一个类圆形的图案，但是在css中它是个盒子，也就是在css中它是个矩形，所以出现的效果的阴影是与图形分离开来的长方形（尴尬）。后来在网上发现了一个drop-shadow的东西可以用来解决这个问题。</p>\n<p>drop-shadow并不是css的一个属性，它属于CSS滤镜中的一种。</p>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><code>filter: drop-shadow(&lt;offset-x&gt; &lt;offset-y&gt; &lt;?blur-radius&gt; &lt;?spread-radiue&gt; &lt;?color&gt;)</code></p>\n<p>参数如下：</p>\n<p>offset-x ：水平方向的偏移量，负值向左。</p>\n<p>offset-y：垂直方向的偏移量，负值向上。</p>\n<p>blur-radius：值越大越模糊。</p>\n<p>spread-radius：阴影扩张大小。</p>\n<p>color：阴影颜色。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><p>CSS标准里虽然已经包含了一些已实现预定义效果的函数，但是如果你需要兼容多个浏览器，包括旧版本IE，那就要慎重啦。因为旧版本（4-9）的IE支持它们自己的，非标准的filter。</p>\n<h5 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h5><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/filter?v=control\" target=\"_blank\" rel=\"external\">MDN-CSS:filter</a></p>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/\" target=\"_blank\" rel=\"external\">CSS3 filter:drop-shadow滤镜与box-shadow区别应用</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p> 上周写样式，UI小哥给我了一张png图，但是要实现阴影。然后，第一想到的就是用box-shadow，然而写好之后才发现图片虽然是一个类圆形的图案，但是在css中它是个盒子，也就是在css中它是个矩形，所以出现的效果的阴影是与图形分离开来的长方形（尴尬）。后来在网上发现了一个drop-shadow的东西可以用来解决这个问题。</p>\n<p>drop-shadow并不是css的一个属性，它属于CSS滤镜中的一种。</p>\n<h5 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h5><p><code>filter: drop-shadow(&lt;offset-x&gt; &lt;offset-y&gt; &lt;?blur-radius&gt; &lt;?spread-radiue&gt; &lt;?color&gt;)</code></p>\n<p>参数如下：</p>\n<p>offset-x ：水平方向的偏移量，负值向左。</p>\n<p>offset-y：垂直方向的偏移量，负值向上。</p>\n<p>blur-radius：值越大越模糊。</p>\n<p>spread-radius：阴影扩张大小。</p>\n<p>color：阴影颜色。</p>\n<h5 id=\"缺点\"><a href=\"#缺点\" class=\"headerlink\" title=\"缺点\"></a>缺点</h5><p>CSS标准里虽然已经包含了一些已实现预定义效果的函数，但是如果你需要兼容多个浏览器，包括旧版本IE，那就要慎重啦。因为旧版本（4-9）的IE支持它们自己的，非标准的filter。</p>\n<h5 id=\"资料\"><a href=\"#资料\" class=\"headerlink\" title=\"资料\"></a>资料</h5><p><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/filter?v=control\" target=\"_blank\" rel=\"external\">MDN-CSS:filter</a></p>\n<p><a href=\"http://www.zhangxinxu.com/wordpress/2016/05/css3-filter-drop-shadow-vs-box-shadow/\" target=\"_blank\" rel=\"external\">CSS3 filter:drop-shadow滤镜与box-shadow区别应用</a></p>\n"},{"title":"前端工程化-gulp应用篇2","date":"2016-08-24T15:13:58.000Z","_content":"\n今天是七夕节，我和工作有个约会。尽管如此，心情还是很高兴，因为在公司负责的第一个项目赶在七夕佳节上线了。虽然是很简单的展示页面，但是做的过程也有了许多的收获，并且和工作伙伴也更加熟悉了，嘿嘿嘿。BUT回校路上的一个追魂夺命Call打破了今日的宁静….好吧，回归正题，继续讲“前端工程化的gulp应用篇”之下回分解。\n\n## 正文\n\n### 优化CSS和JS文件\n\n通常在生产环节，我们会对css和js进行一些优化：压缩和合并。这样可以减少http请求和减少文件大小，从而实现一定程度的性能优化。\n在gulp中，我们可以用[`gulp-useref`](https://www.npmjs.com/package/gulp-useref)来帮助我们进行合并。\n\n`gulp-useref`通过在html加入一段注释来判断要对那些文件进行合并。\n\n```\n<!-- build:<type> <path> -->\n... HTML Markup, list of script / link tags.\n<!-- endbuild -->\n\n```\n\n`<type>`可以是js，css或其它。`<path>`则是指合并目标的路径。\n\n如果想把我们js里面的几个文件合并为一个`main.min.js`，html中添加如下代码：\n\n```\n<!--build:js js/main.min.js -->\n<script src=\"js/lib/a-library.js\"></script>\n<script src=\"js/lib/another-library.js\"></script>\n<script src=\"js/main.js\"></script>\n<!-- endbuild -->\n\n```\n\n之后，还要在gulpfile文件进行配置（安装gulp-useref的过程我就省略了,后面的模块安装过程也同样省略了）\n\n```\nvar useref = require('gulp-useref');\n\ngulp.task('useref', function(){\n      return gulp.src('app/*.html')\n                .pipe(useref())\n                .pipe(gulp.dest('dist'))\n});\n\n```\n\n运行gulp useref，gulp就会合并注释标注的那3个js文件为main.min.js，并且dist文件也会有一个html文件，引用js的script标签也变成一个。（强烈建议自己动手试试，观察下结果！）\n[![img](https://cdn.css-tricks.com/wp-content/uploads/2015/08/useref-html-1024x291.png)](https://cdn.css-tricks.com/wp-content/uploads/2015/08/useref-html-1024x291.png)\n合并之后的文件，其实没有被压缩，这时我们可以用`gulp-uglify`来帮助我们对文件进行压缩，为了判断只对js文件进行压缩，我们还要引入另外一个压缩`gulp-if`。\n\n```\n// Other requires...\nvar uglify = require('gulp-uglify');\nvar gulpIf = require('gulp-if');\n\ngulp.task('useref', function(){\n          return gulp.src('app/*.html')\n                    .pipe(useref())\n        // Minifies only if it's a JavaScript file\n                    .pipe(gulpIf('*.js', uglify()))\n                    .pipe(gulp.dest('dist'))\n});\n\n```\n\n现在当我们运行了useref任务（合并了文件）之后gulp就立刻帮我们对合并的文件进行压缩。so wonderfu~我们可以似乎用相同的方法来对css文件进行合并，然后用`gulp-cssnano`来帮助我们对css文件进行压缩。\n\n```\n<!--build:css css/styles.min.css-->\n<link rel=\"stylesheet\" href=\"css/styles.css\">\n<link rel=\"stylesheet\" href=\"css/another-stylesheet.css\">\n<!--endbuild-->\n\n```\n\ngulpfile配置\n\n```\nvar cssnano = require('gulp-cssnano');\n\ngulp.task('useref', function(){\n      return gulp.src('app/*.html')\n                .pipe(useref())\n                    .pipe(gulpIf('*.js', uglify()))\n                // Minifies only if it's a CSS file\n                    .pipe(gulpIf('*.css', cssnano()))\n                    .pipe(gulp.dest('dist'))\n});\n\n```\n\n### 优化图片\n\n`gulp-imagemin`可以帮我们对图片进行压缩。利用这个插件，我们可以对png，jpg，gif甚至是svg进行压缩，来上栗子：\n\n```\nvar imagemin = require('gulp-imagemin');\ngulp.task('images', function(){\n          return gulp.src('app/images/**/*.+(png|jpg|gif|svg)')\n                      .pipe(imagemin())\n                      .pipe(gulp.dest('dist/images'))\n        });\n\n```\n\n`imagemin()`方法可以传入其它的参数对压缩进行设置，具体看[`gulp-imagemin`文档](https://www.npmjs.com/package/gulp-imagemin)。\n\n图片压缩的过程或许会比较慢，有时我们无需对所有图片重复进行压缩，为了达到这个目的，我们可以用`gulp-cache`。\n\n```\nvar cache = require('gulp-cache');\n\ngulp.task('images', function(){\n      return gulp.src('app/images/**/*.+(png|jpg|jpeg|gif|svg)')\n          // Caching images that ran through imagemin\n                  .pipe(cache(imagemin()))\n                  .pipe(gulp.dest('dist/images'))\n    });\n\n```\n\n### 对fonts等其它资源进行简单输出\n\n有些资源，如果我们无须进行进一步处理，仅仅想把它从app目录（开发环境）复制到dist（生产环境）中，那就只要简单的进行输出和输出就好啦~\n\n```\ngulp.task('fonts', function() {\n      return gulp.src('app/fonts/**/*')\n                  .pipe(gulp.dest('dist/fonts'))\n    })\n\n```\n\n我们现在有六个gulp任务可以进行不同的处理，为了方便我们使用，我们往往想把多个任务合并成一个任务，这样，我们只要运行一个命令就能执行多个任务了。但在此之前，我们可以了解一下怎么把生成的文件进行清空。\n\n### 自动清空生成的文件\n\n因为通过gulp的一些任务，gulp会自动帮我们生成一些文件，但是对于我们之前生成的，但是现在不需要的文件，我们需要对其进行清空时，就需要`del`模块来帮助我们。\n\n`del（）`方法可以接收一组node globs来告诉gulp哪些文件要被删除。如果我们想把dist文件全部清空的话，这样就可以实现：\n\n```\ngulp.task('clean:dist', function() {\n      return del.sync('dist');\n    })\n\n```\n\n但是，前面`gulp-cache`来报错在缓存中的`dist/images`是不会被删除的，如果你想把这个文件也删除了，可以这样写：\n\n```\ngulp.task('cache:clear', function (callback) {\n    return cache.clearAll(callback)\n    })\n\n```\n\n### 对gulp tasks进行合并\n\n回想一下我们至今做的一切。\n对于开发环境，我们把sass编译成css，而且对其进行实时监控，浏览器可以在文件修改保存后自动刷新。 对于生产环境，我们对css和js进行合并压缩，对图片进行了压缩，对其它一些资源（fonts）直接进行复制。\n对于后者，我们可以建立一个`build`来合并我们的`clean:dist`,`sass`.`useref`,`images`和`fonts`，有人会想到这么写：\n\n```\ngulp.task('build', [`clean`, `sass`, `useref`, `images`, `fonts`], function (){\n        console.log('Building files');\n})\n\n```\n\n然而，当我们执行build时，gulp会自发同时地去执行中括号里面的所有任务。\n\n我们希望的是`clean`任务执行完了之后才执行其它任务。所以，为了按顺序执行某些任务，我们可以借助`run-sequence`。\n\n```\nvar runSequence = require('run-sequence');\n\ngulp.task('task-name', function(callback) {\n      runSequence('task-one', 'task-two', 'task-three', callback);\n    });\n\n```\n\n当`task-name`被执行，gulp会先运行`task-one`，运行完这个任务，再执行`task-two`，执行完了再执行最后一个任务。\n`run-sequence`也允许同步执行某些任务：\n\n```\ngulp.task('task-name', function(callback) {\n      runSequence('task-one', ['tasks','two','run','in','parallel'], 'task-three', callback);\n});\n\n```\n\n这种情况下，gulp先运行task-one,运行完了再同时执行第二个参数里面的任务，里面的所有任务执行完毕就执行task-three。\n\n好了，来构建我们生产环境的指令：\n\n```\ngulp.task('build', function (callback) {\n      runSequence('clean:dist', ['sass', 'useref', 'images', 'fonts'], callback\n  )\n})\n\n```\n\n对于开发环境的指令，类似的方法，可以这么写：\n\n```\ngulp.task('default', function (callback) {\n      runSequence(['sass','browserSync', 'watch'],callback\n      )\n})\n\n```\n\n注意，名为default的task可以直接在命令行运行gulp来执行该任务。\n\n### 这就是所有了吗？\n\n通过上面的教程，我们可以配置出一个简单的前端工作流，代码已经po到github上了[`basic-workflow`](https://github.com/yzzhuo/basic-workflow)。开发过程，我们可以通过`gulp`命令来自动编译sass并且在浏览器自动刷新等，完成了开发后通过`gulp build`就可以优化资源，输出到用于生产的dist目录中。\n\n但是，千万别以为它能做的只是这些。你可以做更多的事情：\n\n- [sourcemap](https://www.npmjs.com/package/gulp-sourcemaps)可以更容易定位到错误\n- [sprity](https://www.npmjs.com/package/sprity)或者gulp.spritesmith可以合成雪碧图\n- 通过webpack，browserify模块化js文件\n- 利用模板引擎模块化html\n- 自动部署到服务器\n  ….\n\n**对于不同的项目，可能需要根据自己的需求来构件不一样的前端工作流。但一旦能在开发之前构建出一个好的前端工作流，开发工作就会达到事半功倍的效果。用gulp就像有了一个供使唤的小弟，工作一下子轻松了许多，姐姐我终于不用到处瞎折腾啦**","source":"_posts/前端工程化-gulp应用篇2.md","raw":"---\ntitle: 前端工程化-gulp应用篇2\ndate: 2016-8-24 23:13:58\ntags: 前端工具\n---\n\n今天是七夕节，我和工作有个约会。尽管如此，心情还是很高兴，因为在公司负责的第一个项目赶在七夕佳节上线了。虽然是很简单的展示页面，但是做的过程也有了许多的收获，并且和工作伙伴也更加熟悉了，嘿嘿嘿。BUT回校路上的一个追魂夺命Call打破了今日的宁静….好吧，回归正题，继续讲“前端工程化的gulp应用篇”之下回分解。\n\n## 正文\n\n### 优化CSS和JS文件\n\n通常在生产环节，我们会对css和js进行一些优化：压缩和合并。这样可以减少http请求和减少文件大小，从而实现一定程度的性能优化。\n在gulp中，我们可以用[`gulp-useref`](https://www.npmjs.com/package/gulp-useref)来帮助我们进行合并。\n\n`gulp-useref`通过在html加入一段注释来判断要对那些文件进行合并。\n\n```\n<!-- build:<type> <path> -->\n... HTML Markup, list of script / link tags.\n<!-- endbuild -->\n\n```\n\n`<type>`可以是js，css或其它。`<path>`则是指合并目标的路径。\n\n如果想把我们js里面的几个文件合并为一个`main.min.js`，html中添加如下代码：\n\n```\n<!--build:js js/main.min.js -->\n<script src=\"js/lib/a-library.js\"></script>\n<script src=\"js/lib/another-library.js\"></script>\n<script src=\"js/main.js\"></script>\n<!-- endbuild -->\n\n```\n\n之后，还要在gulpfile文件进行配置（安装gulp-useref的过程我就省略了,后面的模块安装过程也同样省略了）\n\n```\nvar useref = require('gulp-useref');\n\ngulp.task('useref', function(){\n      return gulp.src('app/*.html')\n                .pipe(useref())\n                .pipe(gulp.dest('dist'))\n});\n\n```\n\n运行gulp useref，gulp就会合并注释标注的那3个js文件为main.min.js，并且dist文件也会有一个html文件，引用js的script标签也变成一个。（强烈建议自己动手试试，观察下结果！）\n[![img](https://cdn.css-tricks.com/wp-content/uploads/2015/08/useref-html-1024x291.png)](https://cdn.css-tricks.com/wp-content/uploads/2015/08/useref-html-1024x291.png)\n合并之后的文件，其实没有被压缩，这时我们可以用`gulp-uglify`来帮助我们对文件进行压缩，为了判断只对js文件进行压缩，我们还要引入另外一个压缩`gulp-if`。\n\n```\n// Other requires...\nvar uglify = require('gulp-uglify');\nvar gulpIf = require('gulp-if');\n\ngulp.task('useref', function(){\n          return gulp.src('app/*.html')\n                    .pipe(useref())\n        // Minifies only if it's a JavaScript file\n                    .pipe(gulpIf('*.js', uglify()))\n                    .pipe(gulp.dest('dist'))\n});\n\n```\n\n现在当我们运行了useref任务（合并了文件）之后gulp就立刻帮我们对合并的文件进行压缩。so wonderfu~我们可以似乎用相同的方法来对css文件进行合并，然后用`gulp-cssnano`来帮助我们对css文件进行压缩。\n\n```\n<!--build:css css/styles.min.css-->\n<link rel=\"stylesheet\" href=\"css/styles.css\">\n<link rel=\"stylesheet\" href=\"css/another-stylesheet.css\">\n<!--endbuild-->\n\n```\n\ngulpfile配置\n\n```\nvar cssnano = require('gulp-cssnano');\n\ngulp.task('useref', function(){\n      return gulp.src('app/*.html')\n                .pipe(useref())\n                    .pipe(gulpIf('*.js', uglify()))\n                // Minifies only if it's a CSS file\n                    .pipe(gulpIf('*.css', cssnano()))\n                    .pipe(gulp.dest('dist'))\n});\n\n```\n\n### 优化图片\n\n`gulp-imagemin`可以帮我们对图片进行压缩。利用这个插件，我们可以对png，jpg，gif甚至是svg进行压缩，来上栗子：\n\n```\nvar imagemin = require('gulp-imagemin');\ngulp.task('images', function(){\n          return gulp.src('app/images/**/*.+(png|jpg|gif|svg)')\n                      .pipe(imagemin())\n                      .pipe(gulp.dest('dist/images'))\n        });\n\n```\n\n`imagemin()`方法可以传入其它的参数对压缩进行设置，具体看[`gulp-imagemin`文档](https://www.npmjs.com/package/gulp-imagemin)。\n\n图片压缩的过程或许会比较慢，有时我们无需对所有图片重复进行压缩，为了达到这个目的，我们可以用`gulp-cache`。\n\n```\nvar cache = require('gulp-cache');\n\ngulp.task('images', function(){\n      return gulp.src('app/images/**/*.+(png|jpg|jpeg|gif|svg)')\n          // Caching images that ran through imagemin\n                  .pipe(cache(imagemin()))\n                  .pipe(gulp.dest('dist/images'))\n    });\n\n```\n\n### 对fonts等其它资源进行简单输出\n\n有些资源，如果我们无须进行进一步处理，仅仅想把它从app目录（开发环境）复制到dist（生产环境）中，那就只要简单的进行输出和输出就好啦~\n\n```\ngulp.task('fonts', function() {\n      return gulp.src('app/fonts/**/*')\n                  .pipe(gulp.dest('dist/fonts'))\n    })\n\n```\n\n我们现在有六个gulp任务可以进行不同的处理，为了方便我们使用，我们往往想把多个任务合并成一个任务，这样，我们只要运行一个命令就能执行多个任务了。但在此之前，我们可以了解一下怎么把生成的文件进行清空。\n\n### 自动清空生成的文件\n\n因为通过gulp的一些任务，gulp会自动帮我们生成一些文件，但是对于我们之前生成的，但是现在不需要的文件，我们需要对其进行清空时，就需要`del`模块来帮助我们。\n\n`del（）`方法可以接收一组node globs来告诉gulp哪些文件要被删除。如果我们想把dist文件全部清空的话，这样就可以实现：\n\n```\ngulp.task('clean:dist', function() {\n      return del.sync('dist');\n    })\n\n```\n\n但是，前面`gulp-cache`来报错在缓存中的`dist/images`是不会被删除的，如果你想把这个文件也删除了，可以这样写：\n\n```\ngulp.task('cache:clear', function (callback) {\n    return cache.clearAll(callback)\n    })\n\n```\n\n### 对gulp tasks进行合并\n\n回想一下我们至今做的一切。\n对于开发环境，我们把sass编译成css，而且对其进行实时监控，浏览器可以在文件修改保存后自动刷新。 对于生产环境，我们对css和js进行合并压缩，对图片进行了压缩，对其它一些资源（fonts）直接进行复制。\n对于后者，我们可以建立一个`build`来合并我们的`clean:dist`,`sass`.`useref`,`images`和`fonts`，有人会想到这么写：\n\n```\ngulp.task('build', [`clean`, `sass`, `useref`, `images`, `fonts`], function (){\n        console.log('Building files');\n})\n\n```\n\n然而，当我们执行build时，gulp会自发同时地去执行中括号里面的所有任务。\n\n我们希望的是`clean`任务执行完了之后才执行其它任务。所以，为了按顺序执行某些任务，我们可以借助`run-sequence`。\n\n```\nvar runSequence = require('run-sequence');\n\ngulp.task('task-name', function(callback) {\n      runSequence('task-one', 'task-two', 'task-three', callback);\n    });\n\n```\n\n当`task-name`被执行，gulp会先运行`task-one`，运行完这个任务，再执行`task-two`，执行完了再执行最后一个任务。\n`run-sequence`也允许同步执行某些任务：\n\n```\ngulp.task('task-name', function(callback) {\n      runSequence('task-one', ['tasks','two','run','in','parallel'], 'task-three', callback);\n});\n\n```\n\n这种情况下，gulp先运行task-one,运行完了再同时执行第二个参数里面的任务，里面的所有任务执行完毕就执行task-three。\n\n好了，来构建我们生产环境的指令：\n\n```\ngulp.task('build', function (callback) {\n      runSequence('clean:dist', ['sass', 'useref', 'images', 'fonts'], callback\n  )\n})\n\n```\n\n对于开发环境的指令，类似的方法，可以这么写：\n\n```\ngulp.task('default', function (callback) {\n      runSequence(['sass','browserSync', 'watch'],callback\n      )\n})\n\n```\n\n注意，名为default的task可以直接在命令行运行gulp来执行该任务。\n\n### 这就是所有了吗？\n\n通过上面的教程，我们可以配置出一个简单的前端工作流，代码已经po到github上了[`basic-workflow`](https://github.com/yzzhuo/basic-workflow)。开发过程，我们可以通过`gulp`命令来自动编译sass并且在浏览器自动刷新等，完成了开发后通过`gulp build`就可以优化资源，输出到用于生产的dist目录中。\n\n但是，千万别以为它能做的只是这些。你可以做更多的事情：\n\n- [sourcemap](https://www.npmjs.com/package/gulp-sourcemaps)可以更容易定位到错误\n- [sprity](https://www.npmjs.com/package/sprity)或者gulp.spritesmith可以合成雪碧图\n- 通过webpack，browserify模块化js文件\n- 利用模板引擎模块化html\n- 自动部署到服务器\n  ….\n\n**对于不同的项目，可能需要根据自己的需求来构件不一样的前端工作流。但一旦能在开发之前构建出一个好的前端工作流，开发工作就会达到事半功倍的效果。用gulp就像有了一个供使唤的小弟，工作一下子轻松了许多，姐姐我终于不用到处瞎折腾啦**","slug":"前端工程化-gulp应用篇2","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwn4000lcgesi4qf8yim","content":"<p>今天是七夕节，我和工作有个约会。尽管如此，心情还是很高兴，因为在公司负责的第一个项目赶在七夕佳节上线了。虽然是很简单的展示页面，但是做的过程也有了许多的收获，并且和工作伙伴也更加熟悉了，嘿嘿嘿。BUT回校路上的一个追魂夺命Call打破了今日的宁静….好吧，回归正题，继续讲“前端工程化的gulp应用篇”之下回分解。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"优化CSS和JS文件\"><a href=\"#优化CSS和JS文件\" class=\"headerlink\" title=\"优化CSS和JS文件\"></a>优化CSS和JS文件</h3><p>通常在生产环节，我们会对css和js进行一些优化：压缩和合并。这样可以减少http请求和减少文件大小，从而实现一定程度的性能优化。<br>在gulp中，我们可以用<a href=\"https://www.npmjs.com/package/gulp-useref\" target=\"_blank\" rel=\"external\"><code>gulp-useref</code></a>来帮助我们进行合并。</p>\n<p><code>gulp-useref</code>通过在html加入一段注释来判断要对那些文件进行合并。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- build:&lt;type&gt; &lt;path&gt; --&gt;</div><div class=\"line\">... HTML Markup, list of script / link tags.</div><div class=\"line\">&lt;!-- endbuild --&gt;</div></pre></td></tr></table></figure>\n<p><code>&lt;type&gt;</code>可以是js，css或其它。<code>&lt;path&gt;</code>则是指合并目标的路径。</p>\n<p>如果想把我们js里面的几个文件合并为一个<code>main.min.js</code>，html中添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--build:js js/main.min.js --&gt;</div><div class=\"line\">&lt;script src=&quot;js/lib/a-library.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;js/lib/another-library.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;!-- endbuild --&gt;</div></pre></td></tr></table></figure>\n<p>之后，还要在gulpfile文件进行配置（安装gulp-useref的过程我就省略了,后面的模块安装过程也同样省略了）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var useref = require(&apos;gulp-useref&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;useref&apos;, function()&#123;</div><div class=\"line\">      return gulp.src(&apos;app/*.html&apos;)</div><div class=\"line\">                .pipe(useref())</div><div class=\"line\">                .pipe(gulp.dest(&apos;dist&apos;))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>运行gulp useref，gulp就会合并注释标注的那3个js文件为main.min.js，并且dist文件也会有一个html文件，引用js的script标签也变成一个。（强烈建议自己动手试试，观察下结果！）<br><a href=\"https://cdn.css-tricks.com/wp-content/uploads/2015/08/useref-html-1024x291.png\" target=\"_blank\" rel=\"external\"><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2015/08/useref-html-1024x291.png\" alt=\"img\"></a><br>合并之后的文件，其实没有被压缩，这时我们可以用<code>gulp-uglify</code>来帮助我们对文件进行压缩，为了判断只对js文件进行压缩，我们还要引入另外一个压缩<code>gulp-if</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Other requires...</div><div class=\"line\">var uglify = require(&apos;gulp-uglify&apos;);</div><div class=\"line\">var gulpIf = require(&apos;gulp-if&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;useref&apos;, function()&#123;</div><div class=\"line\">          return gulp.src(&apos;app/*.html&apos;)</div><div class=\"line\">                    .pipe(useref())</div><div class=\"line\">        // Minifies only if it&apos;s a JavaScript file</div><div class=\"line\">                    .pipe(gulpIf(&apos;*.js&apos;, uglify()))</div><div class=\"line\">                    .pipe(gulp.dest(&apos;dist&apos;))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>现在当我们运行了useref任务（合并了文件）之后gulp就立刻帮我们对合并的文件进行压缩。so wonderfu~我们可以似乎用相同的方法来对css文件进行合并，然后用<code>gulp-cssnano</code>来帮助我们对css文件进行压缩。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--build:css css/styles.min.css--&gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/styles.css&quot;&gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/another-stylesheet.css&quot;&gt;</div><div class=\"line\">&lt;!--endbuild--&gt;</div></pre></td></tr></table></figure>\n<p>gulpfile配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cssnano = require(&apos;gulp-cssnano&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;useref&apos;, function()&#123;</div><div class=\"line\">      return gulp.src(&apos;app/*.html&apos;)</div><div class=\"line\">                .pipe(useref())</div><div class=\"line\">                    .pipe(gulpIf(&apos;*.js&apos;, uglify()))</div><div class=\"line\">                // Minifies only if it&apos;s a CSS file</div><div class=\"line\">                    .pipe(gulpIf(&apos;*.css&apos;, cssnano()))</div><div class=\"line\">                    .pipe(gulp.dest(&apos;dist&apos;))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"优化图片\"><a href=\"#优化图片\" class=\"headerlink\" title=\"优化图片\"></a>优化图片</h3><p><code>gulp-imagemin</code>可以帮我们对图片进行压缩。利用这个插件，我们可以对png，jpg，gif甚至是svg进行压缩，来上栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var imagemin = require(&apos;gulp-imagemin&apos;);</div><div class=\"line\">gulp.task(&apos;images&apos;, function()&#123;</div><div class=\"line\">          return gulp.src(&apos;app/images/**/*.+(png|jpg|gif|svg)&apos;)</div><div class=\"line\">                      .pipe(imagemin())</div><div class=\"line\">                      .pipe(gulp.dest(&apos;dist/images&apos;))</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p><code>imagemin()</code>方法可以传入其它的参数对压缩进行设置，具体看<a href=\"https://www.npmjs.com/package/gulp-imagemin\" target=\"_blank\" rel=\"external\"><code>gulp-imagemin</code>文档</a>。</p>\n<p>图片压缩的过程或许会比较慢，有时我们无需对所有图片重复进行压缩，为了达到这个目的，我们可以用<code>gulp-cache</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cache = require(&apos;gulp-cache&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;images&apos;, function()&#123;</div><div class=\"line\">      return gulp.src(&apos;app/images/**/*.+(png|jpg|jpeg|gif|svg)&apos;)</div><div class=\"line\">          // Caching images that ran through imagemin</div><div class=\"line\">                  .pipe(cache(imagemin()))</div><div class=\"line\">                  .pipe(gulp.dest(&apos;dist/images&apos;))</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"对fonts等其它资源进行简单输出\"><a href=\"#对fonts等其它资源进行简单输出\" class=\"headerlink\" title=\"对fonts等其它资源进行简单输出\"></a>对fonts等其它资源进行简单输出</h3><p>有些资源，如果我们无须进行进一步处理，仅仅想把它从app目录（开发环境）复制到dist（生产环境）中，那就只要简单的进行输出和输出就好啦~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;fonts&apos;, function() &#123;</div><div class=\"line\">      return gulp.src(&apos;app/fonts/**/*&apos;)</div><div class=\"line\">                  .pipe(gulp.dest(&apos;dist/fonts&apos;))</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<p>我们现在有六个gulp任务可以进行不同的处理，为了方便我们使用，我们往往想把多个任务合并成一个任务，这样，我们只要运行一个命令就能执行多个任务了。但在此之前，我们可以了解一下怎么把生成的文件进行清空。</p>\n<h3 id=\"自动清空生成的文件\"><a href=\"#自动清空生成的文件\" class=\"headerlink\" title=\"自动清空生成的文件\"></a>自动清空生成的文件</h3><p>因为通过gulp的一些任务，gulp会自动帮我们生成一些文件，但是对于我们之前生成的，但是现在不需要的文件，我们需要对其进行清空时，就需要<code>del</code>模块来帮助我们。</p>\n<p><code>del（）</code>方法可以接收一组node globs来告诉gulp哪些文件要被删除。如果我们想把dist文件全部清空的话，这样就可以实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;clean:dist&apos;, function() &#123;</div><div class=\"line\">      return del.sync(&apos;dist&apos;);</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<p>但是，前面<code>gulp-cache</code>来报错在缓存中的<code>dist/images</code>是不会被删除的，如果你想把这个文件也删除了，可以这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;cache:clear&apos;, function (callback) &#123;</div><div class=\"line\">    return cache.clearAll(callback)</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"对gulp-tasks进行合并\"><a href=\"#对gulp-tasks进行合并\" class=\"headerlink\" title=\"对gulp tasks进行合并\"></a>对gulp tasks进行合并</h3><p>回想一下我们至今做的一切。<br>对于开发环境，我们把sass编译成css，而且对其进行实时监控，浏览器可以在文件修改保存后自动刷新。 对于生产环境，我们对css和js进行合并压缩，对图片进行了压缩，对其它一些资源（fonts）直接进行复制。<br>对于后者，我们可以建立一个<code>build</code>来合并我们的<code>clean:dist</code>,<code>sass</code>.<code>useref</code>,<code>images</code>和<code>fonts</code>，有人会想到这么写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;build&apos;, [`clean`, `sass`, `useref`, `images`, `fonts`], function ()&#123;</div><div class=\"line\">        console.log(&apos;Building files&apos;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>然而，当我们执行build时，gulp会自发同时地去执行中括号里面的所有任务。</p>\n<p>我们希望的是<code>clean</code>任务执行完了之后才执行其它任务。所以，为了按顺序执行某些任务，我们可以借助<code>run-sequence</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var runSequence = require(&apos;run-sequence&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;task-name&apos;, function(callback) &#123;</div><div class=\"line\">      runSequence(&apos;task-one&apos;, &apos;task-two&apos;, &apos;task-three&apos;, callback);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>当<code>task-name</code>被执行，gulp会先运行<code>task-one</code>，运行完这个任务，再执行<code>task-two</code>，执行完了再执行最后一个任务。<br><code>run-sequence</code>也允许同步执行某些任务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;task-name&apos;, function(callback) &#123;</div><div class=\"line\">      runSequence(&apos;task-one&apos;, [&apos;tasks&apos;,&apos;two&apos;,&apos;run&apos;,&apos;in&apos;,&apos;parallel&apos;], &apos;task-three&apos;, callback);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这种情况下，gulp先运行task-one,运行完了再同时执行第二个参数里面的任务，里面的所有任务执行完毕就执行task-three。</p>\n<p>好了，来构建我们生产环境的指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;build&apos;, function (callback) &#123;</div><div class=\"line\">      runSequence(&apos;clean:dist&apos;, [&apos;sass&apos;, &apos;useref&apos;, &apos;images&apos;, &apos;fonts&apos;], callback</div><div class=\"line\">  )</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>对于开发环境的指令，类似的方法，可以这么写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;default&apos;, function (callback) &#123;</div><div class=\"line\">      runSequence([&apos;sass&apos;,&apos;browserSync&apos;, &apos;watch&apos;],callback</div><div class=\"line\">      )</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>注意，名为default的task可以直接在命令行运行gulp来执行该任务。</p>\n<h3 id=\"这就是所有了吗？\"><a href=\"#这就是所有了吗？\" class=\"headerlink\" title=\"这就是所有了吗？\"></a>这就是所有了吗？</h3><p>通过上面的教程，我们可以配置出一个简单的前端工作流，代码已经po到github上了<a href=\"https://github.com/yzzhuo/basic-workflow\" target=\"_blank\" rel=\"external\"><code>basic-workflow</code></a>。开发过程，我们可以通过<code>gulp</code>命令来自动编译sass并且在浏览器自动刷新等，完成了开发后通过<code>gulp build</code>就可以优化资源，输出到用于生产的dist目录中。</p>\n<p>但是，千万别以为它能做的只是这些。你可以做更多的事情：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/gulp-sourcemaps\" target=\"_blank\" rel=\"external\">sourcemap</a>可以更容易定位到错误</li>\n<li><a href=\"https://www.npmjs.com/package/sprity\" target=\"_blank\" rel=\"external\">sprity</a>或者gulp.spritesmith可以合成雪碧图</li>\n<li>通过webpack，browserify模块化js文件</li>\n<li>利用模板引擎模块化html</li>\n<li>自动部署到服务器<br>….</li>\n</ul>\n<p><strong>对于不同的项目，可能需要根据自己的需求来构件不一样的前端工作流。但一旦能在开发之前构建出一个好的前端工作流，开发工作就会达到事半功倍的效果。用gulp就像有了一个供使唤的小弟，工作一下子轻松了许多，姐姐我终于不用到处瞎折腾啦</strong></p>\n","site":{"data":{}},"excerpt":"","more":"<p>今天是七夕节，我和工作有个约会。尽管如此，心情还是很高兴，因为在公司负责的第一个项目赶在七夕佳节上线了。虽然是很简单的展示页面，但是做的过程也有了许多的收获，并且和工作伙伴也更加熟悉了，嘿嘿嘿。BUT回校路上的一个追魂夺命Call打破了今日的宁静….好吧，回归正题，继续讲“前端工程化的gulp应用篇”之下回分解。</p>\n<h2 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h2><h3 id=\"优化CSS和JS文件\"><a href=\"#优化CSS和JS文件\" class=\"headerlink\" title=\"优化CSS和JS文件\"></a>优化CSS和JS文件</h3><p>通常在生产环节，我们会对css和js进行一些优化：压缩和合并。这样可以减少http请求和减少文件大小，从而实现一定程度的性能优化。<br>在gulp中，我们可以用<a href=\"https://www.npmjs.com/package/gulp-useref\" target=\"_blank\" rel=\"external\"><code>gulp-useref</code></a>来帮助我们进行合并。</p>\n<p><code>gulp-useref</code>通过在html加入一段注释来判断要对那些文件进行合并。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!-- build:&lt;type&gt; &lt;path&gt; --&gt;</div><div class=\"line\">... HTML Markup, list of script / link tags.</div><div class=\"line\">&lt;!-- endbuild --&gt;</div></pre></td></tr></table></figure>\n<p><code>&lt;type&gt;</code>可以是js，css或其它。<code>&lt;path&gt;</code>则是指合并目标的路径。</p>\n<p>如果想把我们js里面的几个文件合并为一个<code>main.min.js</code>，html中添加如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--build:js js/main.min.js --&gt;</div><div class=\"line\">&lt;script src=&quot;js/lib/a-library.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;js/lib/another-library.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;script src=&quot;js/main.js&quot;&gt;&lt;/script&gt;</div><div class=\"line\">&lt;!-- endbuild --&gt;</div></pre></td></tr></table></figure>\n<p>之后，还要在gulpfile文件进行配置（安装gulp-useref的过程我就省略了,后面的模块安装过程也同样省略了）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">var useref = require(&apos;gulp-useref&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;useref&apos;, function()&#123;</div><div class=\"line\">      return gulp.src(&apos;app/*.html&apos;)</div><div class=\"line\">                .pipe(useref())</div><div class=\"line\">                .pipe(gulp.dest(&apos;dist&apos;))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>运行gulp useref，gulp就会合并注释标注的那3个js文件为main.min.js，并且dist文件也会有一个html文件，引用js的script标签也变成一个。（强烈建议自己动手试试，观察下结果！）<br><a href=\"https://cdn.css-tricks.com/wp-content/uploads/2015/08/useref-html-1024x291.png\" target=\"_blank\" rel=\"external\"><img src=\"https://cdn.css-tricks.com/wp-content/uploads/2015/08/useref-html-1024x291.png\" alt=\"img\"></a><br>合并之后的文件，其实没有被压缩，这时我们可以用<code>gulp-uglify</code>来帮助我们对文件进行压缩，为了判断只对js文件进行压缩，我们还要引入另外一个压缩<code>gulp-if</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">// Other requires...</div><div class=\"line\">var uglify = require(&apos;gulp-uglify&apos;);</div><div class=\"line\">var gulpIf = require(&apos;gulp-if&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;useref&apos;, function()&#123;</div><div class=\"line\">          return gulp.src(&apos;app/*.html&apos;)</div><div class=\"line\">                    .pipe(useref())</div><div class=\"line\">        // Minifies only if it&apos;s a JavaScript file</div><div class=\"line\">                    .pipe(gulpIf(&apos;*.js&apos;, uglify()))</div><div class=\"line\">                    .pipe(gulp.dest(&apos;dist&apos;))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>现在当我们运行了useref任务（合并了文件）之后gulp就立刻帮我们对合并的文件进行压缩。so wonderfu~我们可以似乎用相同的方法来对css文件进行合并，然后用<code>gulp-cssnano</code>来帮助我们对css文件进行压缩。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;!--build:css css/styles.min.css--&gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/styles.css&quot;&gt;</div><div class=\"line\">&lt;link rel=&quot;stylesheet&quot; href=&quot;css/another-stylesheet.css&quot;&gt;</div><div class=\"line\">&lt;!--endbuild--&gt;</div></pre></td></tr></table></figure>\n<p>gulpfile配置</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cssnano = require(&apos;gulp-cssnano&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;useref&apos;, function()&#123;</div><div class=\"line\">      return gulp.src(&apos;app/*.html&apos;)</div><div class=\"line\">                .pipe(useref())</div><div class=\"line\">                    .pipe(gulpIf(&apos;*.js&apos;, uglify()))</div><div class=\"line\">                // Minifies only if it&apos;s a CSS file</div><div class=\"line\">                    .pipe(gulpIf(&apos;*.css&apos;, cssnano()))</div><div class=\"line\">                    .pipe(gulp.dest(&apos;dist&apos;))</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"优化图片\"><a href=\"#优化图片\" class=\"headerlink\" title=\"优化图片\"></a>优化图片</h3><p><code>gulp-imagemin</code>可以帮我们对图片进行压缩。利用这个插件，我们可以对png，jpg，gif甚至是svg进行压缩，来上栗子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">var imagemin = require(&apos;gulp-imagemin&apos;);</div><div class=\"line\">gulp.task(&apos;images&apos;, function()&#123;</div><div class=\"line\">          return gulp.src(&apos;app/images/**/*.+(png|jpg|gif|svg)&apos;)</div><div class=\"line\">                      .pipe(imagemin())</div><div class=\"line\">                      .pipe(gulp.dest(&apos;dist/images&apos;))</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p><code>imagemin()</code>方法可以传入其它的参数对压缩进行设置，具体看<a href=\"https://www.npmjs.com/package/gulp-imagemin\" target=\"_blank\" rel=\"external\"><code>gulp-imagemin</code>文档</a>。</p>\n<p>图片压缩的过程或许会比较慢，有时我们无需对所有图片重复进行压缩，为了达到这个目的，我们可以用<code>gulp-cache</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">var cache = require(&apos;gulp-cache&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;images&apos;, function()&#123;</div><div class=\"line\">      return gulp.src(&apos;app/images/**/*.+(png|jpg|jpeg|gif|svg)&apos;)</div><div class=\"line\">          // Caching images that ran through imagemin</div><div class=\"line\">                  .pipe(cache(imagemin()))</div><div class=\"line\">                  .pipe(gulp.dest(&apos;dist/images&apos;))</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"对fonts等其它资源进行简单输出\"><a href=\"#对fonts等其它资源进行简单输出\" class=\"headerlink\" title=\"对fonts等其它资源进行简单输出\"></a>对fonts等其它资源进行简单输出</h3><p>有些资源，如果我们无须进行进一步处理，仅仅想把它从app目录（开发环境）复制到dist（生产环境）中，那就只要简单的进行输出和输出就好啦~</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;fonts&apos;, function() &#123;</div><div class=\"line\">      return gulp.src(&apos;app/fonts/**/*&apos;)</div><div class=\"line\">                  .pipe(gulp.dest(&apos;dist/fonts&apos;))</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<p>我们现在有六个gulp任务可以进行不同的处理，为了方便我们使用，我们往往想把多个任务合并成一个任务，这样，我们只要运行一个命令就能执行多个任务了。但在此之前，我们可以了解一下怎么把生成的文件进行清空。</p>\n<h3 id=\"自动清空生成的文件\"><a href=\"#自动清空生成的文件\" class=\"headerlink\" title=\"自动清空生成的文件\"></a>自动清空生成的文件</h3><p>因为通过gulp的一些任务，gulp会自动帮我们生成一些文件，但是对于我们之前生成的，但是现在不需要的文件，我们需要对其进行清空时，就需要<code>del</code>模块来帮助我们。</p>\n<p><code>del（）</code>方法可以接收一组node globs来告诉gulp哪些文件要被删除。如果我们想把dist文件全部清空的话，这样就可以实现：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;clean:dist&apos;, function() &#123;</div><div class=\"line\">      return del.sync(&apos;dist&apos;);</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<p>但是，前面<code>gulp-cache</code>来报错在缓存中的<code>dist/images</code>是不会被删除的，如果你想把这个文件也删除了，可以这样写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;cache:clear&apos;, function (callback) &#123;</div><div class=\"line\">    return cache.clearAll(callback)</div><div class=\"line\">    &#125;)</div></pre></td></tr></table></figure>\n<h3 id=\"对gulp-tasks进行合并\"><a href=\"#对gulp-tasks进行合并\" class=\"headerlink\" title=\"对gulp tasks进行合并\"></a>对gulp tasks进行合并</h3><p>回想一下我们至今做的一切。<br>对于开发环境，我们把sass编译成css，而且对其进行实时监控，浏览器可以在文件修改保存后自动刷新。 对于生产环境，我们对css和js进行合并压缩，对图片进行了压缩，对其它一些资源（fonts）直接进行复制。<br>对于后者，我们可以建立一个<code>build</code>来合并我们的<code>clean:dist</code>,<code>sass</code>.<code>useref</code>,<code>images</code>和<code>fonts</code>，有人会想到这么写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;build&apos;, [`clean`, `sass`, `useref`, `images`, `fonts`], function ()&#123;</div><div class=\"line\">        console.log(&apos;Building files&apos;);</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>然而，当我们执行build时，gulp会自发同时地去执行中括号里面的所有任务。</p>\n<p>我们希望的是<code>clean</code>任务执行完了之后才执行其它任务。所以，为了按顺序执行某些任务，我们可以借助<code>run-sequence</code>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">var runSequence = require(&apos;run-sequence&apos;);</div><div class=\"line\"></div><div class=\"line\">gulp.task(&apos;task-name&apos;, function(callback) &#123;</div><div class=\"line\">      runSequence(&apos;task-one&apos;, &apos;task-two&apos;, &apos;task-three&apos;, callback);</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>当<code>task-name</code>被执行，gulp会先运行<code>task-one</code>，运行完这个任务，再执行<code>task-two</code>，执行完了再执行最后一个任务。<br><code>run-sequence</code>也允许同步执行某些任务：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;task-name&apos;, function(callback) &#123;</div><div class=\"line\">      runSequence(&apos;task-one&apos;, [&apos;tasks&apos;,&apos;two&apos;,&apos;run&apos;,&apos;in&apos;,&apos;parallel&apos;], &apos;task-three&apos;, callback);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这种情况下，gulp先运行task-one,运行完了再同时执行第二个参数里面的任务，里面的所有任务执行完毕就执行task-three。</p>\n<p>好了，来构建我们生产环境的指令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;build&apos;, function (callback) &#123;</div><div class=\"line\">      runSequence(&apos;clean:dist&apos;, [&apos;sass&apos;, &apos;useref&apos;, &apos;images&apos;, &apos;fonts&apos;], callback</div><div class=\"line\">  )</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>对于开发环境的指令，类似的方法，可以这么写：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">gulp.task(&apos;default&apos;, function (callback) &#123;</div><div class=\"line\">      runSequence([&apos;sass&apos;,&apos;browserSync&apos;, &apos;watch&apos;],callback</div><div class=\"line\">      )</div><div class=\"line\">&#125;)</div></pre></td></tr></table></figure>\n<p>注意，名为default的task可以直接在命令行运行gulp来执行该任务。</p>\n<h3 id=\"这就是所有了吗？\"><a href=\"#这就是所有了吗？\" class=\"headerlink\" title=\"这就是所有了吗？\"></a>这就是所有了吗？</h3><p>通过上面的教程，我们可以配置出一个简单的前端工作流，代码已经po到github上了<a href=\"https://github.com/yzzhuo/basic-workflow\" target=\"_blank\" rel=\"external\"><code>basic-workflow</code></a>。开发过程，我们可以通过<code>gulp</code>命令来自动编译sass并且在浏览器自动刷新等，完成了开发后通过<code>gulp build</code>就可以优化资源，输出到用于生产的dist目录中。</p>\n<p>但是，千万别以为它能做的只是这些。你可以做更多的事情：</p>\n<ul>\n<li><a href=\"https://www.npmjs.com/package/gulp-sourcemaps\" target=\"_blank\" rel=\"external\">sourcemap</a>可以更容易定位到错误</li>\n<li><a href=\"https://www.npmjs.com/package/sprity\" target=\"_blank\" rel=\"external\">sprity</a>或者gulp.spritesmith可以合成雪碧图</li>\n<li>通过webpack，browserify模块化js文件</li>\n<li>利用模板引擎模块化html</li>\n<li>自动部署到服务器<br>….</li>\n</ul>\n<p><strong>对于不同的项目，可能需要根据自己的需求来构件不一样的前端工作流。但一旦能在开发之前构建出一个好的前端工作流，开发工作就会达到事半功倍的效果。用gulp就像有了一个供使唤的小弟，工作一下子轻松了许多，姐姐我终于不用到处瞎折腾啦</strong></p>\n"},{"title":"在创业公司实习的三个月","date":"2016-10-01T15:13:58.000Z","_content":"\n八月份，我怀着期待和小心翼翼的心情进入了一个创业公司，开始了我长达三个月的实习生涯。在此，我想总结一下这三个月的经历和感悟，以及接下来的一些安排。这次的经历，和上一次实习有很大的不同，也让我对创业公司有了新的看法。\n\n### 初来乍到，互相了解和熟悉的过程\n\n公司规模不大，开发团队大约只有十来个人。麻雀虽小，但五脏俱全。里面有安卓移动开发，ios移动开发，后台开发和前端开发，也有产品经理和UI设计。平日里，程序猿们在一个独立的工作间工作。这里没有很多条条框框，有着弹性的工作时间和自由的工作状态…我还清晰地记得，有个早上，这间小屋子产品，UI，程序员共聚一堂，这边讨论着需求，那边讨论着设计稿，再那边是在讨论bug的解决方案…那个场面，确实热闹，我仿佛忘记了我现在是在工作。这便是我对这个创业公司第一次的印象，大家充满活力。一起为事业奋斗的感觉，或许就是这种感觉吧。\n\n### 我的工作\n\n#### 态度的转变\n\n刚来的一个星期，基本是在安装开发工具和搭建的开发环境，熟悉团队的工作模式和流程。之后没多久，接到第一个工作–开发公司的官网。其实主要是两个静态页面（一个移动端一个PC端），这确实难不倒我，没两下子，自己就以为完成了。公司规模虽小，但对产品质量的要求却不低。首先，前端大大看了我的代码便皱起了眉头，告诉了我很多可以改善的要点，并告诉我去学习一下gulp来进行开发，提高开发效率。UI那边也提了一大堆修改地方，很多都是细小到icon的对齐方式和文本的左边距等等..我突然意识到，自己之前有点小瞧这工作了。确实，即使是页面重构，也是一个体现个人能力的活。工作，不在乎简不简单，而在于你能不能把它做得尽善尽美。\n\n于是后面花了一个星期，来完善我做的页面。这个过程，也去学习了如何使用gulp来进行前端开发，最终自己也成功搭建了这次项目的工作流来完成sass预编译，开发过程实时刷新，合成css雪碧图等等前端自动化。发现确实效率和效果都大大提升了。在页面实现方面，自己也研究了PC的兼容问题和移动端的适配问题，发现了自己以前没有注意的要点。忙忙碌碌，终于让官网顺利上线了，看着自己做的东西被人肯定的喜悦难以言喻。第一份任务便让自己学习到了许多，尤其是工作态度上，我们应该怀着“物勒工名”的心，即对自己写的代码和做的东西负责，把每一件工作都当作一个作品，为了做出一个好的作品，首先得先严格要求自己。\n\n#### 能力的提升\n\n两个月内，自己参与完成了几个项目，能力渐渐提升被大伙们所肯定。后来，老大派给我一个艰巨的活，完成运营后台的改版，并且担任起架构的角色。因为是前后端分离模式，我看了接口文档，有些功能模块接口就有足足两页，其实自己也害怕不能胜任该工作但还是选择接受这个挑战。前端框架用angular，界面用了material-design的一个后台模板。自己以前没深入学习过ng，趁着国庆放假自己学习了一下，算是入门了。开工后，边学边做终于搭起了项目的架构，成功跑起了一些基本的功能，然后之后便和另外一个前端继续完善剩下的功能。这次的工作，自己不仅学习实践了angular，也意识到面对日新月异的前端技术，很多东西方到用时便会自然而然驱动自己去深入学习，虽然接触陌生之物时起初会有些许痛苦和抗拒，但后来发现这种遇到问题-思考问题-学习-解决问题的学习方式让自己变得干劲十足。虽然现在回头会发现有些东西可能还有更好的实践，但这个项目确实让自己的能力又提升了不少，也开始摸清了学习前端新框架的一些套路。\n\n#### 关于情绪管理和团队协作的事\n\n就在离职前一周的某天，在公司发生了一件不那么愉快的事情。当时自己花了不少精力和时间把微信公众号学历认证功能的事情完善好，好不容易能抽出身想把运营后台的代码再做检查进行优化（因为只剩几天就离职了，想好好善后，不想自己做的东西在自己离职后留坑）。可是，第二天产品就说要改需求（改动还不小），我当时说好吧，可以改。但是想到之前做的一些东西这么一改又得加班来拼命赶进度，情绪因此有些波动，后来的工作中伙伴们也似乎都察觉出自己心情不大好，但又不知道是怎么回事。有个人讲话比较直接，提醒我要训练下自己的职业素养。what？自己并非是因为针对改需求这件事才有意见..情绪瞬间一发不可收拾，那天晚上无心投入工作，准时踩点下班。走在路上，想着这几个月，自己尽职尽责，任劳任怨，却因为这事被人说职业素养不到位，只觉得满腹委屈。第二天，老大知道我不妥，直接找我谈话了，我说了前因后果。他说事发时可以说出自己心里的想法啊，比如离职前不想再接更多的活怕在一周时间内做不完，或者自己有一些安排，这些都可以理解，改动需求是一件常发生的事，但是如果是因为自己把情绪闷在心里，别人也不知道你内心的想法，那别人也只会根据表面来判断一件事…\n\n这次自己确实也有问题，在待人处事方面还是欠缺一些思考，有时情绪闷在心里不加以沟通就会出乱子，情绪爆发时一些对自己不痛不痒的话会对整个团队造成影响，切记不能带着情绪工作。这件事给自己上了一课，工作中沟通和情绪管理都很重要，另外，得到理解的前提是要懂得表达，要记住“你不是一个人在做事”。\n\n### 总结\n\n这次实习，自己得到的锻炼很多。从工作上能力还是团队协作方面都有所提升。也认识了许多人，感谢工作中伙伴们的热心帮助。实习过程也发现了自己不足的地方，今后的日子，主要还是想在技术上以及其它各方面继续不断地进行自我提升。在离职最后一天，感谢大伙们给我办欢送会，吃了美味的日料，欢乐地结束了我这三个月的实习生活。这段充实的实习时光让我成长了许多~最后附上一张图：程序猿的工（zhuang）作（bi）现场，以此纪念在这里难忘的实习时光。\n[](http://ww4.sinaimg.cn/large/63739cabgw1f9i7vvma0tj20zk0qogno.jpg)","source":"_posts/在创业公司实习的三个月.md","raw":"---\ntitle: 在创业公司实习的三个月\ndate: 2016-10-01 23:13:58\ntags: 杂谈\n---\n\n八月份，我怀着期待和小心翼翼的心情进入了一个创业公司，开始了我长达三个月的实习生涯。在此，我想总结一下这三个月的经历和感悟，以及接下来的一些安排。这次的经历，和上一次实习有很大的不同，也让我对创业公司有了新的看法。\n\n### 初来乍到，互相了解和熟悉的过程\n\n公司规模不大，开发团队大约只有十来个人。麻雀虽小，但五脏俱全。里面有安卓移动开发，ios移动开发，后台开发和前端开发，也有产品经理和UI设计。平日里，程序猿们在一个独立的工作间工作。这里没有很多条条框框，有着弹性的工作时间和自由的工作状态…我还清晰地记得，有个早上，这间小屋子产品，UI，程序员共聚一堂，这边讨论着需求，那边讨论着设计稿，再那边是在讨论bug的解决方案…那个场面，确实热闹，我仿佛忘记了我现在是在工作。这便是我对这个创业公司第一次的印象，大家充满活力。一起为事业奋斗的感觉，或许就是这种感觉吧。\n\n### 我的工作\n\n#### 态度的转变\n\n刚来的一个星期，基本是在安装开发工具和搭建的开发环境，熟悉团队的工作模式和流程。之后没多久，接到第一个工作–开发公司的官网。其实主要是两个静态页面（一个移动端一个PC端），这确实难不倒我，没两下子，自己就以为完成了。公司规模虽小，但对产品质量的要求却不低。首先，前端大大看了我的代码便皱起了眉头，告诉了我很多可以改善的要点，并告诉我去学习一下gulp来进行开发，提高开发效率。UI那边也提了一大堆修改地方，很多都是细小到icon的对齐方式和文本的左边距等等..我突然意识到，自己之前有点小瞧这工作了。确实，即使是页面重构，也是一个体现个人能力的活。工作，不在乎简不简单，而在于你能不能把它做得尽善尽美。\n\n于是后面花了一个星期，来完善我做的页面。这个过程，也去学习了如何使用gulp来进行前端开发，最终自己也成功搭建了这次项目的工作流来完成sass预编译，开发过程实时刷新，合成css雪碧图等等前端自动化。发现确实效率和效果都大大提升了。在页面实现方面，自己也研究了PC的兼容问题和移动端的适配问题，发现了自己以前没有注意的要点。忙忙碌碌，终于让官网顺利上线了，看着自己做的东西被人肯定的喜悦难以言喻。第一份任务便让自己学习到了许多，尤其是工作态度上，我们应该怀着“物勒工名”的心，即对自己写的代码和做的东西负责，把每一件工作都当作一个作品，为了做出一个好的作品，首先得先严格要求自己。\n\n#### 能力的提升\n\n两个月内，自己参与完成了几个项目，能力渐渐提升被大伙们所肯定。后来，老大派给我一个艰巨的活，完成运营后台的改版，并且担任起架构的角色。因为是前后端分离模式，我看了接口文档，有些功能模块接口就有足足两页，其实自己也害怕不能胜任该工作但还是选择接受这个挑战。前端框架用angular，界面用了material-design的一个后台模板。自己以前没深入学习过ng，趁着国庆放假自己学习了一下，算是入门了。开工后，边学边做终于搭起了项目的架构，成功跑起了一些基本的功能，然后之后便和另外一个前端继续完善剩下的功能。这次的工作，自己不仅学习实践了angular，也意识到面对日新月异的前端技术，很多东西方到用时便会自然而然驱动自己去深入学习，虽然接触陌生之物时起初会有些许痛苦和抗拒，但后来发现这种遇到问题-思考问题-学习-解决问题的学习方式让自己变得干劲十足。虽然现在回头会发现有些东西可能还有更好的实践，但这个项目确实让自己的能力又提升了不少，也开始摸清了学习前端新框架的一些套路。\n\n#### 关于情绪管理和团队协作的事\n\n就在离职前一周的某天，在公司发生了一件不那么愉快的事情。当时自己花了不少精力和时间把微信公众号学历认证功能的事情完善好，好不容易能抽出身想把运营后台的代码再做检查进行优化（因为只剩几天就离职了，想好好善后，不想自己做的东西在自己离职后留坑）。可是，第二天产品就说要改需求（改动还不小），我当时说好吧，可以改。但是想到之前做的一些东西这么一改又得加班来拼命赶进度，情绪因此有些波动，后来的工作中伙伴们也似乎都察觉出自己心情不大好，但又不知道是怎么回事。有个人讲话比较直接，提醒我要训练下自己的职业素养。what？自己并非是因为针对改需求这件事才有意见..情绪瞬间一发不可收拾，那天晚上无心投入工作，准时踩点下班。走在路上，想着这几个月，自己尽职尽责，任劳任怨，却因为这事被人说职业素养不到位，只觉得满腹委屈。第二天，老大知道我不妥，直接找我谈话了，我说了前因后果。他说事发时可以说出自己心里的想法啊，比如离职前不想再接更多的活怕在一周时间内做不完，或者自己有一些安排，这些都可以理解，改动需求是一件常发生的事，但是如果是因为自己把情绪闷在心里，别人也不知道你内心的想法，那别人也只会根据表面来判断一件事…\n\n这次自己确实也有问题，在待人处事方面还是欠缺一些思考，有时情绪闷在心里不加以沟通就会出乱子，情绪爆发时一些对自己不痛不痒的话会对整个团队造成影响，切记不能带着情绪工作。这件事给自己上了一课，工作中沟通和情绪管理都很重要，另外，得到理解的前提是要懂得表达，要记住“你不是一个人在做事”。\n\n### 总结\n\n这次实习，自己得到的锻炼很多。从工作上能力还是团队协作方面都有所提升。也认识了许多人，感谢工作中伙伴们的热心帮助。实习过程也发现了自己不足的地方，今后的日子，主要还是想在技术上以及其它各方面继续不断地进行自我提升。在离职最后一天，感谢大伙们给我办欢送会，吃了美味的日料，欢乐地结束了我这三个月的实习生活。这段充实的实习时光让我成长了许多~最后附上一张图：程序猿的工（zhuang）作（bi）现场，以此纪念在这里难忘的实习时光。\n[](http://ww4.sinaimg.cn/large/63739cabgw1f9i7vvma0tj20zk0qogno.jpg)","slug":"在创业公司实习的三个月","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwn6000ocges1pmrx3da","content":"<p>八月份，我怀着期待和小心翼翼的心情进入了一个创业公司，开始了我长达三个月的实习生涯。在此，我想总结一下这三个月的经历和感悟，以及接下来的一些安排。这次的经历，和上一次实习有很大的不同，也让我对创业公司有了新的看法。</p>\n<h3 id=\"初来乍到，互相了解和熟悉的过程\"><a href=\"#初来乍到，互相了解和熟悉的过程\" class=\"headerlink\" title=\"初来乍到，互相了解和熟悉的过程\"></a>初来乍到，互相了解和熟悉的过程</h3><p>公司规模不大，开发团队大约只有十来个人。麻雀虽小，但五脏俱全。里面有安卓移动开发，ios移动开发，后台开发和前端开发，也有产品经理和UI设计。平日里，程序猿们在一个独立的工作间工作。这里没有很多条条框框，有着弹性的工作时间和自由的工作状态…我还清晰地记得，有个早上，这间小屋子产品，UI，程序员共聚一堂，这边讨论着需求，那边讨论着设计稿，再那边是在讨论bug的解决方案…那个场面，确实热闹，我仿佛忘记了我现在是在工作。这便是我对这个创业公司第一次的印象，大家充满活力。一起为事业奋斗的感觉，或许就是这种感觉吧。</p>\n<h3 id=\"我的工作\"><a href=\"#我的工作\" class=\"headerlink\" title=\"我的工作\"></a>我的工作</h3><h4 id=\"态度的转变\"><a href=\"#态度的转变\" class=\"headerlink\" title=\"态度的转变\"></a>态度的转变</h4><p>刚来的一个星期，基本是在安装开发工具和搭建的开发环境，熟悉团队的工作模式和流程。之后没多久，接到第一个工作–开发公司的官网。其实主要是两个静态页面（一个移动端一个PC端），这确实难不倒我，没两下子，自己就以为完成了。公司规模虽小，但对产品质量的要求却不低。首先，前端大大看了我的代码便皱起了眉头，告诉了我很多可以改善的要点，并告诉我去学习一下gulp来进行开发，提高开发效率。UI那边也提了一大堆修改地方，很多都是细小到icon的对齐方式和文本的左边距等等..我突然意识到，自己之前有点小瞧这工作了。确实，即使是页面重构，也是一个体现个人能力的活。工作，不在乎简不简单，而在于你能不能把它做得尽善尽美。</p>\n<p>于是后面花了一个星期，来完善我做的页面。这个过程，也去学习了如何使用gulp来进行前端开发，最终自己也成功搭建了这次项目的工作流来完成sass预编译，开发过程实时刷新，合成css雪碧图等等前端自动化。发现确实效率和效果都大大提升了。在页面实现方面，自己也研究了PC的兼容问题和移动端的适配问题，发现了自己以前没有注意的要点。忙忙碌碌，终于让官网顺利上线了，看着自己做的东西被人肯定的喜悦难以言喻。第一份任务便让自己学习到了许多，尤其是工作态度上，我们应该怀着“物勒工名”的心，即对自己写的代码和做的东西负责，把每一件工作都当作一个作品，为了做出一个好的作品，首先得先严格要求自己。</p>\n<h4 id=\"能力的提升\"><a href=\"#能力的提升\" class=\"headerlink\" title=\"能力的提升\"></a>能力的提升</h4><p>两个月内，自己参与完成了几个项目，能力渐渐提升被大伙们所肯定。后来，老大派给我一个艰巨的活，完成运营后台的改版，并且担任起架构的角色。因为是前后端分离模式，我看了接口文档，有些功能模块接口就有足足两页，其实自己也害怕不能胜任该工作但还是选择接受这个挑战。前端框架用angular，界面用了material-design的一个后台模板。自己以前没深入学习过ng，趁着国庆放假自己学习了一下，算是入门了。开工后，边学边做终于搭起了项目的架构，成功跑起了一些基本的功能，然后之后便和另外一个前端继续完善剩下的功能。这次的工作，自己不仅学习实践了angular，也意识到面对日新月异的前端技术，很多东西方到用时便会自然而然驱动自己去深入学习，虽然接触陌生之物时起初会有些许痛苦和抗拒，但后来发现这种遇到问题-思考问题-学习-解决问题的学习方式让自己变得干劲十足。虽然现在回头会发现有些东西可能还有更好的实践，但这个项目确实让自己的能力又提升了不少，也开始摸清了学习前端新框架的一些套路。</p>\n<h4 id=\"关于情绪管理和团队协作的事\"><a href=\"#关于情绪管理和团队协作的事\" class=\"headerlink\" title=\"关于情绪管理和团队协作的事\"></a>关于情绪管理和团队协作的事</h4><p>就在离职前一周的某天，在公司发生了一件不那么愉快的事情。当时自己花了不少精力和时间把微信公众号学历认证功能的事情完善好，好不容易能抽出身想把运营后台的代码再做检查进行优化（因为只剩几天就离职了，想好好善后，不想自己做的东西在自己离职后留坑）。可是，第二天产品就说要改需求（改动还不小），我当时说好吧，可以改。但是想到之前做的一些东西这么一改又得加班来拼命赶进度，情绪因此有些波动，后来的工作中伙伴们也似乎都察觉出自己心情不大好，但又不知道是怎么回事。有个人讲话比较直接，提醒我要训练下自己的职业素养。what？自己并非是因为针对改需求这件事才有意见..情绪瞬间一发不可收拾，那天晚上无心投入工作，准时踩点下班。走在路上，想着这几个月，自己尽职尽责，任劳任怨，却因为这事被人说职业素养不到位，只觉得满腹委屈。第二天，老大知道我不妥，直接找我谈话了，我说了前因后果。他说事发时可以说出自己心里的想法啊，比如离职前不想再接更多的活怕在一周时间内做不完，或者自己有一些安排，这些都可以理解，改动需求是一件常发生的事，但是如果是因为自己把情绪闷在心里，别人也不知道你内心的想法，那别人也只会根据表面来判断一件事…</p>\n<p>这次自己确实也有问题，在待人处事方面还是欠缺一些思考，有时情绪闷在心里不加以沟通就会出乱子，情绪爆发时一些对自己不痛不痒的话会对整个团队造成影响，切记不能带着情绪工作。这件事给自己上了一课，工作中沟通和情绪管理都很重要，另外，得到理解的前提是要懂得表达，要记住“你不是一个人在做事”。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这次实习，自己得到的锻炼很多。从工作上能力还是团队协作方面都有所提升。也认识了许多人，感谢工作中伙伴们的热心帮助。实习过程也发现了自己不足的地方，今后的日子，主要还是想在技术上以及其它各方面继续不断地进行自我提升。在离职最后一天，感谢大伙们给我办欢送会，吃了美味的日料，欢乐地结束了我这三个月的实习生活。这段充实的实习时光让我成长了许多~最后附上一张图：程序猿的工（zhuang）作（bi）现场，以此纪念在这里难忘的实习时光。<br><a href=\"http://ww4.sinaimg.cn/large/63739cabgw1f9i7vvma0tj20zk0qogno.jpg\" target=\"_blank\" rel=\"external\"></a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>八月份，我怀着期待和小心翼翼的心情进入了一个创业公司，开始了我长达三个月的实习生涯。在此，我想总结一下这三个月的经历和感悟，以及接下来的一些安排。这次的经历，和上一次实习有很大的不同，也让我对创业公司有了新的看法。</p>\n<h3 id=\"初来乍到，互相了解和熟悉的过程\"><a href=\"#初来乍到，互相了解和熟悉的过程\" class=\"headerlink\" title=\"初来乍到，互相了解和熟悉的过程\"></a>初来乍到，互相了解和熟悉的过程</h3><p>公司规模不大，开发团队大约只有十来个人。麻雀虽小，但五脏俱全。里面有安卓移动开发，ios移动开发，后台开发和前端开发，也有产品经理和UI设计。平日里，程序猿们在一个独立的工作间工作。这里没有很多条条框框，有着弹性的工作时间和自由的工作状态…我还清晰地记得，有个早上，这间小屋子产品，UI，程序员共聚一堂，这边讨论着需求，那边讨论着设计稿，再那边是在讨论bug的解决方案…那个场面，确实热闹，我仿佛忘记了我现在是在工作。这便是我对这个创业公司第一次的印象，大家充满活力。一起为事业奋斗的感觉，或许就是这种感觉吧。</p>\n<h3 id=\"我的工作\"><a href=\"#我的工作\" class=\"headerlink\" title=\"我的工作\"></a>我的工作</h3><h4 id=\"态度的转变\"><a href=\"#态度的转变\" class=\"headerlink\" title=\"态度的转变\"></a>态度的转变</h4><p>刚来的一个星期，基本是在安装开发工具和搭建的开发环境，熟悉团队的工作模式和流程。之后没多久，接到第一个工作–开发公司的官网。其实主要是两个静态页面（一个移动端一个PC端），这确实难不倒我，没两下子，自己就以为完成了。公司规模虽小，但对产品质量的要求却不低。首先，前端大大看了我的代码便皱起了眉头，告诉了我很多可以改善的要点，并告诉我去学习一下gulp来进行开发，提高开发效率。UI那边也提了一大堆修改地方，很多都是细小到icon的对齐方式和文本的左边距等等..我突然意识到，自己之前有点小瞧这工作了。确实，即使是页面重构，也是一个体现个人能力的活。工作，不在乎简不简单，而在于你能不能把它做得尽善尽美。</p>\n<p>于是后面花了一个星期，来完善我做的页面。这个过程，也去学习了如何使用gulp来进行前端开发，最终自己也成功搭建了这次项目的工作流来完成sass预编译，开发过程实时刷新，合成css雪碧图等等前端自动化。发现确实效率和效果都大大提升了。在页面实现方面，自己也研究了PC的兼容问题和移动端的适配问题，发现了自己以前没有注意的要点。忙忙碌碌，终于让官网顺利上线了，看着自己做的东西被人肯定的喜悦难以言喻。第一份任务便让自己学习到了许多，尤其是工作态度上，我们应该怀着“物勒工名”的心，即对自己写的代码和做的东西负责，把每一件工作都当作一个作品，为了做出一个好的作品，首先得先严格要求自己。</p>\n<h4 id=\"能力的提升\"><a href=\"#能力的提升\" class=\"headerlink\" title=\"能力的提升\"></a>能力的提升</h4><p>两个月内，自己参与完成了几个项目，能力渐渐提升被大伙们所肯定。后来，老大派给我一个艰巨的活，完成运营后台的改版，并且担任起架构的角色。因为是前后端分离模式，我看了接口文档，有些功能模块接口就有足足两页，其实自己也害怕不能胜任该工作但还是选择接受这个挑战。前端框架用angular，界面用了material-design的一个后台模板。自己以前没深入学习过ng，趁着国庆放假自己学习了一下，算是入门了。开工后，边学边做终于搭起了项目的架构，成功跑起了一些基本的功能，然后之后便和另外一个前端继续完善剩下的功能。这次的工作，自己不仅学习实践了angular，也意识到面对日新月异的前端技术，很多东西方到用时便会自然而然驱动自己去深入学习，虽然接触陌生之物时起初会有些许痛苦和抗拒，但后来发现这种遇到问题-思考问题-学习-解决问题的学习方式让自己变得干劲十足。虽然现在回头会发现有些东西可能还有更好的实践，但这个项目确实让自己的能力又提升了不少，也开始摸清了学习前端新框架的一些套路。</p>\n<h4 id=\"关于情绪管理和团队协作的事\"><a href=\"#关于情绪管理和团队协作的事\" class=\"headerlink\" title=\"关于情绪管理和团队协作的事\"></a>关于情绪管理和团队协作的事</h4><p>就在离职前一周的某天，在公司发生了一件不那么愉快的事情。当时自己花了不少精力和时间把微信公众号学历认证功能的事情完善好，好不容易能抽出身想把运营后台的代码再做检查进行优化（因为只剩几天就离职了，想好好善后，不想自己做的东西在自己离职后留坑）。可是，第二天产品就说要改需求（改动还不小），我当时说好吧，可以改。但是想到之前做的一些东西这么一改又得加班来拼命赶进度，情绪因此有些波动，后来的工作中伙伴们也似乎都察觉出自己心情不大好，但又不知道是怎么回事。有个人讲话比较直接，提醒我要训练下自己的职业素养。what？自己并非是因为针对改需求这件事才有意见..情绪瞬间一发不可收拾，那天晚上无心投入工作，准时踩点下班。走在路上，想着这几个月，自己尽职尽责，任劳任怨，却因为这事被人说职业素养不到位，只觉得满腹委屈。第二天，老大知道我不妥，直接找我谈话了，我说了前因后果。他说事发时可以说出自己心里的想法啊，比如离职前不想再接更多的活怕在一周时间内做不完，或者自己有一些安排，这些都可以理解，改动需求是一件常发生的事，但是如果是因为自己把情绪闷在心里，别人也不知道你内心的想法，那别人也只会根据表面来判断一件事…</p>\n<p>这次自己确实也有问题，在待人处事方面还是欠缺一些思考，有时情绪闷在心里不加以沟通就会出乱子，情绪爆发时一些对自己不痛不痒的话会对整个团队造成影响，切记不能带着情绪工作。这件事给自己上了一课，工作中沟通和情绪管理都很重要，另外，得到理解的前提是要懂得表达，要记住“你不是一个人在做事”。</p>\n<h3 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h3><p>这次实习，自己得到的锻炼很多。从工作上能力还是团队协作方面都有所提升。也认识了许多人，感谢工作中伙伴们的热心帮助。实习过程也发现了自己不足的地方，今后的日子，主要还是想在技术上以及其它各方面继续不断地进行自我提升。在离职最后一天，感谢大伙们给我办欢送会，吃了美味的日料，欢乐地结束了我这三个月的实习生活。这段充实的实习时光让我成长了许多~最后附上一张图：程序猿的工（zhuang）作（bi）现场，以此纪念在这里难忘的实习时光。<br><a href=\"http://ww4.sinaimg.cn/large/63739cabgw1f9i7vvma0tj20zk0qogno.jpg\" target=\"_blank\" rel=\"external\"></a></p>\n"},{"title":"微信支付踩过的坑","date":"2016-09-10T15:13:58.000Z","_content":"\n上个星期末，给公司的一个微信公众号接微信支付的接口。本以为不就是一个小小的接口，应该是一会儿的功夫，结果却折腾得快要神经崩溃。所幸的是，在和另外一个负责服务器端的伙伴的研究下，最终成功折腾出来了。在此，为了避免之后再次掉坑，记录一下遇到的坑和解决的方法。\n\n### 前言\n\n在此之前，我先吐槽一下微信公众号（包括微信支付）的开发者文档。第一眼看的时候，流程和步骤讲得很简单，然而到真正开始做的时候，才发现文档的很多东西真的让人一脸懵逼。其次，微信这一块其实后端的活比前端要多，但是两端都应该理解微信支付的整个流程。这里的总结主要针对是前端的工作。\n\n### 正文\n\n- 微信支付的大概流程？\n\n  看完微信[公众号支付开发者文档](https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_1)，认真看完，看完两三遍，似乎没什么用，依旧是一脸懵逼.jpg。\n\n  还好，后来找到一篇[微信支付流程精简版的文章](http://blog.sina.com.cn/s/blog_48422a050102w364.html)，是这篇文章让我对微信支付的整个流程清晰了许多。\n\n  结合了教程，这次接入支付的大概流程就是：\n\n  > 1.前端在要接入微信支付的页面时会进行一次重定向，进入一个后端提供的带验证的入口URI（此过程的目的是为了让后端根据code来获取openId）\n  > 2.后端调用统一下单的接口来告诉微信交易的一些详情信息。\n  > 3.前端引入微信的sdk（[详见开发文档](https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html)），配置wx.config。\n  > 4.前端配置chooseWXPay\n  > 5.测试\n\n以上几乎每一步基本都有遇到坑，接下来会根据部分步骤遇到坑进行详细的说明。\n\n- 刚开始调用后台提供的支付接口时，前端出现了跨域问题，打开开发者工具，发现是在调用接口过程中进行了重定向发生的。\n\n  原因和解决方法：原本后端打算在我前端调用它的这个接口来获取到code然后重定向去获取openID,但是因为整个过程是在Ajax里进行的，所以会发生跨域错误。\n  解决方法：前端不直接用ajax去调用后端支付的接口，而是在进入要接入微信支付的页面时，重定向到后端的接口地址去，而后端对该接口做了相应修改，即在前端重定向后去根据code获取openId，并把openID存入cookies中。\n\n- 前端如何调用支付API。\n\n  如果把[微信支付开发文档](https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&index=6)的示例代码信以为真，那就呵呵了。反正我当时真的把`getBrandWCPayRequest`这个东西当真了，直到意识到折腾这个东西是没有未来的。\n\n  在调用微信支付API时，前端要先引入微信JS-SDK，[详见这个开发文档](https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html)，配置wx.config来注入权限验证配置。之后才可以去发起一个微信支付的请求，发起微信支付的过程具体可以先看[文档1](https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html#.E5.8F.91.E8.B5.B7.E4.B8.80.E4.B8.AA.E5.BE.AE.E4.BF.A1.E6.94.AF.E4.BB.98.E8.AF.B7.E6.B1.82)再去看[文档2](https://pay.weixin.qq.com/wiki/doc/api/index.html)\n\n- 前端wx.config和wx.chooseWXPay的参数\n\n  一开始我调用后端支付的接口返回的数据是这样的\n  [![img](http://ww4.sinaimg.cn/large/63739cabgw1f9a5vanb1rj20ay0e4dhg.jpg)](http://ww4.sinaimg.cn/large/63739cabgw1f9a5vanb1rj20ay0e4dhg.jpg)\n  第一次配置wx.config时便以为signature就是上图接口访问的sign，timestamp是自己生成的等等.（当时前后端都在支付上有些懵懂，后端too simple too native的以为把统一下单传回来的数据直接传给前端就行了，而前端以为调微信支付API时参数哪个像就拿哪个…..）\n\n**配置时注意的几个参数有：1.wx.config的signature参数是需要服务端生成的，生产的具体方法见文档的附录12.chooseWXPay的timestamp参数是小写，要和后端生产signature用的timestamp保持一致。3.chooseWXPay的paySign参数也需要服务器端生成传给前端。（paySign生成的具体规则依旧见文档的前面算法生成规则） **\n于是，后端一番整改，返回的参数总算齐了，前端只要把传回的数据填充到对于的参数即可。\n[![img](http://ww2.sinaimg.cn/large/63739cabgw1f9a6xg11zpj20gg066dh7.jpg)](http://ww2.sinaimg.cn/large/63739cabgw1f9a6xg11zpj20gg066dh7.jpg)\n\n- 前端进行测试的注意点\n\n  1.一开始用微信开发者的web调试工具来进行测试，但是发现调用微信支付时会报`不支持该类型的SDK模拟`的错误，后来才知道微信支付必须在手机进行测试，还好微信web调试工具有一个移动调试的功能，可以帮助我们在手机测试的时候方便看我们看到调试过程输出的信息。\n\n  2.实践证明最好在IPhone进行测试，因为调用支付失败时，安卓手机只会报（chooseWXPay:fail），而苹果手机则会报更加具体的错误。比如后面折腾了一番，用iphone测试后终于发现原来是`授权目录`出了差错ORZ。\n\nmore：\n\n- 因为代码就不便贴出，代码方面有疑问的话可参考[脚本网站提供的前端接入微信支付的代码](http://www.jb51.net/article/89239.htm)","source":"_posts/微信支付踩过的坑.md","raw":"---\ntitle: 微信支付踩过的坑\ndate: 2016-09-10 23:13:58\ntags: 实战总结\n---\n\n上个星期末，给公司的一个微信公众号接微信支付的接口。本以为不就是一个小小的接口，应该是一会儿的功夫，结果却折腾得快要神经崩溃。所幸的是，在和另外一个负责服务器端的伙伴的研究下，最终成功折腾出来了。在此，为了避免之后再次掉坑，记录一下遇到的坑和解决的方法。\n\n### 前言\n\n在此之前，我先吐槽一下微信公众号（包括微信支付）的开发者文档。第一眼看的时候，流程和步骤讲得很简单，然而到真正开始做的时候，才发现文档的很多东西真的让人一脸懵逼。其次，微信这一块其实后端的活比前端要多，但是两端都应该理解微信支付的整个流程。这里的总结主要针对是前端的工作。\n\n### 正文\n\n- 微信支付的大概流程？\n\n  看完微信[公众号支付开发者文档](https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_1)，认真看完，看完两三遍，似乎没什么用，依旧是一脸懵逼.jpg。\n\n  还好，后来找到一篇[微信支付流程精简版的文章](http://blog.sina.com.cn/s/blog_48422a050102w364.html)，是这篇文章让我对微信支付的整个流程清晰了许多。\n\n  结合了教程，这次接入支付的大概流程就是：\n\n  > 1.前端在要接入微信支付的页面时会进行一次重定向，进入一个后端提供的带验证的入口URI（此过程的目的是为了让后端根据code来获取openId）\n  > 2.后端调用统一下单的接口来告诉微信交易的一些详情信息。\n  > 3.前端引入微信的sdk（[详见开发文档](https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html)），配置wx.config。\n  > 4.前端配置chooseWXPay\n  > 5.测试\n\n以上几乎每一步基本都有遇到坑，接下来会根据部分步骤遇到坑进行详细的说明。\n\n- 刚开始调用后台提供的支付接口时，前端出现了跨域问题，打开开发者工具，发现是在调用接口过程中进行了重定向发生的。\n\n  原因和解决方法：原本后端打算在我前端调用它的这个接口来获取到code然后重定向去获取openID,但是因为整个过程是在Ajax里进行的，所以会发生跨域错误。\n  解决方法：前端不直接用ajax去调用后端支付的接口，而是在进入要接入微信支付的页面时，重定向到后端的接口地址去，而后端对该接口做了相应修改，即在前端重定向后去根据code获取openId，并把openID存入cookies中。\n\n- 前端如何调用支付API。\n\n  如果把[微信支付开发文档](https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&index=6)的示例代码信以为真，那就呵呵了。反正我当时真的把`getBrandWCPayRequest`这个东西当真了，直到意识到折腾这个东西是没有未来的。\n\n  在调用微信支付API时，前端要先引入微信JS-SDK，[详见这个开发文档](https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html)，配置wx.config来注入权限验证配置。之后才可以去发起一个微信支付的请求，发起微信支付的过程具体可以先看[文档1](https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html#.E5.8F.91.E8.B5.B7.E4.B8.80.E4.B8.AA.E5.BE.AE.E4.BF.A1.E6.94.AF.E4.BB.98.E8.AF.B7.E6.B1.82)再去看[文档2](https://pay.weixin.qq.com/wiki/doc/api/index.html)\n\n- 前端wx.config和wx.chooseWXPay的参数\n\n  一开始我调用后端支付的接口返回的数据是这样的\n  [![img](http://ww4.sinaimg.cn/large/63739cabgw1f9a5vanb1rj20ay0e4dhg.jpg)](http://ww4.sinaimg.cn/large/63739cabgw1f9a5vanb1rj20ay0e4dhg.jpg)\n  第一次配置wx.config时便以为signature就是上图接口访问的sign，timestamp是自己生成的等等.（当时前后端都在支付上有些懵懂，后端too simple too native的以为把统一下单传回来的数据直接传给前端就行了，而前端以为调微信支付API时参数哪个像就拿哪个…..）\n\n**配置时注意的几个参数有：1.wx.config的signature参数是需要服务端生成的，生产的具体方法见文档的附录12.chooseWXPay的timestamp参数是小写，要和后端生产signature用的timestamp保持一致。3.chooseWXPay的paySign参数也需要服务器端生成传给前端。（paySign生成的具体规则依旧见文档的前面算法生成规则） **\n于是，后端一番整改，返回的参数总算齐了，前端只要把传回的数据填充到对于的参数即可。\n[![img](http://ww2.sinaimg.cn/large/63739cabgw1f9a6xg11zpj20gg066dh7.jpg)](http://ww2.sinaimg.cn/large/63739cabgw1f9a6xg11zpj20gg066dh7.jpg)\n\n- 前端进行测试的注意点\n\n  1.一开始用微信开发者的web调试工具来进行测试，但是发现调用微信支付时会报`不支持该类型的SDK模拟`的错误，后来才知道微信支付必须在手机进行测试，还好微信web调试工具有一个移动调试的功能，可以帮助我们在手机测试的时候方便看我们看到调试过程输出的信息。\n\n  2.实践证明最好在IPhone进行测试，因为调用支付失败时，安卓手机只会报（chooseWXPay:fail），而苹果手机则会报更加具体的错误。比如后面折腾了一番，用iphone测试后终于发现原来是`授权目录`出了差错ORZ。\n\nmore：\n\n- 因为代码就不便贴出，代码方面有疑问的话可参考[脚本网站提供的前端接入微信支付的代码](http://www.jb51.net/article/89239.htm)","slug":"微信支付踩过的坑","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwn8000qcgesrdf9hrti","content":"<p>上个星期末，给公司的一个微信公众号接微信支付的接口。本以为不就是一个小小的接口，应该是一会儿的功夫，结果却折腾得快要神经崩溃。所幸的是，在和另外一个负责服务器端的伙伴的研究下，最终成功折腾出来了。在此，为了避免之后再次掉坑，记录一下遇到的坑和解决的方法。</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在此之前，我先吐槽一下微信公众号（包括微信支付）的开发者文档。第一眼看的时候，流程和步骤讲得很简单，然而到真正开始做的时候，才发现文档的很多东西真的让人一脸懵逼。其次，微信这一块其实后端的活比前端要多，但是两端都应该理解微信支付的整个流程。这里的总结主要针对是前端的工作。</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><ul>\n<li><p>微信支付的大概流程？</p>\n<p>看完微信<a href=\"https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_1\" target=\"_blank\" rel=\"external\">公众号支付开发者文档</a>，认真看完，看完两三遍，似乎没什么用，依旧是一脸懵逼.jpg。</p>\n<p>还好，后来找到一篇<a href=\"http://blog.sina.com.cn/s/blog_48422a050102w364.html\" target=\"_blank\" rel=\"external\">微信支付流程精简版的文章</a>，是这篇文章让我对微信支付的整个流程清晰了许多。</p>\n<p>结合了教程，这次接入支付的大概流程就是：</p>\n<blockquote>\n<p>1.前端在要接入微信支付的页面时会进行一次重定向，进入一个后端提供的带验证的入口URI（此过程的目的是为了让后端根据code来获取openId）<br>2.后端调用统一下单的接口来告诉微信交易的一些详情信息。<br>3.前端引入微信的sdk（<a href=\"https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html\" target=\"_blank\" rel=\"external\">详见开发文档</a>），配置wx.config。<br>4.前端配置chooseWXPay<br>5.测试</p>\n</blockquote>\n</li>\n</ul>\n<p>以上几乎每一步基本都有遇到坑，接下来会根据部分步骤遇到坑进行详细的说明。</p>\n<ul>\n<li><p>刚开始调用后台提供的支付接口时，前端出现了跨域问题，打开开发者工具，发现是在调用接口过程中进行了重定向发生的。</p>\n<p>原因和解决方法：原本后端打算在我前端调用它的这个接口来获取到code然后重定向去获取openID,但是因为整个过程是在Ajax里进行的，所以会发生跨域错误。<br>解决方法：前端不直接用ajax去调用后端支付的接口，而是在进入要接入微信支付的页面时，重定向到后端的接口地址去，而后端对该接口做了相应修改，即在前端重定向后去根据code获取openId，并把openID存入cookies中。</p>\n</li>\n<li><p>前端如何调用支付API。</p>\n<p>如果把<a href=\"https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6\" target=\"_blank\" rel=\"external\">微信支付开发文档</a>的示例代码信以为真，那就呵呵了。反正我当时真的把<code>getBrandWCPayRequest</code>这个东西当真了，直到意识到折腾这个东西是没有未来的。</p>\n<p>在调用微信支付API时，前端要先引入微信JS-SDK，<a href=\"https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html\" target=\"_blank\" rel=\"external\">详见这个开发文档</a>，配置wx.config来注入权限验证配置。之后才可以去发起一个微信支付的请求，发起微信支付的过程具体可以先看<a href=\"https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html#.E5.8F.91.E8.B5.B7.E4.B8.80.E4.B8.AA.E5.BE.AE.E4.BF.A1.E6.94.AF.E4.BB.98.E8.AF.B7.E6.B1.82\" target=\"_blank\" rel=\"external\">文档1</a>再去看<a href=\"https://pay.weixin.qq.com/wiki/doc/api/index.html\" target=\"_blank\" rel=\"external\">文档2</a></p>\n</li>\n<li><p>前端wx.config和wx.chooseWXPay的参数</p>\n<p>一开始我调用后端支付的接口返回的数据是这样的<br><a href=\"http://ww4.sinaimg.cn/large/63739cabgw1f9a5vanb1rj20ay0e4dhg.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww4.sinaimg.cn/large/63739cabgw1f9a5vanb1rj20ay0e4dhg.jpg\" alt=\"img\"></a><br>第一次配置wx.config时便以为signature就是上图接口访问的sign，timestamp是自己生成的等等.（当时前后端都在支付上有些懵懂，后端too simple too native的以为把统一下单传回来的数据直接传给前端就行了，而前端以为调微信支付API时参数哪个像就拿哪个…..）</p>\n</li>\n</ul>\n<p><strong>配置时注意的几个参数有：1.wx.config的signature参数是需要服务端生成的，生产的具体方法见文档的附录12.chooseWXPay的timestamp参数是小写，要和后端生产signature用的timestamp保持一致。3.chooseWXPay的paySign参数也需要服务器端生成传给前端。（paySign生成的具体规则依旧见文档的前面算法生成规则） </strong><br>于是，后端一番整改，返回的参数总算齐了，前端只要把传回的数据填充到对于的参数即可。<br><a href=\"http://ww2.sinaimg.cn/large/63739cabgw1f9a6xg11zpj20gg066dh7.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww2.sinaimg.cn/large/63739cabgw1f9a6xg11zpj20gg066dh7.jpg\" alt=\"img\"></a></p>\n<ul>\n<li><p>前端进行测试的注意点</p>\n<p>1.一开始用微信开发者的web调试工具来进行测试，但是发现调用微信支付时会报<code>不支持该类型的SDK模拟</code>的错误，后来才知道微信支付必须在手机进行测试，还好微信web调试工具有一个移动调试的功能，可以帮助我们在手机测试的时候方便看我们看到调试过程输出的信息。</p>\n<p>2.实践证明最好在IPhone进行测试，因为调用支付失败时，安卓手机只会报（chooseWXPay:fail），而苹果手机则会报更加具体的错误。比如后面折腾了一番，用iphone测试后终于发现原来是<code>授权目录</code>出了差错ORZ。</p>\n</li>\n</ul>\n<p>more：</p>\n<ul>\n<li>因为代码就不便贴出，代码方面有疑问的话可参考<a href=\"http://www.jb51.net/article/89239.htm\" target=\"_blank\" rel=\"external\">脚本网站提供的前端接入微信支付的代码</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>上个星期末，给公司的一个微信公众号接微信支付的接口。本以为不就是一个小小的接口，应该是一会儿的功夫，结果却折腾得快要神经崩溃。所幸的是，在和另外一个负责服务器端的伙伴的研究下，最终成功折腾出来了。在此，为了避免之后再次掉坑，记录一下遇到的坑和解决的方法。</p>\n<h3 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h3><p>在此之前，我先吐槽一下微信公众号（包括微信支付）的开发者文档。第一眼看的时候，流程和步骤讲得很简单，然而到真正开始做的时候，才发现文档的很多东西真的让人一脸懵逼。其次，微信这一块其实后端的活比前端要多，但是两端都应该理解微信支付的整个流程。这里的总结主要针对是前端的工作。</p>\n<h3 id=\"正文\"><a href=\"#正文\" class=\"headerlink\" title=\"正文\"></a>正文</h3><ul>\n<li><p>微信支付的大概流程？</p>\n<p>看完微信<a href=\"https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_1\" target=\"_blank\" rel=\"external\">公众号支付开发者文档</a>，认真看完，看完两三遍，似乎没什么用，依旧是一脸懵逼.jpg。</p>\n<p>还好，后来找到一篇<a href=\"http://blog.sina.com.cn/s/blog_48422a050102w364.html\" target=\"_blank\" rel=\"external\">微信支付流程精简版的文章</a>，是这篇文章让我对微信支付的整个流程清晰了许多。</p>\n<p>结合了教程，这次接入支付的大概流程就是：</p>\n<blockquote>\n<p>1.前端在要接入微信支付的页面时会进行一次重定向，进入一个后端提供的带验证的入口URI（此过程的目的是为了让后端根据code来获取openId）<br>2.后端调用统一下单的接口来告诉微信交易的一些详情信息。<br>3.前端引入微信的sdk（<a href=\"https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html\" target=\"_blank\" rel=\"external\">详见开发文档</a>），配置wx.config。<br>4.前端配置chooseWXPay<br>5.测试</p>\n</blockquote>\n</li>\n</ul>\n<p>以上几乎每一步基本都有遇到坑，接下来会根据部分步骤遇到坑进行详细的说明。</p>\n<ul>\n<li><p>刚开始调用后台提供的支付接口时，前端出现了跨域问题，打开开发者工具，发现是在调用接口过程中进行了重定向发生的。</p>\n<p>原因和解决方法：原本后端打算在我前端调用它的这个接口来获取到code然后重定向去获取openID,但是因为整个过程是在Ajax里进行的，所以会发生跨域错误。<br>解决方法：前端不直接用ajax去调用后端支付的接口，而是在进入要接入微信支付的页面时，重定向到后端的接口地址去，而后端对该接口做了相应修改，即在前端重定向后去根据code获取openId，并把openID存入cookies中。</p>\n</li>\n<li><p>前端如何调用支付API。</p>\n<p>如果把<a href=\"https://pay.weixin.qq.com/wiki/doc/api/jsapi.php?chapter=7_7&amp;index=6\" target=\"_blank\" rel=\"external\">微信支付开发文档</a>的示例代码信以为真，那就呵呵了。反正我当时真的把<code>getBrandWCPayRequest</code>这个东西当真了，直到意识到折腾这个东西是没有未来的。</p>\n<p>在调用微信支付API时，前端要先引入微信JS-SDK，<a href=\"https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html\" target=\"_blank\" rel=\"external\">详见这个开发文档</a>，配置wx.config来注入权限验证配置。之后才可以去发起一个微信支付的请求，发起微信支付的过程具体可以先看<a href=\"https://mp.weixin.qq.com/wiki/7/aaa137b55fb2e0456bf8dd9148dd613f.html#.E5.8F.91.E8.B5.B7.E4.B8.80.E4.B8.AA.E5.BE.AE.E4.BF.A1.E6.94.AF.E4.BB.98.E8.AF.B7.E6.B1.82\" target=\"_blank\" rel=\"external\">文档1</a>再去看<a href=\"https://pay.weixin.qq.com/wiki/doc/api/index.html\" target=\"_blank\" rel=\"external\">文档2</a></p>\n</li>\n<li><p>前端wx.config和wx.chooseWXPay的参数</p>\n<p>一开始我调用后端支付的接口返回的数据是这样的<br><a href=\"http://ww4.sinaimg.cn/large/63739cabgw1f9a5vanb1rj20ay0e4dhg.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww4.sinaimg.cn/large/63739cabgw1f9a5vanb1rj20ay0e4dhg.jpg\" alt=\"img\"></a><br>第一次配置wx.config时便以为signature就是上图接口访问的sign，timestamp是自己生成的等等.（当时前后端都在支付上有些懵懂，后端too simple too native的以为把统一下单传回来的数据直接传给前端就行了，而前端以为调微信支付API时参数哪个像就拿哪个…..）</p>\n</li>\n</ul>\n<p><strong>配置时注意的几个参数有：1.wx.config的signature参数是需要服务端生成的，生产的具体方法见文档的附录12.chooseWXPay的timestamp参数是小写，要和后端生产signature用的timestamp保持一致。3.chooseWXPay的paySign参数也需要服务器端生成传给前端。（paySign生成的具体规则依旧见文档的前面算法生成规则） </strong><br>于是，后端一番整改，返回的参数总算齐了，前端只要把传回的数据填充到对于的参数即可。<br><a href=\"http://ww2.sinaimg.cn/large/63739cabgw1f9a6xg11zpj20gg066dh7.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww2.sinaimg.cn/large/63739cabgw1f9a6xg11zpj20gg066dh7.jpg\" alt=\"img\"></a></p>\n<ul>\n<li><p>前端进行测试的注意点</p>\n<p>1.一开始用微信开发者的web调试工具来进行测试，但是发现调用微信支付时会报<code>不支持该类型的SDK模拟</code>的错误，后来才知道微信支付必须在手机进行测试，还好微信web调试工具有一个移动调试的功能，可以帮助我们在手机测试的时候方便看我们看到调试过程输出的信息。</p>\n<p>2.实践证明最好在IPhone进行测试，因为调用支付失败时，安卓手机只会报（chooseWXPay:fail），而苹果手机则会报更加具体的错误。比如后面折腾了一番，用iphone测试后终于发现原来是<code>授权目录</code>出了差错ORZ。</p>\n</li>\n</ul>\n<p>more：</p>\n<ul>\n<li>因为代码就不便贴出，代码方面有疑问的话可参考<a href=\"http://www.jb51.net/article/89239.htm\" target=\"_blank\" rel=\"external\">脚本网站提供的前端接入微信支付的代码</a></li>\n</ul>\n"},{"title":"浏览器渲染性能分析与优化","date":"2016-12-01T15:13:58.000Z","_content":"\n之前梳理了下浏览器渲染的大致流程。觉得应该弄清楚它跟前端性能优化的关系，于是结合了渲染的各个过程来整理下如何对网页进行分析和有哪些调优手段。\n\n### 性能分析\n\n#### 工具\n\nchrome开发者工具的Timeline。（[传送门->使用说明](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool)）\n\n#### 指标\n\n##### 60ftps\n\n当今大多数设备的屏幕刷新率都是 60次/秒 ，如果浏览器能与设备屏幕的刷新率保持一致即能让用户拥有流畅的体验，这也代表了每帧的渲染工作要求达到16ms。\n\n##### 关键呈现路径\n\n#### 利用chrome的timeline进行初步诊断\n\n[![img](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/imgs/timeline-annotated.png)](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/imgs/timeline-annotated.png)\n上图是timeline的分析面板，从上到下的区域分别要注意的点：\n\n1. 控制面板最左边的圆点可以开始/停止录制页面渲染过程。右边提供了要记录的信息。\n2. 概述窗口从上到下分别是FPS,CPU和NET图表。\n   - FPS：展示了每秒的帧数，绿条越高，FPS越高。上面的红色方块表示长帧，即可能的卡顿块。\n   - CPU：展示了不同事件消耗CPU资源的情况。\n   - NET：展示了资源获取的情况。\n     色块的表示类型与NETWORK面板的相同。\n   - 蓝色：HTML\n   - 黄色：脚本\n   - 紫色：样式表\n   - 媒体文件： 绿色\n   - 其它资源： 灰色\n3. 在从上到下数的第三个区域可以看到三条线，蓝色竖线代表DOMContentLoaded的事件，绿线是开始paint的事件，红色线代表load事件。了解时间轴里每个记录类型的详细代表的含义可以看[这里](https://developers.google.com/web/tools/chrome-devtools/profile/evaluate-performance/performance-reference)\n\n！另外，要得到比较准确的结果，最好开启隐身模式，清清浏览器缓存，避免与分析无关的操作。\n\n试试在这个博客（未经优化勿喷）打开timeline录制，可以看到这个网页的性能有很大的改进空间，FPS显示了许多长帧，点击详细的时间类型可以看到更多详细的信息。\n\n此外，勾选控制面板的screenshots还能捕捉录制过程中的截图，启用js profile能在时间线显示调用的js函数对耗时长的js进行分析追踪。更多请看官方文档。\n\n#### 其它分析手段\n\n- 使用Navigation Timing评估关键呈现路径（[详细的说明见这篇文章](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp)），另外也可以用[google analytics](https://support.google.com/analytics/answer/1205784)来进行评估和查看优化建议。\n- 利用打点\n\n#### 优化方向\n\n这里仅仅从渲染的角度考虑\n\n##### 优化关键路径\n\n减少首页出现的空白画面，分析哪些资源是关键资源，哪些是无需立刻加载的。\n\n- JavaScript：异步或者延迟解析js，避免长时间运行js\n- CSS： 将css放入head，避免使用css import，内联阻止显示的css\n\n##### 减少渲染过程的重排、重绘\n\n- 渲染三种场景：\n  - 修改dom元素的“layout”样式（影响元素的位置或者大小等）：\n    - js/css->calculate style->layout->paint->compsite(渲染层合并)\n  - 修改dom的“paint only”属性：\n    - js/css->calculate style->paint->compsite\n  - 修改非样式非绘制的dom属性（transform和opacity）\n    - js/css->calculate style->compsite\n\n（具体css属性会触发什么渲染类型可以看[CSS trigger](http://csstriggers.com/)）\n应该尽量减少第一种场景和第二种场景的发生。\n\n### 优化类型\n\n- js\n  - 优化方法：\n    - 动画效果可以使用requestAnimationFrame\n    - 耗时长的js代码放到web worker上去\n    - dom元素的更新划分成多个小任务，分别在多个frame中去完成\n- css\n  - 优化手段：\n    - 减低css选择器的复杂度，使用基于class的方式，比如BEM\n    - 减少需要执行样式计算的个数\n- DOM操作\n  - 智能的浏览器，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。从性能角度考虑，尽量不要把读操作和写操作。最好多个读操作（多个写操作）放一起。\n  - 操作统一元素的多条样式，最好通过DOM改变class来一次惊喜改变\n    、\n- 一些可以用于渲染性能提升的方法：\n  - window.requestAnimationFrame():可以把某些代码放到下一次重新渲染时执行。如页面滚动的监听函数或者网页动画都可以用这个方法。\n  - window.requestIdleCallback()：它指定只有当一帧的末尾有空闲时间，才会执行回调函数\n\n参考文献：\n[谷歌最新的开发者工具文档](https://developers.google.com/web/tools/chrome-devtools/)","source":"_posts/浏览器渲染性能分析与优化.md","raw":"---\ntitle: 浏览器渲染性能分析与优化\ndate: 2016-12-01 23:13:58\ntags: 前端性能\n---\n\n之前梳理了下浏览器渲染的大致流程。觉得应该弄清楚它跟前端性能优化的关系，于是结合了渲染的各个过程来整理下如何对网页进行分析和有哪些调优手段。\n\n### 性能分析\n\n#### 工具\n\nchrome开发者工具的Timeline。（[传送门->使用说明](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool)）\n\n#### 指标\n\n##### 60ftps\n\n当今大多数设备的屏幕刷新率都是 60次/秒 ，如果浏览器能与设备屏幕的刷新率保持一致即能让用户拥有流畅的体验，这也代表了每帧的渲染工作要求达到16ms。\n\n##### 关键呈现路径\n\n#### 利用chrome的timeline进行初步诊断\n\n[![img](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/imgs/timeline-annotated.png)](https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/imgs/timeline-annotated.png)\n上图是timeline的分析面板，从上到下的区域分别要注意的点：\n\n1. 控制面板最左边的圆点可以开始/停止录制页面渲染过程。右边提供了要记录的信息。\n2. 概述窗口从上到下分别是FPS,CPU和NET图表。\n   - FPS：展示了每秒的帧数，绿条越高，FPS越高。上面的红色方块表示长帧，即可能的卡顿块。\n   - CPU：展示了不同事件消耗CPU资源的情况。\n   - NET：展示了资源获取的情况。\n     色块的表示类型与NETWORK面板的相同。\n   - 蓝色：HTML\n   - 黄色：脚本\n   - 紫色：样式表\n   - 媒体文件： 绿色\n   - 其它资源： 灰色\n3. 在从上到下数的第三个区域可以看到三条线，蓝色竖线代表DOMContentLoaded的事件，绿线是开始paint的事件，红色线代表load事件。了解时间轴里每个记录类型的详细代表的含义可以看[这里](https://developers.google.com/web/tools/chrome-devtools/profile/evaluate-performance/performance-reference)\n\n！另外，要得到比较准确的结果，最好开启隐身模式，清清浏览器缓存，避免与分析无关的操作。\n\n试试在这个博客（未经优化勿喷）打开timeline录制，可以看到这个网页的性能有很大的改进空间，FPS显示了许多长帧，点击详细的时间类型可以看到更多详细的信息。\n\n此外，勾选控制面板的screenshots还能捕捉录制过程中的截图，启用js profile能在时间线显示调用的js函数对耗时长的js进行分析追踪。更多请看官方文档。\n\n#### 其它分析手段\n\n- 使用Navigation Timing评估关键呈现路径（[详细的说明见这篇文章](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp)），另外也可以用[google analytics](https://support.google.com/analytics/answer/1205784)来进行评估和查看优化建议。\n- 利用打点\n\n#### 优化方向\n\n这里仅仅从渲染的角度考虑\n\n##### 优化关键路径\n\n减少首页出现的空白画面，分析哪些资源是关键资源，哪些是无需立刻加载的。\n\n- JavaScript：异步或者延迟解析js，避免长时间运行js\n- CSS： 将css放入head，避免使用css import，内联阻止显示的css\n\n##### 减少渲染过程的重排、重绘\n\n- 渲染三种场景：\n  - 修改dom元素的“layout”样式（影响元素的位置或者大小等）：\n    - js/css->calculate style->layout->paint->compsite(渲染层合并)\n  - 修改dom的“paint only”属性：\n    - js/css->calculate style->paint->compsite\n  - 修改非样式非绘制的dom属性（transform和opacity）\n    - js/css->calculate style->compsite\n\n（具体css属性会触发什么渲染类型可以看[CSS trigger](http://csstriggers.com/)）\n应该尽量减少第一种场景和第二种场景的发生。\n\n### 优化类型\n\n- js\n  - 优化方法：\n    - 动画效果可以使用requestAnimationFrame\n    - 耗时长的js代码放到web worker上去\n    - dom元素的更新划分成多个小任务，分别在多个frame中去完成\n- css\n  - 优化手段：\n    - 减低css选择器的复杂度，使用基于class的方式，比如BEM\n    - 减少需要执行样式计算的个数\n- DOM操作\n  - 智能的浏览器，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。从性能角度考虑，尽量不要把读操作和写操作。最好多个读操作（多个写操作）放一起。\n  - 操作统一元素的多条样式，最好通过DOM改变class来一次惊喜改变\n    、\n- 一些可以用于渲染性能提升的方法：\n  - window.requestAnimationFrame():可以把某些代码放到下一次重新渲染时执行。如页面滚动的监听函数或者网页动画都可以用这个方法。\n  - window.requestIdleCallback()：它指定只有当一帧的末尾有空闲时间，才会执行回调函数\n\n参考文献：\n[谷歌最新的开发者工具文档](https://developers.google.com/web/tools/chrome-devtools/)","slug":"浏览器渲染性能分析与优化","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwna000scgesd5spzt67","content":"<p>之前梳理了下浏览器渲染的大致流程。觉得应该弄清楚它跟前端性能优化的关系，于是结合了渲染的各个过程来整理下如何对网页进行分析和有哪些调优手段。</p>\n<h3 id=\"性能分析\"><a href=\"#性能分析\" class=\"headerlink\" title=\"性能分析\"></a>性能分析</h3><h4 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h4><p>chrome开发者工具的Timeline。（<a href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool\" target=\"_blank\" rel=\"external\">传送门-&gt;使用说明</a>）</p>\n<h4 id=\"指标\"><a href=\"#指标\" class=\"headerlink\" title=\"指标\"></a>指标</h4><h5 id=\"60ftps\"><a href=\"#60ftps\" class=\"headerlink\" title=\"60ftps\"></a>60ftps</h5><p>当今大多数设备的屏幕刷新率都是 60次/秒 ，如果浏览器能与设备屏幕的刷新率保持一致即能让用户拥有流畅的体验，这也代表了每帧的渲染工作要求达到16ms。</p>\n<h5 id=\"关键呈现路径\"><a href=\"#关键呈现路径\" class=\"headerlink\" title=\"关键呈现路径\"></a>关键呈现路径</h5><h4 id=\"利用chrome的timeline进行初步诊断\"><a href=\"#利用chrome的timeline进行初步诊断\" class=\"headerlink\" title=\"利用chrome的timeline进行初步诊断\"></a>利用chrome的timeline进行初步诊断</h4><p><a href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/imgs/timeline-annotated.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/imgs/timeline-annotated.png\" alt=\"img\"></a><br>上图是timeline的分析面板，从上到下的区域分别要注意的点：</p>\n<ol>\n<li>控制面板最左边的圆点可以开始/停止录制页面渲染过程。右边提供了要记录的信息。</li>\n<li>概述窗口从上到下分别是FPS,CPU和NET图表。<ul>\n<li>FPS：展示了每秒的帧数，绿条越高，FPS越高。上面的红色方块表示长帧，即可能的卡顿块。</li>\n<li>CPU：展示了不同事件消耗CPU资源的情况。</li>\n<li>NET：展示了资源获取的情况。<br>色块的表示类型与NETWORK面板的相同。</li>\n<li>蓝色：HTML</li>\n<li>黄色：脚本</li>\n<li>紫色：样式表</li>\n<li>媒体文件： 绿色</li>\n<li>其它资源： 灰色</li>\n</ul>\n</li>\n<li>在从上到下数的第三个区域可以看到三条线，蓝色竖线代表DOMContentLoaded的事件，绿线是开始paint的事件，红色线代表load事件。了解时间轴里每个记录类型的详细代表的含义可以看<a href=\"https://developers.google.com/web/tools/chrome-devtools/profile/evaluate-performance/performance-reference\" target=\"_blank\" rel=\"external\">这里</a></li>\n</ol>\n<p>！另外，要得到比较准确的结果，最好开启隐身模式，清清浏览器缓存，避免与分析无关的操作。</p>\n<p>试试在这个博客（未经优化勿喷）打开timeline录制，可以看到这个网页的性能有很大的改进空间，FPS显示了许多长帧，点击详细的时间类型可以看到更多详细的信息。</p>\n<p>此外，勾选控制面板的screenshots还能捕捉录制过程中的截图，启用js profile能在时间线显示调用的js函数对耗时长的js进行分析追踪。更多请看官方文档。</p>\n<h4 id=\"其它分析手段\"><a href=\"#其它分析手段\" class=\"headerlink\" title=\"其它分析手段\"></a>其它分析手段</h4><ul>\n<li>使用Navigation Timing评估关键呈现路径（<a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp\" target=\"_blank\" rel=\"external\">详细的说明见这篇文章</a>），另外也可以用<a href=\"https://support.google.com/analytics/answer/1205784\" target=\"_blank\" rel=\"external\">google analytics</a>来进行评估和查看优化建议。</li>\n<li>利用打点</li>\n</ul>\n<h4 id=\"优化方向\"><a href=\"#优化方向\" class=\"headerlink\" title=\"优化方向\"></a>优化方向</h4><p>这里仅仅从渲染的角度考虑</p>\n<h5 id=\"优化关键路径\"><a href=\"#优化关键路径\" class=\"headerlink\" title=\"优化关键路径\"></a>优化关键路径</h5><p>减少首页出现的空白画面，分析哪些资源是关键资源，哪些是无需立刻加载的。</p>\n<ul>\n<li>JavaScript：异步或者延迟解析js，避免长时间运行js</li>\n<li>CSS： 将css放入head，避免使用css import，内联阻止显示的css</li>\n</ul>\n<h5 id=\"减少渲染过程的重排、重绘\"><a href=\"#减少渲染过程的重排、重绘\" class=\"headerlink\" title=\"减少渲染过程的重排、重绘\"></a>减少渲染过程的重排、重绘</h5><ul>\n<li>渲染三种场景：<ul>\n<li>修改dom元素的“layout”样式（影响元素的位置或者大小等）：<ul>\n<li>js/css-&gt;calculate style-&gt;layout-&gt;paint-&gt;compsite(渲染层合并)</li>\n</ul>\n</li>\n<li>修改dom的“paint only”属性：<ul>\n<li>js/css-&gt;calculate style-&gt;paint-&gt;compsite</li>\n</ul>\n</li>\n<li>修改非样式非绘制的dom属性（transform和opacity）<ul>\n<li>js/css-&gt;calculate style-&gt;compsite</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>（具体css属性会触发什么渲染类型可以看<a href=\"http://csstriggers.com/\" target=\"_blank\" rel=\"external\">CSS trigger</a>）<br>应该尽量减少第一种场景和第二种场景的发生。</p>\n<h3 id=\"优化类型\"><a href=\"#优化类型\" class=\"headerlink\" title=\"优化类型\"></a>优化类型</h3><ul>\n<li>js<ul>\n<li>优化方法：<ul>\n<li>动画效果可以使用requestAnimationFrame</li>\n<li>耗时长的js代码放到web worker上去</li>\n<li>dom元素的更新划分成多个小任务，分别在多个frame中去完成</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>css<ul>\n<li>优化手段：<ul>\n<li>减低css选择器的复杂度，使用基于class的方式，比如BEM</li>\n<li>减少需要执行样式计算的个数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>DOM操作<ul>\n<li>智能的浏览器，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。从性能角度考虑，尽量不要把读操作和写操作。最好多个读操作（多个写操作）放一起。</li>\n<li>操作统一元素的多条样式，最好通过DOM改变class来一次惊喜改变<br>、</li>\n</ul>\n</li>\n<li>一些可以用于渲染性能提升的方法：<ul>\n<li>window.requestAnimationFrame():可以把某些代码放到下一次重新渲染时执行。如页面滚动的监听函数或者网页动画都可以用这个方法。</li>\n<li>window.requestIdleCallback()：它指定只有当一帧的末尾有空闲时间，才会执行回调函数</li>\n</ul>\n</li>\n</ul>\n<p>参考文献：<br><a href=\"https://developers.google.com/web/tools/chrome-devtools/\" target=\"_blank\" rel=\"external\">谷歌最新的开发者工具文档</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前梳理了下浏览器渲染的大致流程。觉得应该弄清楚它跟前端性能优化的关系，于是结合了渲染的各个过程来整理下如何对网页进行分析和有哪些调优手段。</p>\n<h3 id=\"性能分析\"><a href=\"#性能分析\" class=\"headerlink\" title=\"性能分析\"></a>性能分析</h3><h4 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h4><p>chrome开发者工具的Timeline。（<a href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/timeline-tool\" target=\"_blank\" rel=\"external\">传送门-&gt;使用说明</a>）</p>\n<h4 id=\"指标\"><a href=\"#指标\" class=\"headerlink\" title=\"指标\"></a>指标</h4><h5 id=\"60ftps\"><a href=\"#60ftps\" class=\"headerlink\" title=\"60ftps\"></a>60ftps</h5><p>当今大多数设备的屏幕刷新率都是 60次/秒 ，如果浏览器能与设备屏幕的刷新率保持一致即能让用户拥有流畅的体验，这也代表了每帧的渲染工作要求达到16ms。</p>\n<h5 id=\"关键呈现路径\"><a href=\"#关键呈现路径\" class=\"headerlink\" title=\"关键呈现路径\"></a>关键呈现路径</h5><h4 id=\"利用chrome的timeline进行初步诊断\"><a href=\"#利用chrome的timeline进行初步诊断\" class=\"headerlink\" title=\"利用chrome的timeline进行初步诊断\"></a>利用chrome的timeline进行初步诊断</h4><p><a href=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/imgs/timeline-annotated.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/tools/chrome-devtools/evaluate-performance/imgs/timeline-annotated.png\" alt=\"img\"></a><br>上图是timeline的分析面板，从上到下的区域分别要注意的点：</p>\n<ol>\n<li>控制面板最左边的圆点可以开始/停止录制页面渲染过程。右边提供了要记录的信息。</li>\n<li>概述窗口从上到下分别是FPS,CPU和NET图表。<ul>\n<li>FPS：展示了每秒的帧数，绿条越高，FPS越高。上面的红色方块表示长帧，即可能的卡顿块。</li>\n<li>CPU：展示了不同事件消耗CPU资源的情况。</li>\n<li>NET：展示了资源获取的情况。<br>色块的表示类型与NETWORK面板的相同。</li>\n<li>蓝色：HTML</li>\n<li>黄色：脚本</li>\n<li>紫色：样式表</li>\n<li>媒体文件： 绿色</li>\n<li>其它资源： 灰色</li>\n</ul>\n</li>\n<li>在从上到下数的第三个区域可以看到三条线，蓝色竖线代表DOMContentLoaded的事件，绿线是开始paint的事件，红色线代表load事件。了解时间轴里每个记录类型的详细代表的含义可以看<a href=\"https://developers.google.com/web/tools/chrome-devtools/profile/evaluate-performance/performance-reference\" target=\"_blank\" rel=\"external\">这里</a></li>\n</ol>\n<p>！另外，要得到比较准确的结果，最好开启隐身模式，清清浏览器缓存，避免与分析无关的操作。</p>\n<p>试试在这个博客（未经优化勿喷）打开timeline录制，可以看到这个网页的性能有很大的改进空间，FPS显示了许多长帧，点击详细的时间类型可以看到更多详细的信息。</p>\n<p>此外，勾选控制面板的screenshots还能捕捉录制过程中的截图，启用js profile能在时间线显示调用的js函数对耗时长的js进行分析追踪。更多请看官方文档。</p>\n<h4 id=\"其它分析手段\"><a href=\"#其它分析手段\" class=\"headerlink\" title=\"其它分析手段\"></a>其它分析手段</h4><ul>\n<li>使用Navigation Timing评估关键呈现路径（<a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp\" target=\"_blank\" rel=\"external\">详细的说明见这篇文章</a>），另外也可以用<a href=\"https://support.google.com/analytics/answer/1205784\" target=\"_blank\" rel=\"external\">google analytics</a>来进行评估和查看优化建议。</li>\n<li>利用打点</li>\n</ul>\n<h4 id=\"优化方向\"><a href=\"#优化方向\" class=\"headerlink\" title=\"优化方向\"></a>优化方向</h4><p>这里仅仅从渲染的角度考虑</p>\n<h5 id=\"优化关键路径\"><a href=\"#优化关键路径\" class=\"headerlink\" title=\"优化关键路径\"></a>优化关键路径</h5><p>减少首页出现的空白画面，分析哪些资源是关键资源，哪些是无需立刻加载的。</p>\n<ul>\n<li>JavaScript：异步或者延迟解析js，避免长时间运行js</li>\n<li>CSS： 将css放入head，避免使用css import，内联阻止显示的css</li>\n</ul>\n<h5 id=\"减少渲染过程的重排、重绘\"><a href=\"#减少渲染过程的重排、重绘\" class=\"headerlink\" title=\"减少渲染过程的重排、重绘\"></a>减少渲染过程的重排、重绘</h5><ul>\n<li>渲染三种场景：<ul>\n<li>修改dom元素的“layout”样式（影响元素的位置或者大小等）：<ul>\n<li>js/css-&gt;calculate style-&gt;layout-&gt;paint-&gt;compsite(渲染层合并)</li>\n</ul>\n</li>\n<li>修改dom的“paint only”属性：<ul>\n<li>js/css-&gt;calculate style-&gt;paint-&gt;compsite</li>\n</ul>\n</li>\n<li>修改非样式非绘制的dom属性（transform和opacity）<ul>\n<li>js/css-&gt;calculate style-&gt;compsite</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>（具体css属性会触发什么渲染类型可以看<a href=\"http://csstriggers.com/\" target=\"_blank\" rel=\"external\">CSS trigger</a>）<br>应该尽量减少第一种场景和第二种场景的发生。</p>\n<h3 id=\"优化类型\"><a href=\"#优化类型\" class=\"headerlink\" title=\"优化类型\"></a>优化类型</h3><ul>\n<li>js<ul>\n<li>优化方法：<ul>\n<li>动画效果可以使用requestAnimationFrame</li>\n<li>耗时长的js代码放到web worker上去</li>\n<li>dom元素的更新划分成多个小任务，分别在多个frame中去完成</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>css<ul>\n<li>优化手段：<ul>\n<li>减低css选择器的复杂度，使用基于class的方式，比如BEM</li>\n<li>减少需要执行样式计算的个数</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>DOM操作<ul>\n<li>智能的浏览器，会尽量把所有的变动集中在一起，排成一个队列，然后一次性执行，尽量避免多次重新渲染。从性能角度考虑，尽量不要把读操作和写操作。最好多个读操作（多个写操作）放一起。</li>\n<li>操作统一元素的多条样式，最好通过DOM改变class来一次惊喜改变<br>、</li>\n</ul>\n</li>\n<li>一些可以用于渲染性能提升的方法：<ul>\n<li>window.requestAnimationFrame():可以把某些代码放到下一次重新渲染时执行。如页面滚动的监听函数或者网页动画都可以用这个方法。</li>\n<li>window.requestIdleCallback()：它指定只有当一帧的末尾有空闲时间，才会执行回调函数</li>\n</ul>\n</li>\n</ul>\n<p>参考文献：<br><a href=\"https://developers.google.com/web/tools/chrome-devtools/\" target=\"_blank\" rel=\"external\">谷歌最新的开发者工具文档</a></p>\n"},{"title":"浏览器渲染过程学习总结","date":"2016-12-01T15:13:58.000Z","_content":"\n作为一名前端工程师，我们的日常就是与浏览器打交道。想要对网页进行性能调优，又是建立在对浏览器的工作原理了解的基础上。所以，带着目的（前端优化）以及疑问（从地址栏输入地址到页面完全呈现在我眼中的整个过程发生了什么），初步了解学习了浏览器的渲染原理，在此总结一二。\n\n### 浏览器渲染的主流程（网页生成的过程）\n\n[![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png)](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png)\n\n1. HTML解析生成DOM tree\n2. CSS代码转化成CSSOM\n3. DOM和CSSOM生成render tree\n4. 浏览器根据render tree进行布局layout\n5. 绘制\n\n### 具体流程\n\n#### 解析\n\nHTML解析的主要经历了转换，符号化，词法分析，DOM构建，最终的输出就是文档对象模型（DOM）。话不多说，上图\n[![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png)\n\nCSS解析的过程与HTML解析大致相当：\n\n[![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png)\nCSS解析的最终产物就是CSSOM，大致长下面这个样子：\n[![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png)\n\n#### 生成渲染树\n\nDOM和CSSOM融合生成渲染树，这个渲染只包括渲染页面需要的节点和这些可见内容的样式信息，构建渲染树的过程浏览器大致经历了从 DOM 树的根节点开始，遍历每个可见的节点，之后给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则，最后生成了一颗由可见节点，连带其内容及计算的样式的渲染树。\n[![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png)\n\n#### 布局\n\n浏览器绘制之前光知道节点的样式是不够的，还要确定他们的位置和尺寸。这一步也叫做重排。\n布局过程输出一个盒模型。\n另外，因为页面中元素的布局通常是相对的，一个元素的大小或者位置发生了变化，很有可能会联动其它元素的布局发生变化。\n\n#### 绘制\n\n构建完渲染树和布局结束后，浏览器就会开始绘制。\n一般来说，绘制的过程是在多个层完成的。在每个层绘制玩抽，浏览器会将所有层按照合理的顺序合并成一个图层显示在屏幕上。\n\n> 绘制实际包含两个主要任务：1)创建一些列draw调用2）填充像素。后者就是常听人说的[光栅化]\n\n### 等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\n\nHow browser work强调了一下这句话：\n\n> 需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。\n\n从谷歌的开发者文档中也知道以下几点：\n\n1. CSS被视为阻塞渲染的资源，在CSSOM构建完成之前，浏览器会暂停渲染任何已处理的内容。\n   - 优化点： 应该让CSS尽早、尽快地下载到客户端，以便缩短首次渲染的时间，并使用媒体类型与媒体查询来解除阻塞\n2. javascript可以查询，修改DOM和CSSOM，js可以阻塞DOM构建，延缓页面渲染。同时js的执行也可能因为CSSOM而阻塞。\n   - 这表示了脚本的位置很重要，因为遇到script标签，DOM构建将停止，直到脚本执行完毕。\n   - 优化点：可以让js异步加载，消除关键渲染路径中不必要的js\n3. 不是所有资源都对首次描绘起重要，如图片是否加载完成并不影响构建渲染树甚至绘制页面。\n4. 前端优化的很大部分实在优化处理HTML/CSS/JS之间的依存关系。\n\n参考文献：\n\n- [How browser works](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)\n\n- [浏览器-关键呈现路径](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/)浏览器渲染过程学习总结\n\n  作为一名前端工程师，我们的日常就是与浏览器打交道。想要对网页进行性能调优，又是建立在对浏览器的工作原理了解的基础上。所以，带着目的（前端优化）以及疑问（从地址栏输入地址到页面完全呈现在我眼中的整个过程发生了什么），初步了解学习了浏览器的渲染原理，在此总结一二。\n\n  ### 浏览器渲染的主流程（网页生成的过程）\n\n  [![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png)](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png)\n\n  1. HTML解析生成DOM tree\n  2. CSS代码转化成CSSOM\n  3. DOM和CSSOM生成render tree\n  4. 浏览器根据render tree进行布局layout\n  5. 绘制\n\n  ### 具体流程\n\n  #### 解析\n\n  HTML解析的主要经历了转换，符号化，词法分析，DOM构建，最终的输出就是文档对象模型（DOM）。话不多说，上图\n  [![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png)\n\n  CSS解析的过程与HTML解析大致相当：\n\n  [![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png)\n  CSS解析的最终产物就是CSSOM，大致长下面这个样子：\n  [![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png)\n\n  #### 生成渲染树\n\n  DOM和CSSOM融合生成渲染树，这个渲染只包括渲染页面需要的节点和这些可见内容的样式信息，构建渲染树的过程浏览器大致经历了从 DOM 树的根节点开始，遍历每个可见的节点，之后给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则，最后生成了一颗由可见节点，连带其内容及计算的样式的渲染树。\n  [![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png)\n\n  #### 布局\n\n  浏览器绘制之前光知道节点的样式是不够的，还要确定他们的位置和尺寸。这一步也叫做重排。\n  布局过程输出一个盒模型。\n  另外，因为页面中元素的布局通常是相对的，一个元素的大小或者位置发生了变化，很有可能会联动其它元素的布局发生变化。\n\n  #### 绘制\n\n  构建完渲染树和布局结束后，浏览器就会开始绘制。\n  一般来说，绘制的过程是在多个层完成的。在每个层绘制玩抽，浏览器会将所有层按照合理的顺序合并成一个图层显示在屏幕上。\n\n  > 绘制实际包含两个主要任务：1)创建一些列draw调用2）填充像素。后者就是常听人说的[光栅化]\n\n  ### 等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\n\n  How browser work强调了一下这句话：\n\n  > 需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。\n\n  从谷歌的开发者文档中也知道以下几点：\n\n  1. CSS被视为阻塞渲染的资源，在CSSOM构建完成之前，浏览器会暂停渲染任何已处理的内容。\n     - 优化点： 应该让CSS尽早、尽快地下载到客户端，以便缩短首次渲染的时间，并使用媒体类型与媒体查询来解除阻塞\n  2. javascript可以查询，修改DOM和CSSOM，js可以阻塞DOM构建，延缓页面渲染。同时js的执行也可能因为CSSOM而阻塞。\n     - 这表示了脚本的位置很重要，因为遇到script标签，DOM构建将停止，直到脚本执行完毕。\n     - 优化点：可以让js异步加载，消除关键渲染路径中不必要的js\n  3. 不是所有资源都对首次描绘起重要，如图片是否加载完成并不影响构建渲染树甚至绘制页面。\n  4. 前端优化的很大部分实在优化处理HTML/CSS/JS之间的依存关系。\n\n  参考文献：\n\n  - [How browser works](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)\n  - [浏览器-关键呈现路径](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/)","source":"_posts/浏览器渲染过程学习总结.md","raw":"---\ntitle: 浏览器渲染过程学习总结\ndate: 2016-12-01 23:13:58\ntags: 前端性能\n---\n\n作为一名前端工程师，我们的日常就是与浏览器打交道。想要对网页进行性能调优，又是建立在对浏览器的工作原理了解的基础上。所以，带着目的（前端优化）以及疑问（从地址栏输入地址到页面完全呈现在我眼中的整个过程发生了什么），初步了解学习了浏览器的渲染原理，在此总结一二。\n\n### 浏览器渲染的主流程（网页生成的过程）\n\n[![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png)](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png)\n\n1. HTML解析生成DOM tree\n2. CSS代码转化成CSSOM\n3. DOM和CSSOM生成render tree\n4. 浏览器根据render tree进行布局layout\n5. 绘制\n\n### 具体流程\n\n#### 解析\n\nHTML解析的主要经历了转换，符号化，词法分析，DOM构建，最终的输出就是文档对象模型（DOM）。话不多说，上图\n[![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png)\n\nCSS解析的过程与HTML解析大致相当：\n\n[![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png)\nCSS解析的最终产物就是CSSOM，大致长下面这个样子：\n[![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png)\n\n#### 生成渲染树\n\nDOM和CSSOM融合生成渲染树，这个渲染只包括渲染页面需要的节点和这些可见内容的样式信息，构建渲染树的过程浏览器大致经历了从 DOM 树的根节点开始，遍历每个可见的节点，之后给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则，最后生成了一颗由可见节点，连带其内容及计算的样式的渲染树。\n[![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png)\n\n#### 布局\n\n浏览器绘制之前光知道节点的样式是不够的，还要确定他们的位置和尺寸。这一步也叫做重排。\n布局过程输出一个盒模型。\n另外，因为页面中元素的布局通常是相对的，一个元素的大小或者位置发生了变化，很有可能会联动其它元素的布局发生变化。\n\n#### 绘制\n\n构建完渲染树和布局结束后，浏览器就会开始绘制。\n一般来说，绘制的过程是在多个层完成的。在每个层绘制玩抽，浏览器会将所有层按照合理的顺序合并成一个图层显示在屏幕上。\n\n> 绘制实际包含两个主要任务：1)创建一些列draw调用2）填充像素。后者就是常听人说的[光栅化]\n\n### 等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\n\nHow browser work强调了一下这句话：\n\n> 需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。\n\n从谷歌的开发者文档中也知道以下几点：\n\n1. CSS被视为阻塞渲染的资源，在CSSOM构建完成之前，浏览器会暂停渲染任何已处理的内容。\n   - 优化点： 应该让CSS尽早、尽快地下载到客户端，以便缩短首次渲染的时间，并使用媒体类型与媒体查询来解除阻塞\n2. javascript可以查询，修改DOM和CSSOM，js可以阻塞DOM构建，延缓页面渲染。同时js的执行也可能因为CSSOM而阻塞。\n   - 这表示了脚本的位置很重要，因为遇到script标签，DOM构建将停止，直到脚本执行完毕。\n   - 优化点：可以让js异步加载，消除关键渲染路径中不必要的js\n3. 不是所有资源都对首次描绘起重要，如图片是否加载完成并不影响构建渲染树甚至绘制页面。\n4. 前端优化的很大部分实在优化处理HTML/CSS/JS之间的依存关系。\n\n参考文献：\n\n- [How browser works](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)\n\n- [浏览器-关键呈现路径](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/)浏览器渲染过程学习总结\n\n  作为一名前端工程师，我们的日常就是与浏览器打交道。想要对网页进行性能调优，又是建立在对浏览器的工作原理了解的基础上。所以，带着目的（前端优化）以及疑问（从地址栏输入地址到页面完全呈现在我眼中的整个过程发生了什么），初步了解学习了浏览器的渲染原理，在此总结一二。\n\n  ### 浏览器渲染的主流程（网页生成的过程）\n\n  [![img](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png)](http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png)\n\n  1. HTML解析生成DOM tree\n  2. CSS代码转化成CSSOM\n  3. DOM和CSSOM生成render tree\n  4. 浏览器根据render tree进行布局layout\n  5. 绘制\n\n  ### 具体流程\n\n  #### 解析\n\n  HTML解析的主要经历了转换，符号化，词法分析，DOM构建，最终的输出就是文档对象模型（DOM）。话不多说，上图\n  [![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png)\n\n  CSS解析的过程与HTML解析大致相当：\n\n  [![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png)\n  CSS解析的最终产物就是CSSOM，大致长下面这个样子：\n  [![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png)\n\n  #### 生成渲染树\n\n  DOM和CSSOM融合生成渲染树，这个渲染只包括渲染页面需要的节点和这些可见内容的样式信息，构建渲染树的过程浏览器大致经历了从 DOM 树的根节点开始，遍历每个可见的节点，之后给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则，最后生成了一颗由可见节点，连带其内容及计算的样式的渲染树。\n  [![img](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png)](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png)\n\n  #### 布局\n\n  浏览器绘制之前光知道节点的样式是不够的，还要确定他们的位置和尺寸。这一步也叫做重排。\n  布局过程输出一个盒模型。\n  另外，因为页面中元素的布局通常是相对的，一个元素的大小或者位置发生了变化，很有可能会联动其它元素的布局发生变化。\n\n  #### 绘制\n\n  构建完渲染树和布局结束后，浏览器就会开始绘制。\n  一般来说，绘制的过程是在多个层完成的。在每个层绘制玩抽，浏览器会将所有层按照合理的顺序合并成一个图层显示在屏幕上。\n\n  > 绘制实际包含两个主要任务：1)创建一些列draw调用2）填充像素。后者就是常听人说的[光栅化]\n\n  ### 等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\n\n  How browser work强调了一下这句话：\n\n  > 需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。\n\n  从谷歌的开发者文档中也知道以下几点：\n\n  1. CSS被视为阻塞渲染的资源，在CSSOM构建完成之前，浏览器会暂停渲染任何已处理的内容。\n     - 优化点： 应该让CSS尽早、尽快地下载到客户端，以便缩短首次渲染的时间，并使用媒体类型与媒体查询来解除阻塞\n  2. javascript可以查询，修改DOM和CSSOM，js可以阻塞DOM构建，延缓页面渲染。同时js的执行也可能因为CSSOM而阻塞。\n     - 这表示了脚本的位置很重要，因为遇到script标签，DOM构建将停止，直到脚本执行完毕。\n     - 优化点：可以让js异步加载，消除关键渲染路径中不必要的js\n  3. 不是所有资源都对首次描绘起重要，如图片是否加载完成并不影响构建渲染树甚至绘制页面。\n  4. 前端优化的很大部分实在优化处理HTML/CSS/JS之间的依存关系。\n\n  参考文献：\n\n  - [How browser works](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)\n  - [浏览器-关键呈现路径](https://developers.google.com/web/fundamentals/performance/critical-rendering-path/)","slug":"浏览器渲染过程学习总结","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwnc000ucges3enxdwul","content":"<p>作为一名前端工程师，我们的日常就是与浏览器打交道。想要对网页进行性能调优，又是建立在对浏览器的工作原理了解的基础上。所以，带着目的（前端优化）以及疑问（从地址栏输入地址到页面完全呈现在我眼中的整个过程发生了什么），初步了解学习了浏览器的渲染原理，在此总结一二。</p>\n<h3 id=\"浏览器渲染的主流程（网页生成的过程）\"><a href=\"#浏览器渲染的主流程（网页生成的过程）\" class=\"headerlink\" title=\"浏览器渲染的主流程（网页生成的过程）\"></a>浏览器渲染的主流程（网页生成的过程）</h3><p><a href=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png\" target=\"_blank\" rel=\"external\"><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png\" alt=\"img\"></a></p>\n<ol>\n<li>HTML解析生成DOM tree</li>\n<li>CSS代码转化成CSSOM</li>\n<li>DOM和CSSOM生成render tree</li>\n<li>浏览器根据render tree进行布局layout</li>\n<li>绘制</li>\n</ol>\n<h3 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h3><h4 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h4><p>HTML解析的主要经历了转换，符号化，词法分析，DOM构建，最终的输出就是文档对象模型（DOM）。话不多说，上图<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png\" alt=\"img\"></a></p>\n<p>CSS解析的过程与HTML解析大致相当：</p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png\" alt=\"img\"></a><br>CSS解析的最终产物就是CSSOM，大致长下面这个样子：<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\" alt=\"img\"></a></p>\n<h4 id=\"生成渲染树\"><a href=\"#生成渲染树\" class=\"headerlink\" title=\"生成渲染树\"></a>生成渲染树</h4><p>DOM和CSSOM融合生成渲染树，这个渲染只包括渲染页面需要的节点和这些可见内容的样式信息，构建渲染树的过程浏览器大致经历了从 DOM 树的根节点开始，遍历每个可见的节点，之后给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则，最后生成了一颗由可见节点，连带其内容及计算的样式的渲染树。<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png\" alt=\"img\"></a></p>\n<h4 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h4><p>浏览器绘制之前光知道节点的样式是不够的，还要确定他们的位置和尺寸。这一步也叫做重排。<br>布局过程输出一个盒模型。<br>另外，因为页面中元素的布局通常是相对的，一个元素的大小或者位置发生了变化，很有可能会联动其它元素的布局发生变化。</p>\n<h4 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h4><p>构建完渲染树和布局结束后，浏览器就会开始绘制。<br>一般来说，绘制的过程是在多个层完成的。在每个层绘制玩抽，浏览器会将所有层按照合理的顺序合并成一个图层显示在屏幕上。</p>\n<blockquote>\n<p>绘制实际包含两个主要任务：1)创建一些列draw调用2）填充像素。后者就是常听人说的[光栅化]</p>\n</blockquote>\n<h3 id=\"等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\"><a href=\"#等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\" class=\"headerlink\" title=\"等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\"></a>等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程</h3><p>How browser work强调了一下这句话：</p>\n<blockquote>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n</blockquote>\n<p>从谷歌的开发者文档中也知道以下几点：</p>\n<ol>\n<li>CSS被视为阻塞渲染的资源，在CSSOM构建完成之前，浏览器会暂停渲染任何已处理的内容。<ul>\n<li>优化点： 应该让CSS尽早、尽快地下载到客户端，以便缩短首次渲染的时间，并使用媒体类型与媒体查询来解除阻塞</li>\n</ul>\n</li>\n<li>javascript可以查询，修改DOM和CSSOM，js可以阻塞DOM构建，延缓页面渲染。同时js的执行也可能因为CSSOM而阻塞。<ul>\n<li>这表示了脚本的位置很重要，因为遇到script标签，DOM构建将停止，直到脚本执行完毕。</li>\n<li>优化点：可以让js异步加载，消除关键渲染路径中不必要的js</li>\n</ul>\n</li>\n<li>不是所有资源都对首次描绘起重要，如图片是否加载完成并不影响构建渲染树甚至绘制页面。</li>\n<li>前端优化的很大部分实在优化处理HTML/CSS/JS之间的依存关系。</li>\n</ol>\n<p>参考文献：</p>\n<ul>\n<li><p><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\" target=\"_blank\" rel=\"external\">How browser works</a></p>\n</li>\n<li><p><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/\" target=\"_blank\" rel=\"external\">浏览器-关键呈现路径</a>浏览器渲染过程学习总结</p>\n<p>作为一名前端工程师，我们的日常就是与浏览器打交道。想要对网页进行性能调优，又是建立在对浏览器的工作原理了解的基础上。所以，带着目的（前端优化）以及疑问（从地址栏输入地址到页面完全呈现在我眼中的整个过程发生了什么），初步了解学习了浏览器的渲染原理，在此总结一二。</p>\n<h3 id=\"浏览器渲染的主流程（网页生成的过程）-1\"><a href=\"#浏览器渲染的主流程（网页生成的过程）-1\" class=\"headerlink\" title=\"浏览器渲染的主流程（网页生成的过程）\"></a>浏览器渲染的主流程（网页生成的过程）</h3><p><a href=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png\" target=\"_blank\" rel=\"external\"><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png\" alt=\"img\"></a></p>\n<ol>\n<li>HTML解析生成DOM tree</li>\n<li>CSS代码转化成CSSOM</li>\n<li>DOM和CSSOM生成render tree</li>\n<li>浏览器根据render tree进行布局layout</li>\n<li>绘制</li>\n</ol>\n<h3 id=\"具体流程-1\"><a href=\"#具体流程-1\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h3><h4 id=\"解析-1\"><a href=\"#解析-1\" class=\"headerlink\" title=\"解析\"></a>解析</h4><p>HTML解析的主要经历了转换，符号化，词法分析，DOM构建，最终的输出就是文档对象模型（DOM）。话不多说，上图<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png\" alt=\"img\"></a></p>\n<p>CSS解析的过程与HTML解析大致相当：</p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png\" alt=\"img\"></a><br>CSS解析的最终产物就是CSSOM，大致长下面这个样子：<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\" alt=\"img\"></a></p>\n<h4 id=\"生成渲染树-1\"><a href=\"#生成渲染树-1\" class=\"headerlink\" title=\"生成渲染树\"></a>生成渲染树</h4><p>DOM和CSSOM融合生成渲染树，这个渲染只包括渲染页面需要的节点和这些可见内容的样式信息，构建渲染树的过程浏览器大致经历了从 DOM 树的根节点开始，遍历每个可见的节点，之后给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则，最后生成了一颗由可见节点，连带其内容及计算的样式的渲染树。<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png\" alt=\"img\"></a></p>\n<h4 id=\"布局-1\"><a href=\"#布局-1\" class=\"headerlink\" title=\"布局\"></a>布局</h4><p>浏览器绘制之前光知道节点的样式是不够的，还要确定他们的位置和尺寸。这一步也叫做重排。<br>布局过程输出一个盒模型。<br>另外，因为页面中元素的布局通常是相对的，一个元素的大小或者位置发生了变化，很有可能会联动其它元素的布局发生变化。</p>\n<h4 id=\"绘制-1\"><a href=\"#绘制-1\" class=\"headerlink\" title=\"绘制\"></a>绘制</h4><p>构建完渲染树和布局结束后，浏览器就会开始绘制。<br>一般来说，绘制的过程是在多个层完成的。在每个层绘制玩抽，浏览器会将所有层按照合理的顺序合并成一个图层显示在屏幕上。</p>\n<blockquote>\n<p>绘制实际包含两个主要任务：1)创建一些列draw调用2）填充像素。后者就是常听人说的[光栅化]</p>\n</blockquote>\n<h3 id=\"等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程-1\"><a href=\"#等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程-1\" class=\"headerlink\" title=\"等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\"></a>等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程</h3><p>How browser work强调了一下这句话：</p>\n<blockquote>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n</blockquote>\n<p>从谷歌的开发者文档中也知道以下几点：</p>\n<ol>\n<li>CSS被视为阻塞渲染的资源，在CSSOM构建完成之前，浏览器会暂停渲染任何已处理的内容。<ul>\n<li>优化点： 应该让CSS尽早、尽快地下载到客户端，以便缩短首次渲染的时间，并使用媒体类型与媒体查询来解除阻塞</li>\n</ul>\n</li>\n<li>javascript可以查询，修改DOM和CSSOM，js可以阻塞DOM构建，延缓页面渲染。同时js的执行也可能因为CSSOM而阻塞。<ul>\n<li>这表示了脚本的位置很重要，因为遇到script标签，DOM构建将停止，直到脚本执行完毕。</li>\n<li>优化点：可以让js异步加载，消除关键渲染路径中不必要的js</li>\n</ul>\n</li>\n<li>不是所有资源都对首次描绘起重要，如图片是否加载完成并不影响构建渲染树甚至绘制页面。</li>\n<li>前端优化的很大部分实在优化处理HTML/CSS/JS之间的依存关系。</li>\n</ol>\n<p>参考文献：</p>\n<ul>\n<li><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\" target=\"_blank\" rel=\"external\">How browser works</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/\" target=\"_blank\" rel=\"external\">浏览器-关键呈现路径</a></li>\n</ul>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>作为一名前端工程师，我们的日常就是与浏览器打交道。想要对网页进行性能调优，又是建立在对浏览器的工作原理了解的基础上。所以，带着目的（前端优化）以及疑问（从地址栏输入地址到页面完全呈现在我眼中的整个过程发生了什么），初步了解学习了浏览器的渲染原理，在此总结一二。</p>\n<h3 id=\"浏览器渲染的主流程（网页生成的过程）\"><a href=\"#浏览器渲染的主流程（网页生成的过程）\" class=\"headerlink\" title=\"浏览器渲染的主流程（网页生成的过程）\"></a>浏览器渲染的主流程（网页生成的过程）</h3><p><a href=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png\" target=\"_blank\" rel=\"external\"><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png\" alt=\"img\"></a></p>\n<ol>\n<li>HTML解析生成DOM tree</li>\n<li>CSS代码转化成CSSOM</li>\n<li>DOM和CSSOM生成render tree</li>\n<li>浏览器根据render tree进行布局layout</li>\n<li>绘制</li>\n</ol>\n<h3 id=\"具体流程\"><a href=\"#具体流程\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h3><h4 id=\"解析\"><a href=\"#解析\" class=\"headerlink\" title=\"解析\"></a>解析</h4><p>HTML解析的主要经历了转换，符号化，词法分析，DOM构建，最终的输出就是文档对象模型（DOM）。话不多说，上图<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png\" alt=\"img\"></a></p>\n<p>CSS解析的过程与HTML解析大致相当：</p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png\" alt=\"img\"></a><br>CSS解析的最终产物就是CSSOM，大致长下面这个样子：<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\" alt=\"img\"></a></p>\n<h4 id=\"生成渲染树\"><a href=\"#生成渲染树\" class=\"headerlink\" title=\"生成渲染树\"></a>生成渲染树</h4><p>DOM和CSSOM融合生成渲染树，这个渲染只包括渲染页面需要的节点和这些可见内容的样式信息，构建渲染树的过程浏览器大致经历了从 DOM 树的根节点开始，遍历每个可见的节点，之后给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则，最后生成了一颗由可见节点，连带其内容及计算的样式的渲染树。<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png\" alt=\"img\"></a></p>\n<h4 id=\"布局\"><a href=\"#布局\" class=\"headerlink\" title=\"布局\"></a>布局</h4><p>浏览器绘制之前光知道节点的样式是不够的，还要确定他们的位置和尺寸。这一步也叫做重排。<br>布局过程输出一个盒模型。<br>另外，因为页面中元素的布局通常是相对的，一个元素的大小或者位置发生了变化，很有可能会联动其它元素的布局发生变化。</p>\n<h4 id=\"绘制\"><a href=\"#绘制\" class=\"headerlink\" title=\"绘制\"></a>绘制</h4><p>构建完渲染树和布局结束后，浏览器就会开始绘制。<br>一般来说，绘制的过程是在多个层完成的。在每个层绘制玩抽，浏览器会将所有层按照合理的顺序合并成一个图层显示在屏幕上。</p>\n<blockquote>\n<p>绘制实际包含两个主要任务：1)创建一些列draw调用2）填充像素。后者就是常听人说的[光栅化]</p>\n</blockquote>\n<h3 id=\"等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\"><a href=\"#等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\" class=\"headerlink\" title=\"等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\"></a>等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程</h3><p>How browser work强调了一下这句话：</p>\n<blockquote>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n</blockquote>\n<p>从谷歌的开发者文档中也知道以下几点：</p>\n<ol>\n<li>CSS被视为阻塞渲染的资源，在CSSOM构建完成之前，浏览器会暂停渲染任何已处理的内容。<ul>\n<li>优化点： 应该让CSS尽早、尽快地下载到客户端，以便缩短首次渲染的时间，并使用媒体类型与媒体查询来解除阻塞</li>\n</ul>\n</li>\n<li>javascript可以查询，修改DOM和CSSOM，js可以阻塞DOM构建，延缓页面渲染。同时js的执行也可能因为CSSOM而阻塞。<ul>\n<li>这表示了脚本的位置很重要，因为遇到script标签，DOM构建将停止，直到脚本执行完毕。</li>\n<li>优化点：可以让js异步加载，消除关键渲染路径中不必要的js</li>\n</ul>\n</li>\n<li>不是所有资源都对首次描绘起重要，如图片是否加载完成并不影响构建渲染树甚至绘制页面。</li>\n<li>前端优化的很大部分实在优化处理HTML/CSS/JS之间的依存关系。</li>\n</ol>\n<p>参考文献：</p>\n<ul>\n<li><p><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\" target=\"_blank\" rel=\"external\">How browser works</a></p>\n</li>\n<li><p><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/\" target=\"_blank\" rel=\"external\">浏览器-关键呈现路径</a>浏览器渲染过程学习总结</p>\n<p>作为一名前端工程师，我们的日常就是与浏览器打交道。想要对网页进行性能调优，又是建立在对浏览器的工作原理了解的基础上。所以，带着目的（前端优化）以及疑问（从地址栏输入地址到页面完全呈现在我眼中的整个过程发生了什么），初步了解学习了浏览器的渲染原理，在此总结一二。</p>\n<h3 id=\"浏览器渲染的主流程（网页生成的过程）-1\"><a href=\"#浏览器渲染的主流程（网页生成的过程）-1\" class=\"headerlink\" title=\"浏览器渲染的主流程（网页生成的过程）\"></a>浏览器渲染的主流程（网页生成的过程）</h3><p><a href=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png\" target=\"_blank\" rel=\"external\"><img src=\"http://www.ruanyifeng.com/blogimg/asset/2015/bg2015091502.png\" alt=\"img\"></a></p>\n<ol>\n<li>HTML解析生成DOM tree</li>\n<li>CSS代码转化成CSSOM</li>\n<li>DOM和CSSOM生成render tree</li>\n<li>浏览器根据render tree进行布局layout</li>\n<li>绘制</li>\n</ol>\n<h3 id=\"具体流程-1\"><a href=\"#具体流程-1\" class=\"headerlink\" title=\"具体流程\"></a>具体流程</h3><h4 id=\"解析-1\"><a href=\"#解析-1\" class=\"headerlink\" title=\"解析\"></a>解析</h4><p>HTML解析的主要经历了转换，符号化，词法分析，DOM构建，最终的输出就是文档对象模型（DOM）。话不多说，上图<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/full-process.png\" alt=\"img\"></a></p>\n<p>CSS解析的过程与HTML解析大致相当：</p>\n<p><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-construction.png\" alt=\"img\"></a><br>CSS解析的最终产物就是CSSOM，大致长下面这个样子：<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/cssom-tree.png\" alt=\"img\"></a></p>\n<h4 id=\"生成渲染树-1\"><a href=\"#生成渲染树-1\" class=\"headerlink\" title=\"生成渲染树\"></a>生成渲染树</h4><p>DOM和CSSOM融合生成渲染树，这个渲染只包括渲染页面需要的节点和这些可见内容的样式信息，构建渲染树的过程浏览器大致经历了从 DOM 树的根节点开始，遍历每个可见的节点，之后给每个可见节点找到相应匹配的 CSSOM 规则，并应用这些规则，最后生成了一颗由可见节点，连带其内容及计算的样式的渲染树。<br><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png\" target=\"_blank\" rel=\"external\"><img src=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/images/render-tree-construction.png\" alt=\"img\"></a></p>\n<h4 id=\"布局-1\"><a href=\"#布局-1\" class=\"headerlink\" title=\"布局\"></a>布局</h4><p>浏览器绘制之前光知道节点的样式是不够的，还要确定他们的位置和尺寸。这一步也叫做重排。<br>布局过程输出一个盒模型。<br>另外，因为页面中元素的布局通常是相对的，一个元素的大小或者位置发生了变化，很有可能会联动其它元素的布局发生变化。</p>\n<h4 id=\"绘制-1\"><a href=\"#绘制-1\" class=\"headerlink\" title=\"绘制\"></a>绘制</h4><p>构建完渲染树和布局结束后，浏览器就会开始绘制。<br>一般来说，绘制的过程是在多个层完成的。在每个层绘制玩抽，浏览器会将所有层按照合理的顺序合并成一个图层显示在屏幕上。</p>\n<blockquote>\n<p>绘制实际包含两个主要任务：1)创建一些列draw调用2）填充像素。后者就是常听人说的[光栅化]</p>\n</blockquote>\n<h3 id=\"等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程-1\"><a href=\"#等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程-1\" class=\"headerlink\" title=\"等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程\"></a>等等，上面的步骤有什么依赖关系吗？实际是怎么样的一个过程</h3><p>How browser work强调了一下这句话：</p>\n<blockquote>\n<p>需要着重指出的是，这是一个渐进的过程。为达到更好的用户体验，呈现引擎会力求尽快将内容显示在屏幕上。它不必等到整个 HTML 文档解析完毕之后，就会开始构建呈现树和设置布局。在不断接收和处理来自网络的其余内容的同时，呈现引擎会将部分内容解析并显示出来。</p>\n</blockquote>\n<p>从谷歌的开发者文档中也知道以下几点：</p>\n<ol>\n<li>CSS被视为阻塞渲染的资源，在CSSOM构建完成之前，浏览器会暂停渲染任何已处理的内容。<ul>\n<li>优化点： 应该让CSS尽早、尽快地下载到客户端，以便缩短首次渲染的时间，并使用媒体类型与媒体查询来解除阻塞</li>\n</ul>\n</li>\n<li>javascript可以查询，修改DOM和CSSOM，js可以阻塞DOM构建，延缓页面渲染。同时js的执行也可能因为CSSOM而阻塞。<ul>\n<li>这表示了脚本的位置很重要，因为遇到script标签，DOM构建将停止，直到脚本执行完毕。</li>\n<li>优化点：可以让js异步加载，消除关键渲染路径中不必要的js</li>\n</ul>\n</li>\n<li>不是所有资源都对首次描绘起重要，如图片是否加载完成并不影响构建渲染树甚至绘制页面。</li>\n<li>前端优化的很大部分实在优化处理HTML/CSS/JS之间的依存关系。</li>\n</ol>\n<p>参考文献：</p>\n<ul>\n<li><a href=\"https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/\" target=\"_blank\" rel=\"external\">How browser works</a></li>\n<li><a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path/\" target=\"_blank\" rel=\"external\">浏览器-关键呈现路径</a></li>\n</ul>\n</li>\n</ul>\n"},{"title":"javascript设计模式-状态模式","date":"2017-06-23T15:13:58.000Z","_content":"\n状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。\n\n状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时情况，把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。\n\n\n\n#### 例子\n\n```javascript\nvar Light = function() {\n  this.state = 'off';\n  this.button = null;\n};\nLight.prototype.init = function() {\n  var button = document.createElement('button'),\n      self = this;\n  button.innerHTML = '开关';\n  this.button = document.body.appendChild(button);\n  this.button.onClick = function() {\n\tself.buttonWasPressed();\n  }\n}\nLight.prototype.buttonWasPressed = function() {\n\tif(this.state === 'off') {\n\t  console.log('开灯');\n      this.state = 'on'\n    } else if(this.state === 'on') {\n      console.log('弱光');\n      this.state = 'weakLight'\n    } else if (this.state === 'weakLight') {\n       console.log('弱光');\n       this.state = 'strongLight'\n    }else if (this.state === 'strongLight') {\n  \t  console.log('关灯');\n      this.state = 'off';\n    }\n}\nvar light = new Light();\nlight.init();\n```\n\n使用状态模式，将类的状态进行封装：\n\n```javascript\nvar OffLightState = function(light) {\n  this.light = light;\n}\nOffLightState.prototype.buttonWasPressed = function() {\n  console.log('弱光');\n  this.light.setState(this.light.weakLightState);\n}\nvar WeakLightState = function(light){\n this.light = lightl \n}\nWeakLightState.prototype.buttonWasPressed = function(light) {\n  console.log('强光');\n  this.light.setState(this.light.strongLightState);\n}\nvar StrongLightState = function(light) {\n  this.light = light;\n}\nStrongLightState.prototype.buttonWasPressed = function(light) {\n  console.log('关灯');\n  this.light.setState(this.light.offLightState);\n};\n\n// Light类\nvar Light = function() {\n\tthis.offLightState = new OffLightState(this);\n  \tthis.weakLightState = new WeakLightState(this);\n  \tthis.strongLightState = new StrongLightState(this);\n    this.button = null;\n}\nLight.prototype.init = function() {\n\tvar button = document.createElement('button');\n  \tself = this;\n  \tthis.button = document.body.appendChild(button);\n  \tthis.button.innerHTML ='开关';\n  \tthis.currState = this.offLightState;\n    this.button.onclick = function() {\n      self.currState.buttonWasPressed();\n    }\n}\nLight.prototype.setState = function(newState) {\n  this.currState = newState;\n}\n```\n\n实际上，灯泡的状态最好是实现同一个接口或者抽象类，来强制开发者在每一个状态实现buttonWasPressed方法。\n\n#### 好处与用处\n\n虽然从上面的代码看到，状态模式可能进行一番苦力活写各种状态类，但是它可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类之中，便于阅读和管理代码。从一定程度上，也消除了大量的条件分支语句。即使后期需要增加一种状态，我们只需要增加一个新的状态类，并且增加一种状态切换的逻辑，不至于破坏“开合封闭原则”\n\n当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它行为时，就可以考虑使用状态模式了。\n\n#### 与策略模式的对比\n\n策略模式和状态模式很相似，它们都有一个上下文，一些策略或者状态类，上下文把请求委托给类来执行，从而消除了大量的条件分支语句。它们之间的区别是策略模式中的各个策略类是平等和平行的，它们之间没有任何联系，客户必须熟悉知道这些策略类的存在，由客户自己来随时主动切换算法。而在状态模式中，状态和状态对应的行为也一并封装好的，状态之间的切换也早被完成，”改变行为“这件事情发生在状态模式内部，因此客户无需了解这些细节。","source":"_posts/状态模式.md","raw":"---\ntitle: javascript设计模式-状态模式\ndate: 2017-6-23 23:13:58\ntags: 设计模式\n---\n\n状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。\n\n状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时情况，把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。\n\n\n\n#### 例子\n\n```javascript\nvar Light = function() {\n  this.state = 'off';\n  this.button = null;\n};\nLight.prototype.init = function() {\n  var button = document.createElement('button'),\n      self = this;\n  button.innerHTML = '开关';\n  this.button = document.body.appendChild(button);\n  this.button.onClick = function() {\n\tself.buttonWasPressed();\n  }\n}\nLight.prototype.buttonWasPressed = function() {\n\tif(this.state === 'off') {\n\t  console.log('开灯');\n      this.state = 'on'\n    } else if(this.state === 'on') {\n      console.log('弱光');\n      this.state = 'weakLight'\n    } else if (this.state === 'weakLight') {\n       console.log('弱光');\n       this.state = 'strongLight'\n    }else if (this.state === 'strongLight') {\n  \t  console.log('关灯');\n      this.state = 'off';\n    }\n}\nvar light = new Light();\nlight.init();\n```\n\n使用状态模式，将类的状态进行封装：\n\n```javascript\nvar OffLightState = function(light) {\n  this.light = light;\n}\nOffLightState.prototype.buttonWasPressed = function() {\n  console.log('弱光');\n  this.light.setState(this.light.weakLightState);\n}\nvar WeakLightState = function(light){\n this.light = lightl \n}\nWeakLightState.prototype.buttonWasPressed = function(light) {\n  console.log('强光');\n  this.light.setState(this.light.strongLightState);\n}\nvar StrongLightState = function(light) {\n  this.light = light;\n}\nStrongLightState.prototype.buttonWasPressed = function(light) {\n  console.log('关灯');\n  this.light.setState(this.light.offLightState);\n};\n\n// Light类\nvar Light = function() {\n\tthis.offLightState = new OffLightState(this);\n  \tthis.weakLightState = new WeakLightState(this);\n  \tthis.strongLightState = new StrongLightState(this);\n    this.button = null;\n}\nLight.prototype.init = function() {\n\tvar button = document.createElement('button');\n  \tself = this;\n  \tthis.button = document.body.appendChild(button);\n  \tthis.button.innerHTML ='开关';\n  \tthis.currState = this.offLightState;\n    this.button.onclick = function() {\n      self.currState.buttonWasPressed();\n    }\n}\nLight.prototype.setState = function(newState) {\n  this.currState = newState;\n}\n```\n\n实际上，灯泡的状态最好是实现同一个接口或者抽象类，来强制开发者在每一个状态实现buttonWasPressed方法。\n\n#### 好处与用处\n\n虽然从上面的代码看到，状态模式可能进行一番苦力活写各种状态类，但是它可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类之中，便于阅读和管理代码。从一定程度上，也消除了大量的条件分支语句。即使后期需要增加一种状态，我们只需要增加一个新的状态类，并且增加一种状态切换的逻辑，不至于破坏“开合封闭原则”\n\n当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它行为时，就可以考虑使用状态模式了。\n\n#### 与策略模式的对比\n\n策略模式和状态模式很相似，它们都有一个上下文，一些策略或者状态类，上下文把请求委托给类来执行，从而消除了大量的条件分支语句。它们之间的区别是策略模式中的各个策略类是平等和平行的，它们之间没有任何联系，客户必须熟悉知道这些策略类的存在，由客户自己来随时主动切换算法。而在状态模式中，状态和状态对应的行为也一并封装好的，状态之间的切换也早被完成，”改变行为“这件事情发生在状态模式内部，因此客户无需了解这些细节。","slug":"状态模式","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwne000wcgeshju7sfgt","content":"<p>状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>\n<p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时情况，把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。</p>\n<h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Light = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.state = <span class=\"string\">'off'</span>;</div><div class=\"line\">  <span class=\"keyword\">this</span>.button = <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\">Light.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'button'</span>),</div><div class=\"line\">      self = <span class=\"keyword\">this</span>;</div><div class=\"line\">  button.innerHTML = <span class=\"string\">'开关'</span>;</div><div class=\"line\">  <span class=\"keyword\">this</span>.button = <span class=\"built_in\">document</span>.body.appendChild(button);</div><div class=\"line\">  <span class=\"keyword\">this</span>.button.onClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tself.buttonWasPressed();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Light.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state === <span class=\"string\">'off'</span>) &#123;</div><div class=\"line\">\t  <span class=\"built_in\">console</span>.log(<span class=\"string\">'开灯'</span>);</div><div class=\"line\">      <span class=\"keyword\">this</span>.state = <span class=\"string\">'on'</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state === <span class=\"string\">'on'</span>) &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'弱光'</span>);</div><div class=\"line\">      <span class=\"keyword\">this</span>.state = <span class=\"string\">'weakLight'</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === <span class=\"string\">'weakLight'</span>) &#123;</div><div class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">'弱光'</span>);</div><div class=\"line\">       <span class=\"keyword\">this</span>.state = <span class=\"string\">'strongLight'</span></div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === <span class=\"string\">'strongLight'</span>) &#123;</div><div class=\"line\">  \t  <span class=\"built_in\">console</span>.log(<span class=\"string\">'关灯'</span>);</div><div class=\"line\">      <span class=\"keyword\">this</span>.state = <span class=\"string\">'off'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> light = <span class=\"keyword\">new</span> Light();</div><div class=\"line\">light.init();</div></pre></td></tr></table></figure>\n<p>使用状态模式，将类的状态进行封装：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> OffLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.light = light;</div><div class=\"line\">&#125;</div><div class=\"line\">OffLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'弱光'</span>);</div><div class=\"line\">  <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.weakLightState);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> WeakLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>)</span>&#123;</div><div class=\"line\"> <span class=\"keyword\">this</span>.light = lightl </div><div class=\"line\">&#125;</div><div class=\"line\">WeakLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'强光'</span>);</div><div class=\"line\">  <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.strongLightState);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> StrongLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.light = light;</div><div class=\"line\">&#125;</div><div class=\"line\">StrongLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'关灯'</span>);</div><div class=\"line\">  <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.offLightState);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Light类</span></div><div class=\"line\"><span class=\"keyword\">var</span> Light = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.offLightState = <span class=\"keyword\">new</span> OffLightState(<span class=\"keyword\">this</span>);</div><div class=\"line\">  \t<span class=\"keyword\">this</span>.weakLightState = <span class=\"keyword\">new</span> WeakLightState(<span class=\"keyword\">this</span>);</div><div class=\"line\">  \t<span class=\"keyword\">this</span>.strongLightState = <span class=\"keyword\">new</span> StrongLightState(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.button = <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">Light.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'button'</span>);</div><div class=\"line\">  \tself = <span class=\"keyword\">this</span>;</div><div class=\"line\">  \t<span class=\"keyword\">this</span>.button = <span class=\"built_in\">document</span>.body.appendChild(button);</div><div class=\"line\">  \t<span class=\"keyword\">this</span>.button.innerHTML =<span class=\"string\">'开关'</span>;</div><div class=\"line\">  \t<span class=\"keyword\">this</span>.currState = <span class=\"keyword\">this</span>.offLightState;</div><div class=\"line\">    <span class=\"keyword\">this</span>.button.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      self.currState.buttonWasPressed();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Light.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newState</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.currState = newState;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，灯泡的状态最好是实现同一个接口或者抽象类，来强制开发者在每一个状态实现buttonWasPressed方法。</p>\n<h4 id=\"好处与用处\"><a href=\"#好处与用处\" class=\"headerlink\" title=\"好处与用处\"></a>好处与用处</h4><p>虽然从上面的代码看到，状态模式可能进行一番苦力活写各种状态类，但是它可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类之中，便于阅读和管理代码。从一定程度上，也消除了大量的条件分支语句。即使后期需要增加一种状态，我们只需要增加一个新的状态类，并且增加一种状态切换的逻辑，不至于破坏“开合封闭原则”</p>\n<p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它行为时，就可以考虑使用状态模式了。</p>\n<h4 id=\"与策略模式的对比\"><a href=\"#与策略模式的对比\" class=\"headerlink\" title=\"与策略模式的对比\"></a>与策略模式的对比</h4><p>策略模式和状态模式很相似，它们都有一个上下文，一些策略或者状态类，上下文把请求委托给类来执行，从而消除了大量的条件分支语句。它们之间的区别是策略模式中的各个策略类是平等和平行的，它们之间没有任何联系，客户必须熟悉知道这些策略类的存在，由客户自己来随时主动切换算法。而在状态模式中，状态和状态对应的行为也一并封装好的，状态之间的切换也早被完成，”改变行为“这件事情发生在状态模式内部，因此客户无需了解这些细节。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>状态模式：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。</p>\n<p>状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时情况，把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。</p>\n<h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> Light = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.state = <span class=\"string\">'off'</span>;</div><div class=\"line\">  <span class=\"keyword\">this</span>.button = <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\">Light.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'button'</span>),</div><div class=\"line\">      self = <span class=\"keyword\">this</span>;</div><div class=\"line\">  button.innerHTML = <span class=\"string\">'开关'</span>;</div><div class=\"line\">  <span class=\"keyword\">this</span>.button = <span class=\"built_in\">document</span>.body.appendChild(button);</div><div class=\"line\">  <span class=\"keyword\">this</span>.button.onClick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\tself.buttonWasPressed();</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Light.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state === <span class=\"string\">'off'</span>) &#123;</div><div class=\"line\">\t  <span class=\"built_in\">console</span>.log(<span class=\"string\">'开灯'</span>);</div><div class=\"line\">      <span class=\"keyword\">this</span>.state = <span class=\"string\">'on'</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span>(<span class=\"keyword\">this</span>.state === <span class=\"string\">'on'</span>) &#123;</div><div class=\"line\">      <span class=\"built_in\">console</span>.log(<span class=\"string\">'弱光'</span>);</div><div class=\"line\">      <span class=\"keyword\">this</span>.state = <span class=\"string\">'weakLight'</span></div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === <span class=\"string\">'weakLight'</span>) &#123;</div><div class=\"line\">       <span class=\"built_in\">console</span>.log(<span class=\"string\">'弱光'</span>);</div><div class=\"line\">       <span class=\"keyword\">this</span>.state = <span class=\"string\">'strongLight'</span></div><div class=\"line\">    &#125;<span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (<span class=\"keyword\">this</span>.state === <span class=\"string\">'strongLight'</span>) &#123;</div><div class=\"line\">  \t  <span class=\"built_in\">console</span>.log(<span class=\"string\">'关灯'</span>);</div><div class=\"line\">      <span class=\"keyword\">this</span>.state = <span class=\"string\">'off'</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> light = <span class=\"keyword\">new</span> Light();</div><div class=\"line\">light.init();</div></pre></td></tr></table></figure>\n<p>使用状态模式，将类的状态进行封装：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> OffLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.light = light;</div><div class=\"line\">&#125;</div><div class=\"line\">OffLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'弱光'</span>);</div><div class=\"line\">  <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.weakLightState);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> WeakLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>)</span>&#123;</div><div class=\"line\"> <span class=\"keyword\">this</span>.light = lightl </div><div class=\"line\">&#125;</div><div class=\"line\">WeakLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'强光'</span>);</div><div class=\"line\">  <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.strongLightState);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> StrongLightState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.light = light;</div><div class=\"line\">&#125;</div><div class=\"line\">StrongLightState.prototype.buttonWasPressed = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">light</span>) </span>&#123;</div><div class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'关灯'</span>);</div><div class=\"line\">  <span class=\"keyword\">this</span>.light.setState(<span class=\"keyword\">this</span>.light.offLightState);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Light类</span></div><div class=\"line\"><span class=\"keyword\">var</span> Light = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.offLightState = <span class=\"keyword\">new</span> OffLightState(<span class=\"keyword\">this</span>);</div><div class=\"line\">  \t<span class=\"keyword\">this</span>.weakLightState = <span class=\"keyword\">new</span> WeakLightState(<span class=\"keyword\">this</span>);</div><div class=\"line\">  \t<span class=\"keyword\">this</span>.strongLightState = <span class=\"keyword\">new</span> StrongLightState(<span class=\"keyword\">this</span>);</div><div class=\"line\">    <span class=\"keyword\">this</span>.button = <span class=\"literal\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\">Light.prototype.init = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">var</span> button = <span class=\"built_in\">document</span>.createElement(<span class=\"string\">'button'</span>);</div><div class=\"line\">  \tself = <span class=\"keyword\">this</span>;</div><div class=\"line\">  \t<span class=\"keyword\">this</span>.button = <span class=\"built_in\">document</span>.body.appendChild(button);</div><div class=\"line\">  \t<span class=\"keyword\">this</span>.button.innerHTML =<span class=\"string\">'开关'</span>;</div><div class=\"line\">  \t<span class=\"keyword\">this</span>.currState = <span class=\"keyword\">this</span>.offLightState;</div><div class=\"line\">    <span class=\"keyword\">this</span>.button.onclick = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">      self.currState.buttonWasPressed();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">Light.prototype.setState = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">newState</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.currState = newState;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>实际上，灯泡的状态最好是实现同一个接口或者抽象类，来强制开发者在每一个状态实现buttonWasPressed方法。</p>\n<h4 id=\"好处与用处\"><a href=\"#好处与用处\" class=\"headerlink\" title=\"好处与用处\"></a>好处与用处</h4><p>虽然从上面的代码看到，状态模式可能进行一番苦力活写各种状态类，但是它可以使每一种状态和它对应的行为之间的关系局部化，这些行为被分散和封装在各自对应的状态类之中，便于阅读和管理代码。从一定程度上，也消除了大量的条件分支语句。即使后期需要增加一种状态，我们只需要增加一个新的状态类，并且增加一种状态切换的逻辑，不至于破坏“开合封闭原则”</p>\n<p>当一个对象的行为取决于它的状态，并且它必须在运行时刻根据状态改变它行为时，就可以考虑使用状态模式了。</p>\n<h4 id=\"与策略模式的对比\"><a href=\"#与策略模式的对比\" class=\"headerlink\" title=\"与策略模式的对比\"></a>与策略模式的对比</h4><p>策略模式和状态模式很相似，它们都有一个上下文，一些策略或者状态类，上下文把请求委托给类来执行，从而消除了大量的条件分支语句。它们之间的区别是策略模式中的各个策略类是平等和平行的，它们之间没有任何联系，客户必须熟悉知道这些策略类的存在，由客户自己来随时主动切换算法。而在状态模式中，状态和状态对应的行为也一并封装好的，状态之间的切换也早被完成，”改变行为“这件事情发生在状态模式内部，因此客户无需了解这些细节。</p>\n"},{"title":"用Yeoman来创建我的web应用","date":"2015-08-11T15:13:58.000Z","_content":"\n最近在用AngularJS折腾些东西，打算写一个基于Angular的项目，打算手动创建时被告知可以用Yeoman来生成Angualr项目文件，于是乎去了解了一下Yeoman这玩意。\n\n> 官网显示Yeoman是一个现代Web app的脚手架工具，这里的脚手架就是说在开发者开发web应用的立项阶段，可以使用Yeoman来生成项目的文件和代码结构。\n\n### Yeoman实践\n\n- 和bower等类似，利用npm即可安装yeoman,只是安装时用不必打全称:\n\n  ```\n  npm install -g yo\n  ```\n\n  确认是否安装成功，若能显示版本号即安装成功\n\n  ```\n  yo -v\n  ```\n\n- 创建项目\n  在创建项目前，要先安装模具，比如这里我想要创建一个基于Angular的项目，我要先安装angular这个模具。yeoman官网有generator的列表，可以根据自己实际情况去看自己需要的模具。\n\n  ```\n  npm install -g generator-angular\n  ```\n\n此外，也可以使用yo命令，后选择安装模块来进行安装。\n\n安装完模块后，就可以开始创建项目了。进入自己的项目目录angualr-app文件夹，执行以下命令：\n\n```\nyo angular\n```\n\n在回答了一些问题后，就可以看到该目录生成了一系列的文件。\n[![img](http://ww1.sinaimg.cn/large/63739cabjw1ex9y2z3owzj20e40d7q3y.jpg)](http://ww1.sinaimg.cn/large/63739cabjw1ex9y2z3owzj20e40d7q3y.jpg)\napp/:web应用的父级目录。\nGruntfile.js、package.json 以及node_modules：Grunt需要使用的依赖以及配置。\ntest、karma.conf.js/karma-e2e.conf.js：测试框架以及针对这个项目的单元测试。\n\n- 运行创建好的初始应用\n\n  ```\n  grunt serve\n\n  ```\n\n  通过在浏览器访问localhost:9000就可以看到初始的应用了。\n\n通过yeoman创建好了我的项目结构后，就可以开始编写自己的应用啦\n\n另外再说一点：在用编辑器更改应用，每次保存更改后，浏览器会自动刷新，可以实时来查看应用的状态真的太赞了。","source":"_posts/用Yeoman来创建我的web应用.md","raw":"---\ntitle: 用Yeoman来创建我的web应用\ndate: 2015-08-11 23:13:58\ntags: 前端工具\n---\n\n最近在用AngularJS折腾些东西，打算写一个基于Angular的项目，打算手动创建时被告知可以用Yeoman来生成Angualr项目文件，于是乎去了解了一下Yeoman这玩意。\n\n> 官网显示Yeoman是一个现代Web app的脚手架工具，这里的脚手架就是说在开发者开发web应用的立项阶段，可以使用Yeoman来生成项目的文件和代码结构。\n\n### Yeoman实践\n\n- 和bower等类似，利用npm即可安装yeoman,只是安装时用不必打全称:\n\n  ```\n  npm install -g yo\n  ```\n\n  确认是否安装成功，若能显示版本号即安装成功\n\n  ```\n  yo -v\n  ```\n\n- 创建项目\n  在创建项目前，要先安装模具，比如这里我想要创建一个基于Angular的项目，我要先安装angular这个模具。yeoman官网有generator的列表，可以根据自己实际情况去看自己需要的模具。\n\n  ```\n  npm install -g generator-angular\n  ```\n\n此外，也可以使用yo命令，后选择安装模块来进行安装。\n\n安装完模块后，就可以开始创建项目了。进入自己的项目目录angualr-app文件夹，执行以下命令：\n\n```\nyo angular\n```\n\n在回答了一些问题后，就可以看到该目录生成了一系列的文件。\n[![img](http://ww1.sinaimg.cn/large/63739cabjw1ex9y2z3owzj20e40d7q3y.jpg)](http://ww1.sinaimg.cn/large/63739cabjw1ex9y2z3owzj20e40d7q3y.jpg)\napp/:web应用的父级目录。\nGruntfile.js、package.json 以及node_modules：Grunt需要使用的依赖以及配置。\ntest、karma.conf.js/karma-e2e.conf.js：测试框架以及针对这个项目的单元测试。\n\n- 运行创建好的初始应用\n\n  ```\n  grunt serve\n\n  ```\n\n  通过在浏览器访问localhost:9000就可以看到初始的应用了。\n\n通过yeoman创建好了我的项目结构后，就可以开始编写自己的应用啦\n\n另外再说一点：在用编辑器更改应用，每次保存更改后，浏览器会自动刷新，可以实时来查看应用的状态真的太赞了。","slug":"用Yeoman来创建我的web应用","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwnf000ycgeszxftby9k","content":"<p>最近在用AngularJS折腾些东西，打算写一个基于Angular的项目，打算手动创建时被告知可以用Yeoman来生成Angualr项目文件，于是乎去了解了一下Yeoman这玩意。</p>\n<blockquote>\n<p>官网显示Yeoman是一个现代Web app的脚手架工具，这里的脚手架就是说在开发者开发web应用的立项阶段，可以使用Yeoman来生成项目的文件和代码结构。</p>\n</blockquote>\n<h3 id=\"Yeoman实践\"><a href=\"#Yeoman实践\" class=\"headerlink\" title=\"Yeoman实践\"></a>Yeoman实践</h3><ul>\n<li><p>和bower等类似，利用npm即可安装yeoman,只是安装时用不必打全称:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g yo</div></pre></td></tr></table></figure>\n<p>确认是否安装成功，若能显示版本号即安装成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yo -v</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建项目<br>在创建项目前，要先安装模具，比如这里我想要创建一个基于Angular的项目，我要先安装angular这个模具。yeoman官网有generator的列表，可以根据自己实际情况去看自己需要的模具。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g generator-angular</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此外，也可以使用yo命令，后选择安装模块来进行安装。</p>\n<p>安装完模块后，就可以开始创建项目了。进入自己的项目目录angualr-app文件夹，执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yo angular</div></pre></td></tr></table></figure>\n<p>在回答了一些问题后，就可以看到该目录生成了一系列的文件。<br><a href=\"http://ww1.sinaimg.cn/large/63739cabjw1ex9y2z3owzj20e40d7q3y.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww1.sinaimg.cn/large/63739cabjw1ex9y2z3owzj20e40d7q3y.jpg\" alt=\"img\"></a><br>app/:web应用的父级目录。<br>Gruntfile.js、package.json 以及node_modules：Grunt需要使用的依赖以及配置。<br>test、karma.conf.js/karma-e2e.conf.js：测试框架以及针对这个项目的单元测试。</p>\n<ul>\n<li><p>运行创建好的初始应用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grunt serve</div></pre></td></tr></table></figure>\n<p>通过在浏览器访问localhost:9000就可以看到初始的应用了。</p>\n</li>\n</ul>\n<p>通过yeoman创建好了我的项目结构后，就可以开始编写自己的应用啦</p>\n<p>另外再说一点：在用编辑器更改应用，每次保存更改后，浏览器会自动刷新，可以实时来查看应用的状态真的太赞了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在用AngularJS折腾些东西，打算写一个基于Angular的项目，打算手动创建时被告知可以用Yeoman来生成Angualr项目文件，于是乎去了解了一下Yeoman这玩意。</p>\n<blockquote>\n<p>官网显示Yeoman是一个现代Web app的脚手架工具，这里的脚手架就是说在开发者开发web应用的立项阶段，可以使用Yeoman来生成项目的文件和代码结构。</p>\n</blockquote>\n<h3 id=\"Yeoman实践\"><a href=\"#Yeoman实践\" class=\"headerlink\" title=\"Yeoman实践\"></a>Yeoman实践</h3><ul>\n<li><p>和bower等类似，利用npm即可安装yeoman,只是安装时用不必打全称:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g yo</div></pre></td></tr></table></figure>\n<p>确认是否安装成功，若能显示版本号即安装成功</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yo -v</div></pre></td></tr></table></figure>\n</li>\n<li><p>创建项目<br>在创建项目前，要先安装模具，比如这里我想要创建一个基于Angular的项目，我要先安装angular这个模具。yeoman官网有generator的列表，可以根据自己实际情况去看自己需要的模具。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">npm install -g generator-angular</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>此外，也可以使用yo命令，后选择安装模块来进行安装。</p>\n<p>安装完模块后，就可以开始创建项目了。进入自己的项目目录angualr-app文件夹，执行以下命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yo angular</div></pre></td></tr></table></figure>\n<p>在回答了一些问题后，就可以看到该目录生成了一系列的文件。<br><a href=\"http://ww1.sinaimg.cn/large/63739cabjw1ex9y2z3owzj20e40d7q3y.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww1.sinaimg.cn/large/63739cabjw1ex9y2z3owzj20e40d7q3y.jpg\" alt=\"img\"></a><br>app/:web应用的父级目录。<br>Gruntfile.js、package.json 以及node_modules：Grunt需要使用的依赖以及配置。<br>test、karma.conf.js/karma-e2e.conf.js：测试框架以及针对这个项目的单元测试。</p>\n<ul>\n<li><p>运行创建好的初始应用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">grunt serve</div></pre></td></tr></table></figure>\n<p>通过在浏览器访问localhost:9000就可以看到初始的应用了。</p>\n</li>\n</ul>\n<p>通过yeoman创建好了我的项目结构后，就可以开始编写自己的应用啦</p>\n<p>另外再说一点：在用编辑器更改应用，每次保存更改后，浏览器会自动刷新，可以实时来查看应用的状态真的太赞了。</p>\n"},{"title":"javascript设计模式-策略模式","date":"2017-07-10T15:13:58.000Z","_content":"\n#### 定义\n\n它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。\n\n策略模式的目的就是将算法的使用与算法的实现分离开来。算法是随时可能互相替换的，这就是变化点，封装变化点是面向对象的一种很重要的思维方式。\n\n#### 栗子\n\n根据绩效考核等级确定员工的奖金\n\n```javascript\nvar calculateBonus = function(performanceLevel, salary) {\n\tif (performanceLevel === 'S') {\n\t\treturn salary * 4;\n    }\n    if (performanceLevel === 'A') {\n      \treturn salary * 4;\n    }\n  \tif (performanceLevel === 'B') {\n\t\treturn salary * 2;\n    }\n  }\ncalculateBonus('B', 20000);\ncalculateBonus('S', 6000);\n```\n\n用组合函数和策略模式改造后的代码（基于面向对象语言的模仿）：\n\n```javascript\n// 使用函数封装算法\nvar performanceS = function(){};\nperformanceS.prototype.calculate = function(salary) {\n  return salary * 4;\n};\nvar performanceA = function(){};\nperformanceA.prototype.calculate = function(salary) {\n  return salary * 3;\n}\nvar performaceB = function(){};\nperformanceB.prototype.calculate = function(salary) {\n  return salary * 2;\t\n}\n\n// 奖金类\nvar Bonus = function(){\n  this.salary = null; // 原始工资\n  this.strategy = null; //绩效等级对应的策略对象\n};\nBonus.prototype.setSalary = function(salary) {\n  this.salary = salary;\n}\nBonus.prototype.setStrategy = function(strategy) {\n  this.strategy = strategy;\n}\nBonus.prototype.getBonus = function() {\n  return this.strategy.calculate(this.salary);\n};\n\n// 计算奖金\nvar bonus = new Bonus();\nbonus.setSalary(10000);\nbonus.setStrategy(new performanceS());\nconsole.log(bonus.getBonus()); //40000\nbonus.setStrategy(new performanceA());\nconsole.log(bonus.getBonus()); //30000\n```\n\n基于Javascript版本的策略模式改造：\n\n```javascript\nvar strategies = {\n  \"S\": function(salary) {\n    return salary * 4;\n  },\n  \"A\": function(salary) {\n    return salary * 3;\t\n  },\n  \"B\": function(salary) {\n    return salary * 2;\t\n  }\n}\nvar calculateBonus = function(level, salary) {\n  return strategies[level](salary);\n}\nconsole.log(calculateBonus('S', 2000)); //8000\nconsole.log(calculateBonus('A', 10000)); // 30000\n\n```\n\n（其实第二种的实现简介了很多，但是一旦策略多了，也会变得和原始代码一样面临函数庞大的问题。所以这种只适用于算法较少且较简单的情况吧）\n\n#### 优点以及总结\n\n策略模式减少了各种算法与使用算法类之间的耦合。如果用面向对象语言的策略模式进行实现，每个算法都有自己的类，便于进行单元测试。当不同的行为堆砌在一个类或者函数中时，就很难避免使用条件语句来选择合适的行为，将这些行为封装在一个个独立的Stragtegy类中，可以在使用这些行为的类中消除条件语句。策略模式虽说是用来封装算法的，但是在实际中，我们可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。\n\n但是在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象，这本身并没有接触客户端需要选择判断的压力，而策略模式与简单工厂模式结合，选择具体实现的职责也可以由context来承担，这就最大化地减轻了客户端的职责。面对同样的需求，使用策略模式可以让改动更小。","source":"_posts/策略模式.md","raw":"---\ntitle: javascript设计模式-策略模式\ndate: 2017-7-10 23:13:58\ntags: 设计模式\n---\n\n#### 定义\n\n它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。\n\n策略模式的目的就是将算法的使用与算法的实现分离开来。算法是随时可能互相替换的，这就是变化点，封装变化点是面向对象的一种很重要的思维方式。\n\n#### 栗子\n\n根据绩效考核等级确定员工的奖金\n\n```javascript\nvar calculateBonus = function(performanceLevel, salary) {\n\tif (performanceLevel === 'S') {\n\t\treturn salary * 4;\n    }\n    if (performanceLevel === 'A') {\n      \treturn salary * 4;\n    }\n  \tif (performanceLevel === 'B') {\n\t\treturn salary * 2;\n    }\n  }\ncalculateBonus('B', 20000);\ncalculateBonus('S', 6000);\n```\n\n用组合函数和策略模式改造后的代码（基于面向对象语言的模仿）：\n\n```javascript\n// 使用函数封装算法\nvar performanceS = function(){};\nperformanceS.prototype.calculate = function(salary) {\n  return salary * 4;\n};\nvar performanceA = function(){};\nperformanceA.prototype.calculate = function(salary) {\n  return salary * 3;\n}\nvar performaceB = function(){};\nperformanceB.prototype.calculate = function(salary) {\n  return salary * 2;\t\n}\n\n// 奖金类\nvar Bonus = function(){\n  this.salary = null; // 原始工资\n  this.strategy = null; //绩效等级对应的策略对象\n};\nBonus.prototype.setSalary = function(salary) {\n  this.salary = salary;\n}\nBonus.prototype.setStrategy = function(strategy) {\n  this.strategy = strategy;\n}\nBonus.prototype.getBonus = function() {\n  return this.strategy.calculate(this.salary);\n};\n\n// 计算奖金\nvar bonus = new Bonus();\nbonus.setSalary(10000);\nbonus.setStrategy(new performanceS());\nconsole.log(bonus.getBonus()); //40000\nbonus.setStrategy(new performanceA());\nconsole.log(bonus.getBonus()); //30000\n```\n\n基于Javascript版本的策略模式改造：\n\n```javascript\nvar strategies = {\n  \"S\": function(salary) {\n    return salary * 4;\n  },\n  \"A\": function(salary) {\n    return salary * 3;\t\n  },\n  \"B\": function(salary) {\n    return salary * 2;\t\n  }\n}\nvar calculateBonus = function(level, salary) {\n  return strategies[level](salary);\n}\nconsole.log(calculateBonus('S', 2000)); //8000\nconsole.log(calculateBonus('A', 10000)); // 30000\n\n```\n\n（其实第二种的实现简介了很多，但是一旦策略多了，也会变得和原始代码一样面临函数庞大的问题。所以这种只适用于算法较少且较简单的情况吧）\n\n#### 优点以及总结\n\n策略模式减少了各种算法与使用算法类之间的耦合。如果用面向对象语言的策略模式进行实现，每个算法都有自己的类，便于进行单元测试。当不同的行为堆砌在一个类或者函数中时，就很难避免使用条件语句来选择合适的行为，将这些行为封装在一个个独立的Stragtegy类中，可以在使用这些行为的类中消除条件语句。策略模式虽说是用来封装算法的，但是在实际中，我们可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。\n\n但是在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象，这本身并没有接触客户端需要选择判断的压力，而策略模式与简单工厂模式结合，选择具体实现的职责也可以由context来承担，这就最大化地减轻了客户端的职责。面对同样的需求，使用策略模式可以让改动更小。","slug":"策略模式","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwnh0011cgesq0m52pwj","content":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p>\n<p>策略模式的目的就是将算法的使用与算法的实现分离开来。算法是随时可能互相替换的，这就是变化点，封装变化点是面向对象的一种很重要的思维方式。</p>\n<h4 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h4><p>根据绩效考核等级确定员工的奖金</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> calculateBonus = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">performanceLevel, salary</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (performanceLevel === <span class=\"string\">'S'</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> salary * <span class=\"number\">4</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (performanceLevel === <span class=\"string\">'A'</span>) &#123;</div><div class=\"line\">      \t<span class=\"keyword\">return</span> salary * <span class=\"number\">4</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  \t<span class=\"keyword\">if</span> (performanceLevel === <span class=\"string\">'B'</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> salary * <span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">calculateBonus(<span class=\"string\">'B'</span>, <span class=\"number\">20000</span>);</div><div class=\"line\">calculateBonus(<span class=\"string\">'S'</span>, <span class=\"number\">6000</span>);</div></pre></td></tr></table></figure>\n<p>用组合函数和策略模式改造后的代码（基于面向对象语言的模仿）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用函数封装算法</span></div><div class=\"line\"><span class=\"keyword\">var</span> performanceS = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">performanceS.prototype.calculate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> salary * <span class=\"number\">4</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> performanceA = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">performanceA.prototype.calculate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> salary * <span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> performaceB = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">performanceB.prototype.calculate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> salary * <span class=\"number\">2</span>;\t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 奖金类</span></div><div class=\"line\"><span class=\"keyword\">var</span> Bonus = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.salary = <span class=\"literal\">null</span>; <span class=\"comment\">// 原始工资</span></div><div class=\"line\">  <span class=\"keyword\">this</span>.strategy = <span class=\"literal\">null</span>; <span class=\"comment\">//绩效等级对应的策略对象</span></div><div class=\"line\">&#125;;</div><div class=\"line\">Bonus.prototype.setSalary = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.salary = salary;</div><div class=\"line\">&#125;</div><div class=\"line\">Bonus.prototype.setStrategy = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">strategy</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.strategy = strategy;</div><div class=\"line\">&#125;</div><div class=\"line\">Bonus.prototype.getBonus = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.strategy.calculate(<span class=\"keyword\">this</span>.salary);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 计算奖金</span></div><div class=\"line\"><span class=\"keyword\">var</span> bonus = <span class=\"keyword\">new</span> Bonus();</div><div class=\"line\">bonus.setSalary(<span class=\"number\">10000</span>);</div><div class=\"line\">bonus.setStrategy(<span class=\"keyword\">new</span> performanceS());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(bonus.getBonus()); <span class=\"comment\">//40000</span></div><div class=\"line\">bonus.setStrategy(<span class=\"keyword\">new</span> performanceA());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(bonus.getBonus()); <span class=\"comment\">//30000</span></div></pre></td></tr></table></figure>\n<p>基于Javascript版本的策略模式改造：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> strategies = &#123;</div><div class=\"line\">  <span class=\"string\">\"S\"</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> salary * <span class=\"number\">4</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"string\">\"A\"</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> salary * <span class=\"number\">3</span>;\t</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"string\">\"B\"</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> salary * <span class=\"number\">2</span>;\t</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> calculateBonus = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">level, salary</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> strategies[level](salary);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(calculateBonus(<span class=\"string\">'S'</span>, <span class=\"number\">2000</span>)); <span class=\"comment\">//8000</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(calculateBonus(<span class=\"string\">'A'</span>, <span class=\"number\">10000</span>)); <span class=\"comment\">// 30000</span></div></pre></td></tr></table></figure>\n<p>（其实第二种的实现简介了很多，但是一旦策略多了，也会变得和原始代码一样面临函数庞大的问题。所以这种只适用于算法较少且较简单的情况吧）</p>\n<h4 id=\"优点以及总结\"><a href=\"#优点以及总结\" class=\"headerlink\" title=\"优点以及总结\"></a>优点以及总结</h4><p>策略模式减少了各种算法与使用算法类之间的耦合。如果用面向对象语言的策略模式进行实现，每个算法都有自己的类，便于进行单元测试。当不同的行为堆砌在一个类或者函数中时，就很难避免使用条件语句来选择合适的行为，将这些行为封装在一个个独立的Stragtegy类中，可以在使用这些行为的类中消除条件语句。策略模式虽说是用来封装算法的，但是在实际中，我们可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。</p>\n<p>但是在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象，这本身并没有接触客户端需要选择判断的压力，而策略模式与简单工厂模式结合，选择具体实现的职责也可以由context来承担，这就最大化地减轻了客户端的职责。面对同样的需求，使用策略模式可以让改动更小。</p>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h4><p>它定义了算法家族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化，不会影响到使用算法的客户。</p>\n<p>策略模式的目的就是将算法的使用与算法的实现分离开来。算法是随时可能互相替换的，这就是变化点，封装变化点是面向对象的一种很重要的思维方式。</p>\n<h4 id=\"栗子\"><a href=\"#栗子\" class=\"headerlink\" title=\"栗子\"></a>栗子</h4><p>根据绩效考核等级确定员工的奖金</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> calculateBonus = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">performanceLevel, salary</span>) </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">if</span> (performanceLevel === <span class=\"string\">'S'</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> salary * <span class=\"number\">4</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span> (performanceLevel === <span class=\"string\">'A'</span>) &#123;</div><div class=\"line\">      \t<span class=\"keyword\">return</span> salary * <span class=\"number\">4</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  \t<span class=\"keyword\">if</span> (performanceLevel === <span class=\"string\">'B'</span>) &#123;</div><div class=\"line\">\t\t<span class=\"keyword\">return</span> salary * <span class=\"number\">2</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">calculateBonus(<span class=\"string\">'B'</span>, <span class=\"number\">20000</span>);</div><div class=\"line\">calculateBonus(<span class=\"string\">'S'</span>, <span class=\"number\">6000</span>);</div></pre></td></tr></table></figure>\n<p>用组合函数和策略模式改造后的代码（基于面向对象语言的模仿）：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">// 使用函数封装算法</span></div><div class=\"line\"><span class=\"keyword\">var</span> performanceS = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">performanceS.prototype.calculate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> salary * <span class=\"number\">4</span>;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">var</span> performanceA = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">performanceA.prototype.calculate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> salary * <span class=\"number\">3</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> performaceB = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;;</div><div class=\"line\">performanceB.prototype.calculate = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> salary * <span class=\"number\">2</span>;\t</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 奖金类</span></div><div class=\"line\"><span class=\"keyword\">var</span> Bonus = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.salary = <span class=\"literal\">null</span>; <span class=\"comment\">// 原始工资</span></div><div class=\"line\">  <span class=\"keyword\">this</span>.strategy = <span class=\"literal\">null</span>; <span class=\"comment\">//绩效等级对应的策略对象</span></div><div class=\"line\">&#125;;</div><div class=\"line\">Bonus.prototype.setSalary = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.salary = salary;</div><div class=\"line\">&#125;</div><div class=\"line\">Bonus.prototype.setStrategy = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">strategy</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">this</span>.strategy = strategy;</div><div class=\"line\">&#125;</div><div class=\"line\">Bonus.prototype.getBonus = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.strategy.calculate(<span class=\"keyword\">this</span>.salary);</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// 计算奖金</span></div><div class=\"line\"><span class=\"keyword\">var</span> bonus = <span class=\"keyword\">new</span> Bonus();</div><div class=\"line\">bonus.setSalary(<span class=\"number\">10000</span>);</div><div class=\"line\">bonus.setStrategy(<span class=\"keyword\">new</span> performanceS());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(bonus.getBonus()); <span class=\"comment\">//40000</span></div><div class=\"line\">bonus.setStrategy(<span class=\"keyword\">new</span> performanceA());</div><div class=\"line\"><span class=\"built_in\">console</span>.log(bonus.getBonus()); <span class=\"comment\">//30000</span></div></pre></td></tr></table></figure>\n<p>基于Javascript版本的策略模式改造：</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">var</span> strategies = &#123;</div><div class=\"line\">  <span class=\"string\">\"S\"</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> salary * <span class=\"number\">4</span>;</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"string\">\"A\"</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> salary * <span class=\"number\">3</span>;\t</div><div class=\"line\">  &#125;,</div><div class=\"line\">  <span class=\"string\">\"B\"</span>: <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">salary</span>) </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> salary * <span class=\"number\">2</span>;\t</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"keyword\">var</span> calculateBonus = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">level, salary</span>) </span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> strategies[level](salary);</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"built_in\">console</span>.log(calculateBonus(<span class=\"string\">'S'</span>, <span class=\"number\">2000</span>)); <span class=\"comment\">//8000</span></div><div class=\"line\"><span class=\"built_in\">console</span>.log(calculateBonus(<span class=\"string\">'A'</span>, <span class=\"number\">10000</span>)); <span class=\"comment\">// 30000</span></div></pre></td></tr></table></figure>\n<p>（其实第二种的实现简介了很多，但是一旦策略多了，也会变得和原始代码一样面临函数庞大的问题。所以这种只适用于算法较少且较简单的情况吧）</p>\n<h4 id=\"优点以及总结\"><a href=\"#优点以及总结\" class=\"headerlink\" title=\"优点以及总结\"></a>优点以及总结</h4><p>策略模式减少了各种算法与使用算法类之间的耦合。如果用面向对象语言的策略模式进行实现，每个算法都有自己的类，便于进行单元测试。当不同的行为堆砌在一个类或者函数中时，就很难避免使用条件语句来选择合适的行为，将这些行为封装在一个个独立的Stragtegy类中，可以在使用这些行为的类中消除条件语句。策略模式虽说是用来封装算法的，但是在实际中，我们可以用它来封装几乎任何类型的规则，只要在分析过程中听到需要在不同时间应用不同的业务规则，就可以考虑使用策略模式处理这种变化的可能性。</p>\n<p>但是在基本的策略模式中，选择所用具体实现的职责由客户端对象承担，并转给策略模式的Context对象，这本身并没有接触客户端需要选择判断的压力，而策略模式与简单工厂模式结合，选择具体实现的职责也可以由context来承担，这就最大化地减轻了客户端的职责。面对同样的需求，使用策略模式可以让改动更小。</p>\n"},{"title":"走在人生的夜路上","date":"2016-09-30T15:13:58.000Z","_content":"\n金九银十，人人繁忙。我忙忙碌碌，兜兜转转，最终却越发不知道自己要往哪里走。我不是一个乐观主义者，不会去抑制自己偶尔冒出的负面或悲伤的情绪，毕竟难过和开心都是平等的情绪，所以即使此时此刻我本不应该悠闲地在这书写生活，但是我知道不面对这个低谷去理一理自己的内心，自己便无法向前。\n\n我害怕对不起过去的自己和翩然而至的未来。但人生就是没有什么道理可循，即使我常常觉得自己不够努力，但有时却也不知道要努力到什么样的程度才足够。之所以努力，是想避免最后发现自己“本可以”，但是有时候现实却会变着法子给你一拳，把你做过的努力一拳粉碎。\n\n实习和校招的这段时间给我上了一课：人生并没有想象中的那么美好，在自己最狼狈的时候也许会脆弱得想哭，但是回过头发现自己咬咬牙已经走过了那么漫长和陡峭的道路,便发现了人生也没有想象中的那么糟糕。\n\n这两个月，前一个月常常是一下班以飞奔的速度赶回宿舍做在线笔试，后一个月为了赶赴面试，一来一回跑了好几趟大学城。这过程的确累，但是我也知道这是几乎所有应届毕业生都会经历的事。然而，每当我加班劳累在下班的路上，或者奔波劳碌结束了一场场面试时，就会思考这样的忙碌是否有意义。再后来，校招不尽如意的日子，每天早上醒来时，会思考自己曾经做过的选择是否是正确的。\n\n但现在想来选择或许根本就没有对错之分，无论面临多少次选择，一个人的性格往往决定了一个人会做什么样的选择。我害怕自己处于一种麻木的状态，每天都机械地做事，例行公事，无意义地按部就班，醒来和入睡前都感受到自己梦想匮乏，生活毫无目标和激情。更害怕自己渐渐对这种状态不自知，然后习惯了这种“安逸”的状态，而变得不愿意去改变和冲破。\n\n别人都说我还年轻，不必给自己太大的负担。其实，自己只是渴望那种能和他人一起前进和奋斗的时刻。我享受自我价值得到实现的那种成就感。也许有人会说我想要的太多，但是只有自己知道自己不是一个“安分”的人。相比于随波逐流，有所追求倒也不是什么坏事。起码它让我加班的时候感到的充实多于埋怨，让我在拥挤的求职人群中不那么胆怯和自卑，让我可以把忙碌之余的闲暇看作一种人生的馈赠而非人生的空虚和无聊。\n\n知乎有人问“如何走出人生低谷？”有人回答：“多走几步。”\n\n走在这条没有路灯亮起的夜路上，我其实也感到了一丝的恐惧。所幸的是发现了心里还有一盏灯为自己亮起，它的灯光或许有点微弱，但起码照亮了我现在脚下的路。哪怕现在没有一盏路灯为我亮起，那就凭借这自己心中的这盏灯再多走几步吧。最糟糕的事不过也是走完了一整个黑夜。\n\n毕竟，黑夜总会过去，黎明总会来临","source":"_posts/走在人生的夜路上.md","raw":"---\ntitle: 走在人生的夜路上\ndate: 2016-09-30 23:13:58\ntags: 杂谈\n---\n\n金九银十，人人繁忙。我忙忙碌碌，兜兜转转，最终却越发不知道自己要往哪里走。我不是一个乐观主义者，不会去抑制自己偶尔冒出的负面或悲伤的情绪，毕竟难过和开心都是平等的情绪，所以即使此时此刻我本不应该悠闲地在这书写生活，但是我知道不面对这个低谷去理一理自己的内心，自己便无法向前。\n\n我害怕对不起过去的自己和翩然而至的未来。但人生就是没有什么道理可循，即使我常常觉得自己不够努力，但有时却也不知道要努力到什么样的程度才足够。之所以努力，是想避免最后发现自己“本可以”，但是有时候现实却会变着法子给你一拳，把你做过的努力一拳粉碎。\n\n实习和校招的这段时间给我上了一课：人生并没有想象中的那么美好，在自己最狼狈的时候也许会脆弱得想哭，但是回过头发现自己咬咬牙已经走过了那么漫长和陡峭的道路,便发现了人生也没有想象中的那么糟糕。\n\n这两个月，前一个月常常是一下班以飞奔的速度赶回宿舍做在线笔试，后一个月为了赶赴面试，一来一回跑了好几趟大学城。这过程的确累，但是我也知道这是几乎所有应届毕业生都会经历的事。然而，每当我加班劳累在下班的路上，或者奔波劳碌结束了一场场面试时，就会思考这样的忙碌是否有意义。再后来，校招不尽如意的日子，每天早上醒来时，会思考自己曾经做过的选择是否是正确的。\n\n但现在想来选择或许根本就没有对错之分，无论面临多少次选择，一个人的性格往往决定了一个人会做什么样的选择。我害怕自己处于一种麻木的状态，每天都机械地做事，例行公事，无意义地按部就班，醒来和入睡前都感受到自己梦想匮乏，生活毫无目标和激情。更害怕自己渐渐对这种状态不自知，然后习惯了这种“安逸”的状态，而变得不愿意去改变和冲破。\n\n别人都说我还年轻，不必给自己太大的负担。其实，自己只是渴望那种能和他人一起前进和奋斗的时刻。我享受自我价值得到实现的那种成就感。也许有人会说我想要的太多，但是只有自己知道自己不是一个“安分”的人。相比于随波逐流，有所追求倒也不是什么坏事。起码它让我加班的时候感到的充实多于埋怨，让我在拥挤的求职人群中不那么胆怯和自卑，让我可以把忙碌之余的闲暇看作一种人生的馈赠而非人生的空虚和无聊。\n\n知乎有人问“如何走出人生低谷？”有人回答：“多走几步。”\n\n走在这条没有路灯亮起的夜路上，我其实也感到了一丝的恐惧。所幸的是发现了心里还有一盏灯为自己亮起，它的灯光或许有点微弱，但起码照亮了我现在脚下的路。哪怕现在没有一盏路灯为我亮起，那就凭借这自己心中的这盏灯再多走几步吧。最糟糕的事不过也是走完了一整个黑夜。\n\n毕竟，黑夜总会过去，黎明总会来临","slug":"走在人生的夜路上","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwnj0013cgesf9cbh17j","content":"<p>金九银十，人人繁忙。我忙忙碌碌，兜兜转转，最终却越发不知道自己要往哪里走。我不是一个乐观主义者，不会去抑制自己偶尔冒出的负面或悲伤的情绪，毕竟难过和开心都是平等的情绪，所以即使此时此刻我本不应该悠闲地在这书写生活，但是我知道不面对这个低谷去理一理自己的内心，自己便无法向前。</p>\n<p>我害怕对不起过去的自己和翩然而至的未来。但人生就是没有什么道理可循，即使我常常觉得自己不够努力，但有时却也不知道要努力到什么样的程度才足够。之所以努力，是想避免最后发现自己“本可以”，但是有时候现实却会变着法子给你一拳，把你做过的努力一拳粉碎。</p>\n<p>实习和校招的这段时间给我上了一课：人生并没有想象中的那么美好，在自己最狼狈的时候也许会脆弱得想哭，但是回过头发现自己咬咬牙已经走过了那么漫长和陡峭的道路,便发现了人生也没有想象中的那么糟糕。</p>\n<p>这两个月，前一个月常常是一下班以飞奔的速度赶回宿舍做在线笔试，后一个月为了赶赴面试，一来一回跑了好几趟大学城。这过程的确累，但是我也知道这是几乎所有应届毕业生都会经历的事。然而，每当我加班劳累在下班的路上，或者奔波劳碌结束了一场场面试时，就会思考这样的忙碌是否有意义。再后来，校招不尽如意的日子，每天早上醒来时，会思考自己曾经做过的选择是否是正确的。</p>\n<p>但现在想来选择或许根本就没有对错之分，无论面临多少次选择，一个人的性格往往决定了一个人会做什么样的选择。我害怕自己处于一种麻木的状态，每天都机械地做事，例行公事，无意义地按部就班，醒来和入睡前都感受到自己梦想匮乏，生活毫无目标和激情。更害怕自己渐渐对这种状态不自知，然后习惯了这种“安逸”的状态，而变得不愿意去改变和冲破。</p>\n<p>别人都说我还年轻，不必给自己太大的负担。其实，自己只是渴望那种能和他人一起前进和奋斗的时刻。我享受自我价值得到实现的那种成就感。也许有人会说我想要的太多，但是只有自己知道自己不是一个“安分”的人。相比于随波逐流，有所追求倒也不是什么坏事。起码它让我加班的时候感到的充实多于埋怨，让我在拥挤的求职人群中不那么胆怯和自卑，让我可以把忙碌之余的闲暇看作一种人生的馈赠而非人生的空虚和无聊。</p>\n<p>知乎有人问“如何走出人生低谷？”有人回答：“多走几步。”</p>\n<p>走在这条没有路灯亮起的夜路上，我其实也感到了一丝的恐惧。所幸的是发现了心里还有一盏灯为自己亮起，它的灯光或许有点微弱，但起码照亮了我现在脚下的路。哪怕现在没有一盏路灯为我亮起，那就凭借这自己心中的这盏灯再多走几步吧。最糟糕的事不过也是走完了一整个黑夜。</p>\n<p>毕竟，黑夜总会过去，黎明总会来临</p>\n","site":{"data":{}},"excerpt":"","more":"<p>金九银十，人人繁忙。我忙忙碌碌，兜兜转转，最终却越发不知道自己要往哪里走。我不是一个乐观主义者，不会去抑制自己偶尔冒出的负面或悲伤的情绪，毕竟难过和开心都是平等的情绪，所以即使此时此刻我本不应该悠闲地在这书写生活，但是我知道不面对这个低谷去理一理自己的内心，自己便无法向前。</p>\n<p>我害怕对不起过去的自己和翩然而至的未来。但人生就是没有什么道理可循，即使我常常觉得自己不够努力，但有时却也不知道要努力到什么样的程度才足够。之所以努力，是想避免最后发现自己“本可以”，但是有时候现实却会变着法子给你一拳，把你做过的努力一拳粉碎。</p>\n<p>实习和校招的这段时间给我上了一课：人生并没有想象中的那么美好，在自己最狼狈的时候也许会脆弱得想哭，但是回过头发现自己咬咬牙已经走过了那么漫长和陡峭的道路,便发现了人生也没有想象中的那么糟糕。</p>\n<p>这两个月，前一个月常常是一下班以飞奔的速度赶回宿舍做在线笔试，后一个月为了赶赴面试，一来一回跑了好几趟大学城。这过程的确累，但是我也知道这是几乎所有应届毕业生都会经历的事。然而，每当我加班劳累在下班的路上，或者奔波劳碌结束了一场场面试时，就会思考这样的忙碌是否有意义。再后来，校招不尽如意的日子，每天早上醒来时，会思考自己曾经做过的选择是否是正确的。</p>\n<p>但现在想来选择或许根本就没有对错之分，无论面临多少次选择，一个人的性格往往决定了一个人会做什么样的选择。我害怕自己处于一种麻木的状态，每天都机械地做事，例行公事，无意义地按部就班，醒来和入睡前都感受到自己梦想匮乏，生活毫无目标和激情。更害怕自己渐渐对这种状态不自知，然后习惯了这种“安逸”的状态，而变得不愿意去改变和冲破。</p>\n<p>别人都说我还年轻，不必给自己太大的负担。其实，自己只是渴望那种能和他人一起前进和奋斗的时刻。我享受自我价值得到实现的那种成就感。也许有人会说我想要的太多，但是只有自己知道自己不是一个“安分”的人。相比于随波逐流，有所追求倒也不是什么坏事。起码它让我加班的时候感到的充实多于埋怨，让我在拥挤的求职人群中不那么胆怯和自卑，让我可以把忙碌之余的闲暇看作一种人生的馈赠而非人生的空虚和无聊。</p>\n<p>知乎有人问“如何走出人生低谷？”有人回答：“多走几步。”</p>\n<p>走在这条没有路灯亮起的夜路上，我其实也感到了一丝的恐惧。所幸的是发现了心里还有一盏灯为自己亮起，它的灯光或许有点微弱，但起码照亮了我现在脚下的路。哪怕现在没有一盏路灯为我亮起，那就凭借这自己心中的这盏灯再多走几步吧。最糟糕的事不过也是走完了一整个黑夜。</p>\n<p>毕竟，黑夜总会过去，黎明总会来临</p>\n"},{"title":"面向对象编程的SOLID原则","date":"2017-07-08T15:13:58.000Z","_content":"\nJavascript虽然与传统的面向对象编程语言Java有所不同，但是其设计模式都是围绕着SOLID原则，以便更容易创建可维护和可拓展的系统。\n\n- 单一职责原则（SRP）：表明软件组件（函数、类、模块）必须庄主与单一的任务（只有单一的职责）\n- 开/闭原则（OCP）：表明软件设计时必须时刻考虑到（代码）可能的发展（具有的拓展性），但是程序的发展必须最少地修改已有的代码（对已有的修改封闭）\n- 里氏替换原则（LSP）：表明只要继承的是同一个接口，程序的任意一个类都可以被其它类替换。在替换完成后，不需要其它额外的工作程序就能像原来一样运行。\n- 接口隔离原则（ISP）：表明我们应该将那些非常大的接口（大而全的接口）拆分成一些小的更具体的接口，这样客户端就只需关心它们需要用到的接口。\n- 依赖反转原则（DIP）：表明一个方法应该遵从依赖于抽象（接口）而不是一个实例（类）的概念。","source":"_posts/面向对象编程的SOLID原则.md","raw":"---\ntitle: 面向对象编程的SOLID原则\ndate: 2017-7-8 23:13:58\ntags: 设计模式\n---\n\nJavascript虽然与传统的面向对象编程语言Java有所不同，但是其设计模式都是围绕着SOLID原则，以便更容易创建可维护和可拓展的系统。\n\n- 单一职责原则（SRP）：表明软件组件（函数、类、模块）必须庄主与单一的任务（只有单一的职责）\n- 开/闭原则（OCP）：表明软件设计时必须时刻考虑到（代码）可能的发展（具有的拓展性），但是程序的发展必须最少地修改已有的代码（对已有的修改封闭）\n- 里氏替换原则（LSP）：表明只要继承的是同一个接口，程序的任意一个类都可以被其它类替换。在替换完成后，不需要其它额外的工作程序就能像原来一样运行。\n- 接口隔离原则（ISP）：表明我们应该将那些非常大的接口（大而全的接口）拆分成一些小的更具体的接口，这样客户端就只需关心它们需要用到的接口。\n- 依赖反转原则（DIP）：表明一个方法应该遵从依赖于抽象（接口）而不是一个实例（类）的概念。","slug":"面向对象编程的SOLID原则","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwnk0016cgesgf6ij9pa","content":"<p>Javascript虽然与传统的面向对象编程语言Java有所不同，但是其设计模式都是围绕着SOLID原则，以便更容易创建可维护和可拓展的系统。</p>\n<ul>\n<li>单一职责原则（SRP）：表明软件组件（函数、类、模块）必须庄主与单一的任务（只有单一的职责）</li>\n<li>开/闭原则（OCP）：表明软件设计时必须时刻考虑到（代码）可能的发展（具有的拓展性），但是程序的发展必须最少地修改已有的代码（对已有的修改封闭）</li>\n<li>里氏替换原则（LSP）：表明只要继承的是同一个接口，程序的任意一个类都可以被其它类替换。在替换完成后，不需要其它额外的工作程序就能像原来一样运行。</li>\n<li>接口隔离原则（ISP）：表明我们应该将那些非常大的接口（大而全的接口）拆分成一些小的更具体的接口，这样客户端就只需关心它们需要用到的接口。</li>\n<li>依赖反转原则（DIP）：表明一个方法应该遵从依赖于抽象（接口）而不是一个实例（类）的概念。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Javascript虽然与传统的面向对象编程语言Java有所不同，但是其设计模式都是围绕着SOLID原则，以便更容易创建可维护和可拓展的系统。</p>\n<ul>\n<li>单一职责原则（SRP）：表明软件组件（函数、类、模块）必须庄主与单一的任务（只有单一的职责）</li>\n<li>开/闭原则（OCP）：表明软件设计时必须时刻考虑到（代码）可能的发展（具有的拓展性），但是程序的发展必须最少地修改已有的代码（对已有的修改封闭）</li>\n<li>里氏替换原则（LSP）：表明只要继承的是同一个接口，程序的任意一个类都可以被其它类替换。在替换完成后，不需要其它额外的工作程序就能像原来一样运行。</li>\n<li>接口隔离原则（ISP）：表明我们应该将那些非常大的接口（大而全的接口）拆分成一些小的更具体的接口，这样客户端就只需关心它们需要用到的接口。</li>\n<li>依赖反转原则（DIP）：表明一个方法应该遵从依赖于抽象（接口）而不是一个实例（类）的概念。</li>\n</ul>\n"},{"title":"项目总结-wps","date":"2017-04-01T15:13:58.000Z","_content":"\n在某群实习的最后一个项目，暂且叫它wps吧，是一个用于针对H5页面的性能分析平台，主要技术栈是react+redux+webpack+antd。其中前端用的是dva框架，后端用的是egg.js框架。虽然做这个项目的过程遇到不少困难，但是还是很感激当时能有机会接触这个项目，让我可以学到了一些性能分析的技巧和内核的知识。另外在老大的手下做事虽然不轻松，但是也感谢实习期间能遇到了一位愿意耐心指导的导师，告诉我怎么学习怎么成长。最后的最后，在离开之际整理了一下最后一个月重构工作的一些收获吧。\n\n### React应用性能分析与优化\n\n虽然react解决了在state变化时自动刷新界面，且虚拟DOM（diff算法）也在一定程度减少了重绘的成本。但react也不是无敌的，首先，虚拟DOM的对比也是需要成本的，其次，react发生render的情况不一定符合你的预期。\n[![img](http://ww1.sinaimg.cn/large/63739cabgy1fe5t7hfayzj20je06twgv.jpg)](http://ww1.sinaimg.cn/large/63739cabgy1fe5t7hfayzj20je06twgv.jpg)\n\nreact的每个组件在生命周期里会调用shouldComponentUpdate(object nextProps, object nextState)函数，该函数返回true表示需要更新，需要更新的会调用render生成新的虚拟DOM，false表示不需要。react对此函数默认返回true，（即使没有显示地定义shouldCompnentUpdate函数），即React默认总是进行虚拟DOM的比较，无论真实DOM是否需要被重新渲染。\n\nIn conclusion,对react应用进行性能优化的入口点有两个：\n\n- 减少不必要的render调用\n- 减少虚拟DOM对比的成本\n\n### 性能检测手段\n\nreact官方提供了React.addons.Perf来帮助分析组件的性能。\n\n- 执行操作前，调用React.addons.Perf.start()\n- 执行操作后，调用React.addons.Perf.stop()\n- printWasted()：查看浪费（即组件render前后保持不变，但是却花费了时间进行虚拟DOM的比较），性能分析中最有用的一个方法。\n- printInclusive()：查看组件花费的总时间，可以帮我们找出哪个组件是性能瓶颈。\n- 查看React对DOM的操作情况，调用React.addons.Rerf.printDOM()查看React对DOM的操作情况\n\n更多API见 [React官方文档](https://facebook.github.io/react/docs/perf.html)\n\n### 性能优化\n\n**场景实践-减少不必要的react render**\n一开始重构WPS时，发现创建分析模块的表单操作起来异常卡顿。虽然当时子杰对AnalyseRule这个组件的SCU进行重写，改善了表单的卡顿现象，但是现在回过头来屡下思路是必要的。\n下图是没有进行任何优化处理的表单进行的检测情况，在分析模块规则的一个输入框输入内容的组件渲染情况。\n[![bad](http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/2f49f8a02e8928ce7dcf3ca1d38e66a2/bad.png)](http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/2f49f8a02e8928ce7dcf3ca1d38e66a2/bad.png)bad\n输入规则的时候，每次输入，事件监听到内容发生变化，redux那边会dispatch一个setRuleData的action来改变analyse这个state的createData（更具体地说是createData的rules下的某个对象的某个域的值得改变），更新后的state从容器组件（analyse/modules/detail）传进去后，其子组件的props实际发生了改变。\n通过代码或者printDOM()方法，知道其数据流向大致如下：\n\n[![img](http://ww1.sinaimg.cn/large/63739cabgy1fe607m1ezyj205x0a5jrc.jpg)](http://ww1.sinaimg.cn/large/63739cabgy1fe607m1ezyj205x0a5jrc.jpg)\n\n如果现在编辑的分析模块有X个分析规则，X个分析规则又有S个规则条件，当我改变了某个分析规则的某个规则条件的时候，所有其它无辜的分析规则和他们的规则条件也一起被重新render了。\n如果我编辑了某条规则，我不想让其它无辜分析规则也render呢？\n\n```javascript\nshouldComponentUpdate(nextProps) {\nreturn !is(fromJS(nextProps.data), fromJS(this.props.data)) || this.props.disabled !== nextProps.disabled;\n}\n```\n\n\n\n因为当父组件的状态state发生变化时，传入state的子组件都会进行重新渲染的前提下。\n这段代码，就实现了只在这个规则的数据发生变化，不影响其它实际一动也不动的分析规则进行生成虚拟DOM并且对比balabla。\n\n所以在AnalyseRule和ConditionItem重载组件的shouldComponentUpdate后，再用性能分析工具检测一下成果：\n**同样的操作（一个分析模块，两个分析规则，改变其中一个分析规则的规则条件的字段输入框），时间从143ms减少到69ms，影响的DOM操作从15个减少到6个，即只会让自身所在的分析规则发生虚拟DOMrender。**\n[![2017-03-31_144443](http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/d5d0376b3f838f21c77939d6d64fdbec/2017-03-31_144443.png)](http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/d5d0376b3f838f21c77939d6d64fdbec/2017-03-31_144443.png)2017-03-31_144443\n\n**关于immutable**\n\n在上面的shouldComponentUpdate可以看到数据的对比是用了immutable，如果不用immutable会怎样？\njs数据类型分为基本类型和引用类型。如果直接比较两个对象，实际比较的是他们的指向，即使我们改变了它们的内容，指向不发生改变，那么比较的结果就是没变，导致优化失效。所以这里的比较必须是深比较，但是deepCompare是非常消耗性能的。而immutable可以很好地解决这些问题。\nimmutable的实现原理是持久化数据结构（具体看[immutable详解以及React中的事件](https://github.com/camsong/blog/issues/3)），减低了深比较的成本。另外immutable提高了简洁高效判断数据是否变化的方法`is`.\n\n以前除去SCU这里的场景，immutable在数据流的应用也起到了很大的作用。\n虽然immutable是一个重型库，但是在大型应用中引入是有价值的，它可以除去了复杂应用中可变数据带来的隐患。\n\n总结-react比较好的实践：\n\n- 即使组件之后被复用的机会很小，也不要将复杂的组件在一个组件写完。\n- props和state的数据尽可能简单扁平化。\n- {…this.props}不滥用，只传组件需要的数据，减少shouldComponentUpdate进行数据比较的负担。\n- map的组件要用key，刚刚才发现用可变的index对性能优化是没有半点作用的（WPS有几处是用index做key的，这个要改@-@），具体原因可以看下面两篇比较好的文章\n- [key属性的原理和用法](http://taobaofed.org/blog/2016/08/24/react-key/)\n- [使用Perf工具研究React Key对渲染的影响](http://levy.work/2016-08-31-debug-react-key-with-performance-tool/)\n\n### 产品设计和用户体验\n\n因为WPS是没有专门的产品的，研发就是产品经理。但开发过程习惯了从研发的角度去思考。\n\n#### 表单\n\n因为该项目类似与管理后台系统，多处都需要用户填写表单（创建分析模块，创建评估报告等等）。表单这一块是与用户交互最频繁的组件之一了。而表单的优化有几点：\n\n- 良好的用户提示和反馈，可以减少用户提交表单的成功率（placeholder,以及antd附带的hasFeedback功能）\n- 给输入项设置默认值，自动填充，自动补全，自动聚焦，可以减少用户输入的时间。\n\n其它与业务相关的：\n\n- 编辑分析模块的时候，有分析规则包含了关联规则，有些没有，区分两者的区别可以加快用户的编辑操作，从而提高用户体验。\n\n#### 任务等待\n\n除了创建和编辑表单，另外一个重要的使用场景就是查看评估报告。刚创建完评估报告后，需要用户等待分析服务分析完才能看到结果。最初的版本是需要用户手动刷新才能看到任务的最新状态，于是后来就提供了一个按钮，用户点击后发起异步请求，到后来按钮也不要，直接自动在一定时间间隔内发生请求，获取最新的状态信息。\n优化的过程得到的教训：\n\n> 减少用户的非必要的主动操作。像F5重刷页面和提供刷新按钮进行局部刷新，也许技术上有点差异，但是从用户体验角度，其实毫无差异。\n\n另外，对于等待这件事，如果可以不断给予用户当前状态的反馈，会大大提升用户的体验。比如任务结果等待还可以进行的优化是，提供任务大概还要运行的时间..（即使技术上不能百分百确定还需等待的时间，但“欺骗”用户的交互设计窍门也是值得借鉴的）[用户体验设计中有哪些针对「等待」的设计的好例子？](https://www.zhihu.com/question/20064203)\n\n总结：\n优化用户体验的核心尽量使得产品变得易用（易于上手，减少使用遇到的挫折），实用和使用过程保证用户的满意度（保证操作和使用的效率）。总而言之，学会从使用者的角度去考虑产品（这点说起来很简单，但因为是很主观性的东西，其实实际很难考虑全面，但是尽量做到“don’t make me think , don’t make me unconfortable”吧）。\n\n### 测试\n\n项目开发中，多次因为测试不到位引发的事故。然而，测试真的并不是一件易事，但它也是有章法可循的。\n而测试前应该要先明确测试用例。从慧贤那里学到了书写测试用例最常用的方法是将模块从上到下进行拆分，每个模块有自己单独的用例，模块与模块之间有连接的用例，页面和页面之间交互的用例等…\n\n**测试用例设计方法**\n\n- 黑盒测试用例设计（常用的是等价类划分和边界值分析）<http://www.cnblogs.com/Carolinee/p/5531971.html>\n- 白盒测试用例设计（适用于开发人员，包括语句覆盖，判断覆盖，条件覆盖等..）<http://www.cnblogs.com/Carolinee/p/5404675.html>\n\n总结：\n测试最主要还是要细心细致。而这个过程中还是觉得自己有点粗心大意。另外，手工测试依旧会有缺漏，学习下自动化测试还是很有必要的。","source":"_posts/项目总结-wps.md","raw":"---\ntitle: 项目总结-wps\ndate: 2017-4-1 23:13:58\ntags: 实战总结\n---\n\n在某群实习的最后一个项目，暂且叫它wps吧，是一个用于针对H5页面的性能分析平台，主要技术栈是react+redux+webpack+antd。其中前端用的是dva框架，后端用的是egg.js框架。虽然做这个项目的过程遇到不少困难，但是还是很感激当时能有机会接触这个项目，让我可以学到了一些性能分析的技巧和内核的知识。另外在老大的手下做事虽然不轻松，但是也感谢实习期间能遇到了一位愿意耐心指导的导师，告诉我怎么学习怎么成长。最后的最后，在离开之际整理了一下最后一个月重构工作的一些收获吧。\n\n### React应用性能分析与优化\n\n虽然react解决了在state变化时自动刷新界面，且虚拟DOM（diff算法）也在一定程度减少了重绘的成本。但react也不是无敌的，首先，虚拟DOM的对比也是需要成本的，其次，react发生render的情况不一定符合你的预期。\n[![img](http://ww1.sinaimg.cn/large/63739cabgy1fe5t7hfayzj20je06twgv.jpg)](http://ww1.sinaimg.cn/large/63739cabgy1fe5t7hfayzj20je06twgv.jpg)\n\nreact的每个组件在生命周期里会调用shouldComponentUpdate(object nextProps, object nextState)函数，该函数返回true表示需要更新，需要更新的会调用render生成新的虚拟DOM，false表示不需要。react对此函数默认返回true，（即使没有显示地定义shouldCompnentUpdate函数），即React默认总是进行虚拟DOM的比较，无论真实DOM是否需要被重新渲染。\n\nIn conclusion,对react应用进行性能优化的入口点有两个：\n\n- 减少不必要的render调用\n- 减少虚拟DOM对比的成本\n\n### 性能检测手段\n\nreact官方提供了React.addons.Perf来帮助分析组件的性能。\n\n- 执行操作前，调用React.addons.Perf.start()\n- 执行操作后，调用React.addons.Perf.stop()\n- printWasted()：查看浪费（即组件render前后保持不变，但是却花费了时间进行虚拟DOM的比较），性能分析中最有用的一个方法。\n- printInclusive()：查看组件花费的总时间，可以帮我们找出哪个组件是性能瓶颈。\n- 查看React对DOM的操作情况，调用React.addons.Rerf.printDOM()查看React对DOM的操作情况\n\n更多API见 [React官方文档](https://facebook.github.io/react/docs/perf.html)\n\n### 性能优化\n\n**场景实践-减少不必要的react render**\n一开始重构WPS时，发现创建分析模块的表单操作起来异常卡顿。虽然当时子杰对AnalyseRule这个组件的SCU进行重写，改善了表单的卡顿现象，但是现在回过头来屡下思路是必要的。\n下图是没有进行任何优化处理的表单进行的检测情况，在分析模块规则的一个输入框输入内容的组件渲染情况。\n[![bad](http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/2f49f8a02e8928ce7dcf3ca1d38e66a2/bad.png)](http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/2f49f8a02e8928ce7dcf3ca1d38e66a2/bad.png)bad\n输入规则的时候，每次输入，事件监听到内容发生变化，redux那边会dispatch一个setRuleData的action来改变analyse这个state的createData（更具体地说是createData的rules下的某个对象的某个域的值得改变），更新后的state从容器组件（analyse/modules/detail）传进去后，其子组件的props实际发生了改变。\n通过代码或者printDOM()方法，知道其数据流向大致如下：\n\n[![img](http://ww1.sinaimg.cn/large/63739cabgy1fe607m1ezyj205x0a5jrc.jpg)](http://ww1.sinaimg.cn/large/63739cabgy1fe607m1ezyj205x0a5jrc.jpg)\n\n如果现在编辑的分析模块有X个分析规则，X个分析规则又有S个规则条件，当我改变了某个分析规则的某个规则条件的时候，所有其它无辜的分析规则和他们的规则条件也一起被重新render了。\n如果我编辑了某条规则，我不想让其它无辜分析规则也render呢？\n\n```javascript\nshouldComponentUpdate(nextProps) {\nreturn !is(fromJS(nextProps.data), fromJS(this.props.data)) || this.props.disabled !== nextProps.disabled;\n}\n```\n\n\n\n因为当父组件的状态state发生变化时，传入state的子组件都会进行重新渲染的前提下。\n这段代码，就实现了只在这个规则的数据发生变化，不影响其它实际一动也不动的分析规则进行生成虚拟DOM并且对比balabla。\n\n所以在AnalyseRule和ConditionItem重载组件的shouldComponentUpdate后，再用性能分析工具检测一下成果：\n**同样的操作（一个分析模块，两个分析规则，改变其中一个分析规则的规则条件的字段输入框），时间从143ms减少到69ms，影响的DOM操作从15个减少到6个，即只会让自身所在的分析规则发生虚拟DOMrender。**\n[![2017-03-31_144443](http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/d5d0376b3f838f21c77939d6d64fdbec/2017-03-31_144443.png)](http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/d5d0376b3f838f21c77939d6d64fdbec/2017-03-31_144443.png)2017-03-31_144443\n\n**关于immutable**\n\n在上面的shouldComponentUpdate可以看到数据的对比是用了immutable，如果不用immutable会怎样？\njs数据类型分为基本类型和引用类型。如果直接比较两个对象，实际比较的是他们的指向，即使我们改变了它们的内容，指向不发生改变，那么比较的结果就是没变，导致优化失效。所以这里的比较必须是深比较，但是deepCompare是非常消耗性能的。而immutable可以很好地解决这些问题。\nimmutable的实现原理是持久化数据结构（具体看[immutable详解以及React中的事件](https://github.com/camsong/blog/issues/3)），减低了深比较的成本。另外immutable提高了简洁高效判断数据是否变化的方法`is`.\n\n以前除去SCU这里的场景，immutable在数据流的应用也起到了很大的作用。\n虽然immutable是一个重型库，但是在大型应用中引入是有价值的，它可以除去了复杂应用中可变数据带来的隐患。\n\n总结-react比较好的实践：\n\n- 即使组件之后被复用的机会很小，也不要将复杂的组件在一个组件写完。\n- props和state的数据尽可能简单扁平化。\n- {…this.props}不滥用，只传组件需要的数据，减少shouldComponentUpdate进行数据比较的负担。\n- map的组件要用key，刚刚才发现用可变的index对性能优化是没有半点作用的（WPS有几处是用index做key的，这个要改@-@），具体原因可以看下面两篇比较好的文章\n- [key属性的原理和用法](http://taobaofed.org/blog/2016/08/24/react-key/)\n- [使用Perf工具研究React Key对渲染的影响](http://levy.work/2016-08-31-debug-react-key-with-performance-tool/)\n\n### 产品设计和用户体验\n\n因为WPS是没有专门的产品的，研发就是产品经理。但开发过程习惯了从研发的角度去思考。\n\n#### 表单\n\n因为该项目类似与管理后台系统，多处都需要用户填写表单（创建分析模块，创建评估报告等等）。表单这一块是与用户交互最频繁的组件之一了。而表单的优化有几点：\n\n- 良好的用户提示和反馈，可以减少用户提交表单的成功率（placeholder,以及antd附带的hasFeedback功能）\n- 给输入项设置默认值，自动填充，自动补全，自动聚焦，可以减少用户输入的时间。\n\n其它与业务相关的：\n\n- 编辑分析模块的时候，有分析规则包含了关联规则，有些没有，区分两者的区别可以加快用户的编辑操作，从而提高用户体验。\n\n#### 任务等待\n\n除了创建和编辑表单，另外一个重要的使用场景就是查看评估报告。刚创建完评估报告后，需要用户等待分析服务分析完才能看到结果。最初的版本是需要用户手动刷新才能看到任务的最新状态，于是后来就提供了一个按钮，用户点击后发起异步请求，到后来按钮也不要，直接自动在一定时间间隔内发生请求，获取最新的状态信息。\n优化的过程得到的教训：\n\n> 减少用户的非必要的主动操作。像F5重刷页面和提供刷新按钮进行局部刷新，也许技术上有点差异，但是从用户体验角度，其实毫无差异。\n\n另外，对于等待这件事，如果可以不断给予用户当前状态的反馈，会大大提升用户的体验。比如任务结果等待还可以进行的优化是，提供任务大概还要运行的时间..（即使技术上不能百分百确定还需等待的时间，但“欺骗”用户的交互设计窍门也是值得借鉴的）[用户体验设计中有哪些针对「等待」的设计的好例子？](https://www.zhihu.com/question/20064203)\n\n总结：\n优化用户体验的核心尽量使得产品变得易用（易于上手，减少使用遇到的挫折），实用和使用过程保证用户的满意度（保证操作和使用的效率）。总而言之，学会从使用者的角度去考虑产品（这点说起来很简单，但因为是很主观性的东西，其实实际很难考虑全面，但是尽量做到“don’t make me think , don’t make me unconfortable”吧）。\n\n### 测试\n\n项目开发中，多次因为测试不到位引发的事故。然而，测试真的并不是一件易事，但它也是有章法可循的。\n而测试前应该要先明确测试用例。从慧贤那里学到了书写测试用例最常用的方法是将模块从上到下进行拆分，每个模块有自己单独的用例，模块与模块之间有连接的用例，页面和页面之间交互的用例等…\n\n**测试用例设计方法**\n\n- 黑盒测试用例设计（常用的是等价类划分和边界值分析）<http://www.cnblogs.com/Carolinee/p/5531971.html>\n- 白盒测试用例设计（适用于开发人员，包括语句覆盖，判断覆盖，条件覆盖等..）<http://www.cnblogs.com/Carolinee/p/5404675.html>\n\n总结：\n测试最主要还是要细心细致。而这个过程中还是觉得自己有点粗心大意。另外，手工测试依旧会有缺漏，学习下自动化测试还是很有必要的。","slug":"项目总结-wps","published":1,"updated":"2017-10-30T10:53:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj9e2jwnm0018cgessqtmy4vm","content":"<p>在某群实习的最后一个项目，暂且叫它wps吧，是一个用于针对H5页面的性能分析平台，主要技术栈是react+redux+webpack+antd。其中前端用的是dva框架，后端用的是egg.js框架。虽然做这个项目的过程遇到不少困难，但是还是很感激当时能有机会接触这个项目，让我可以学到了一些性能分析的技巧和内核的知识。另外在老大的手下做事虽然不轻松，但是也感谢实习期间能遇到了一位愿意耐心指导的导师，告诉我怎么学习怎么成长。最后的最后，在离开之际整理了一下最后一个月重构工作的一些收获吧。</p>\n<h3 id=\"React应用性能分析与优化\"><a href=\"#React应用性能分析与优化\" class=\"headerlink\" title=\"React应用性能分析与优化\"></a>React应用性能分析与优化</h3><p>虽然react解决了在state变化时自动刷新界面，且虚拟DOM（diff算法）也在一定程度减少了重绘的成本。但react也不是无敌的，首先，虚拟DOM的对比也是需要成本的，其次，react发生render的情况不一定符合你的预期。<br><a href=\"http://ww1.sinaimg.cn/large/63739cabgy1fe5t7hfayzj20je06twgv.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww1.sinaimg.cn/large/63739cabgy1fe5t7hfayzj20je06twgv.jpg\" alt=\"img\"></a></p>\n<p>react的每个组件在生命周期里会调用shouldComponentUpdate(object nextProps, object nextState)函数，该函数返回true表示需要更新，需要更新的会调用render生成新的虚拟DOM，false表示不需要。react对此函数默认返回true，（即使没有显示地定义shouldCompnentUpdate函数），即React默认总是进行虚拟DOM的比较，无论真实DOM是否需要被重新渲染。</p>\n<p>In conclusion,对react应用进行性能优化的入口点有两个：</p>\n<ul>\n<li>减少不必要的render调用</li>\n<li>减少虚拟DOM对比的成本</li>\n</ul>\n<h3 id=\"性能检测手段\"><a href=\"#性能检测手段\" class=\"headerlink\" title=\"性能检测手段\"></a>性能检测手段</h3><p>react官方提供了React.addons.Perf来帮助分析组件的性能。</p>\n<ul>\n<li>执行操作前，调用React.addons.Perf.start()</li>\n<li>执行操作后，调用React.addons.Perf.stop()</li>\n<li>printWasted()：查看浪费（即组件render前后保持不变，但是却花费了时间进行虚拟DOM的比较），性能分析中最有用的一个方法。</li>\n<li>printInclusive()：查看组件花费的总时间，可以帮我们找出哪个组件是性能瓶颈。</li>\n<li>查看React对DOM的操作情况，调用React.addons.Rerf.printDOM()查看React对DOM的操作情况</li>\n</ul>\n<p>更多API见 <a href=\"https://facebook.github.io/react/docs/perf.html\" target=\"_blank\" rel=\"external\">React官方文档</a></p>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p><strong>场景实践-减少不必要的react render</strong><br>一开始重构WPS时，发现创建分析模块的表单操作起来异常卡顿。虽然当时子杰对AnalyseRule这个组件的SCU进行重写，改善了表单的卡顿现象，但是现在回过头来屡下思路是必要的。<br>下图是没有进行任何优化处理的表单进行的检测情况，在分析模块规则的一个输入框输入内容的组件渲染情况。<br><a href=\"http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/2f49f8a02e8928ce7dcf3ca1d38e66a2/bad.png\" target=\"_blank\" rel=\"external\"><img src=\"http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/2f49f8a02e8928ce7dcf3ca1d38e66a2/bad.png\" alt=\"bad\"></a>bad<br>输入规则的时候，每次输入，事件监听到内容发生变化，redux那边会dispatch一个setRuleData的action来改变analyse这个state的createData（更具体地说是createData的rules下的某个对象的某个域的值得改变），更新后的state从容器组件（analyse/modules/detail）传进去后，其子组件的props实际发生了改变。<br>通过代码或者printDOM()方法，知道其数据流向大致如下：</p>\n<p><a href=\"http://ww1.sinaimg.cn/large/63739cabgy1fe607m1ezyj205x0a5jrc.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww1.sinaimg.cn/large/63739cabgy1fe607m1ezyj205x0a5jrc.jpg\" alt=\"img\"></a></p>\n<p>如果现在编辑的分析模块有X个分析规则，X个分析规则又有S个规则条件，当我改变了某个分析规则的某个规则条件的时候，所有其它无辜的分析规则和他们的规则条件也一起被重新render了。<br>如果我编辑了某条规则，我不想让其它无辜分析规则也render呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">shouldComponentUpdate(nextProps) &#123;</div><div class=\"line\"><span class=\"keyword\">return</span> !is(fromJS(nextProps.data), fromJS(<span class=\"keyword\">this</span>.props.data)) || <span class=\"keyword\">this</span>.props.disabled !== nextProps.disabled;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为当父组件的状态state发生变化时，传入state的子组件都会进行重新渲染的前提下。<br>这段代码，就实现了只在这个规则的数据发生变化，不影响其它实际一动也不动的分析规则进行生成虚拟DOM并且对比balabla。</p>\n<p>所以在AnalyseRule和ConditionItem重载组件的shouldComponentUpdate后，再用性能分析工具检测一下成果：<br><strong>同样的操作（一个分析模块，两个分析规则，改变其中一个分析规则的规则条件的字段输入框），时间从143ms减少到69ms，影响的DOM操作从15个减少到6个，即只会让自身所在的分析规则发生虚拟DOMrender。</strong><br><a href=\"http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/d5d0376b3f838f21c77939d6d64fdbec/2017-03-31_144443.png\" target=\"_blank\" rel=\"external\"><img src=\"http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/d5d0376b3f838f21c77939d6d64fdbec/2017-03-31_144443.png\" alt=\"2017-03-31_144443\"></a>2017-03-31_144443</p>\n<p><strong>关于immutable</strong></p>\n<p>在上面的shouldComponentUpdate可以看到数据的对比是用了immutable，如果不用immutable会怎样？<br>js数据类型分为基本类型和引用类型。如果直接比较两个对象，实际比较的是他们的指向，即使我们改变了它们的内容，指向不发生改变，那么比较的结果就是没变，导致优化失效。所以这里的比较必须是深比较，但是deepCompare是非常消耗性能的。而immutable可以很好地解决这些问题。<br>immutable的实现原理是持久化数据结构（具体看<a href=\"https://github.com/camsong/blog/issues/3\" target=\"_blank\" rel=\"external\">immutable详解以及React中的事件</a>），减低了深比较的成本。另外immutable提高了简洁高效判断数据是否变化的方法<code>is</code>.</p>\n<p>以前除去SCU这里的场景，immutable在数据流的应用也起到了很大的作用。<br>虽然immutable是一个重型库，但是在大型应用中引入是有价值的，它可以除去了复杂应用中可变数据带来的隐患。</p>\n<p>总结-react比较好的实践：</p>\n<ul>\n<li>即使组件之后被复用的机会很小，也不要将复杂的组件在一个组件写完。</li>\n<li>props和state的数据尽可能简单扁平化。</li>\n<li>{…this.props}不滥用，只传组件需要的数据，减少shouldComponentUpdate进行数据比较的负担。</li>\n<li>map的组件要用key，刚刚才发现用可变的index对性能优化是没有半点作用的（WPS有几处是用index做key的，这个要改@-@），具体原因可以看下面两篇比较好的文章</li>\n<li><a href=\"http://taobaofed.org/blog/2016/08/24/react-key/\" target=\"_blank\" rel=\"external\">key属性的原理和用法</a></li>\n<li><a href=\"http://levy.work/2016-08-31-debug-react-key-with-performance-tool/\" target=\"_blank\" rel=\"external\">使用Perf工具研究React Key对渲染的影响</a></li>\n</ul>\n<h3 id=\"产品设计和用户体验\"><a href=\"#产品设计和用户体验\" class=\"headerlink\" title=\"产品设计和用户体验\"></a>产品设计和用户体验</h3><p>因为WPS是没有专门的产品的，研发就是产品经理。但开发过程习惯了从研发的角度去思考。</p>\n<h4 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h4><p>因为该项目类似与管理后台系统，多处都需要用户填写表单（创建分析模块，创建评估报告等等）。表单这一块是与用户交互最频繁的组件之一了。而表单的优化有几点：</p>\n<ul>\n<li>良好的用户提示和反馈，可以减少用户提交表单的成功率（placeholder,以及antd附带的hasFeedback功能）</li>\n<li>给输入项设置默认值，自动填充，自动补全，自动聚焦，可以减少用户输入的时间。</li>\n</ul>\n<p>其它与业务相关的：</p>\n<ul>\n<li>编辑分析模块的时候，有分析规则包含了关联规则，有些没有，区分两者的区别可以加快用户的编辑操作，从而提高用户体验。</li>\n</ul>\n<h4 id=\"任务等待\"><a href=\"#任务等待\" class=\"headerlink\" title=\"任务等待\"></a>任务等待</h4><p>除了创建和编辑表单，另外一个重要的使用场景就是查看评估报告。刚创建完评估报告后，需要用户等待分析服务分析完才能看到结果。最初的版本是需要用户手动刷新才能看到任务的最新状态，于是后来就提供了一个按钮，用户点击后发起异步请求，到后来按钮也不要，直接自动在一定时间间隔内发生请求，获取最新的状态信息。<br>优化的过程得到的教训：</p>\n<blockquote>\n<p>减少用户的非必要的主动操作。像F5重刷页面和提供刷新按钮进行局部刷新，也许技术上有点差异，但是从用户体验角度，其实毫无差异。</p>\n</blockquote>\n<p>另外，对于等待这件事，如果可以不断给予用户当前状态的反馈，会大大提升用户的体验。比如任务结果等待还可以进行的优化是，提供任务大概还要运行的时间..（即使技术上不能百分百确定还需等待的时间，但“欺骗”用户的交互设计窍门也是值得借鉴的）<a href=\"https://www.zhihu.com/question/20064203\" target=\"_blank\" rel=\"external\">用户体验设计中有哪些针对「等待」的设计的好例子？</a></p>\n<p>总结：<br>优化用户体验的核心尽量使得产品变得易用（易于上手，减少使用遇到的挫折），实用和使用过程保证用户的满意度（保证操作和使用的效率）。总而言之，学会从使用者的角度去考虑产品（这点说起来很简单，但因为是很主观性的东西，其实实际很难考虑全面，但是尽量做到“don’t make me think , don’t make me unconfortable”吧）。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>项目开发中，多次因为测试不到位引发的事故。然而，测试真的并不是一件易事，但它也是有章法可循的。<br>而测试前应该要先明确测试用例。从慧贤那里学到了书写测试用例最常用的方法是将模块从上到下进行拆分，每个模块有自己单独的用例，模块与模块之间有连接的用例，页面和页面之间交互的用例等…</p>\n<p><strong>测试用例设计方法</strong></p>\n<ul>\n<li>黑盒测试用例设计（常用的是等价类划分和边界值分析）<a href=\"http://www.cnblogs.com/Carolinee/p/5531971.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Carolinee/p/5531971.html</a></li>\n<li>白盒测试用例设计（适用于开发人员，包括语句覆盖，判断覆盖，条件覆盖等..）<a href=\"http://www.cnblogs.com/Carolinee/p/5404675.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Carolinee/p/5404675.html</a></li>\n</ul>\n<p>总结：<br>测试最主要还是要细心细致。而这个过程中还是觉得自己有点粗心大意。另外，手工测试依旧会有缺漏，学习下自动化测试还是很有必要的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在某群实习的最后一个项目，暂且叫它wps吧，是一个用于针对H5页面的性能分析平台，主要技术栈是react+redux+webpack+antd。其中前端用的是dva框架，后端用的是egg.js框架。虽然做这个项目的过程遇到不少困难，但是还是很感激当时能有机会接触这个项目，让我可以学到了一些性能分析的技巧和内核的知识。另外在老大的手下做事虽然不轻松，但是也感谢实习期间能遇到了一位愿意耐心指导的导师，告诉我怎么学习怎么成长。最后的最后，在离开之际整理了一下最后一个月重构工作的一些收获吧。</p>\n<h3 id=\"React应用性能分析与优化\"><a href=\"#React应用性能分析与优化\" class=\"headerlink\" title=\"React应用性能分析与优化\"></a>React应用性能分析与优化</h3><p>虽然react解决了在state变化时自动刷新界面，且虚拟DOM（diff算法）也在一定程度减少了重绘的成本。但react也不是无敌的，首先，虚拟DOM的对比也是需要成本的，其次，react发生render的情况不一定符合你的预期。<br><a href=\"http://ww1.sinaimg.cn/large/63739cabgy1fe5t7hfayzj20je06twgv.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww1.sinaimg.cn/large/63739cabgy1fe5t7hfayzj20je06twgv.jpg\" alt=\"img\"></a></p>\n<p>react的每个组件在生命周期里会调用shouldComponentUpdate(object nextProps, object nextState)函数，该函数返回true表示需要更新，需要更新的会调用render生成新的虚拟DOM，false表示不需要。react对此函数默认返回true，（即使没有显示地定义shouldCompnentUpdate函数），即React默认总是进行虚拟DOM的比较，无论真实DOM是否需要被重新渲染。</p>\n<p>In conclusion,对react应用进行性能优化的入口点有两个：</p>\n<ul>\n<li>减少不必要的render调用</li>\n<li>减少虚拟DOM对比的成本</li>\n</ul>\n<h3 id=\"性能检测手段\"><a href=\"#性能检测手段\" class=\"headerlink\" title=\"性能检测手段\"></a>性能检测手段</h3><p>react官方提供了React.addons.Perf来帮助分析组件的性能。</p>\n<ul>\n<li>执行操作前，调用React.addons.Perf.start()</li>\n<li>执行操作后，调用React.addons.Perf.stop()</li>\n<li>printWasted()：查看浪费（即组件render前后保持不变，但是却花费了时间进行虚拟DOM的比较），性能分析中最有用的一个方法。</li>\n<li>printInclusive()：查看组件花费的总时间，可以帮我们找出哪个组件是性能瓶颈。</li>\n<li>查看React对DOM的操作情况，调用React.addons.Rerf.printDOM()查看React对DOM的操作情况</li>\n</ul>\n<p>更多API见 <a href=\"https://facebook.github.io/react/docs/perf.html\" target=\"_blank\" rel=\"external\">React官方文档</a></p>\n<h3 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h3><p><strong>场景实践-减少不必要的react render</strong><br>一开始重构WPS时，发现创建分析模块的表单操作起来异常卡顿。虽然当时子杰对AnalyseRule这个组件的SCU进行重写，改善了表单的卡顿现象，但是现在回过头来屡下思路是必要的。<br>下图是没有进行任何优化处理的表单进行的检测情况，在分析模块规则的一个输入框输入内容的组件渲染情况。<br><a href=\"http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/2f49f8a02e8928ce7dcf3ca1d38e66a2/bad.png\" target=\"_blank\" rel=\"external\"><img src=\"http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/2f49f8a02e8928ce7dcf3ca1d38e66a2/bad.png\" alt=\"bad\"></a>bad<br>输入规则的时候，每次输入，事件监听到内容发生变化，redux那边会dispatch一个setRuleData的action来改变analyse这个state的createData（更具体地说是createData的rules下的某个对象的某个域的值得改变），更新后的state从容器组件（analyse/modules/detail）传进去后，其子组件的props实际发生了改变。<br>通过代码或者printDOM()方法，知道其数据流向大致如下：</p>\n<p><a href=\"http://ww1.sinaimg.cn/large/63739cabgy1fe607m1ezyj205x0a5jrc.jpg\" target=\"_blank\" rel=\"external\"><img src=\"http://ww1.sinaimg.cn/large/63739cabgy1fe607m1ezyj205x0a5jrc.jpg\" alt=\"img\"></a></p>\n<p>如果现在编辑的分析模块有X个分析规则，X个分析规则又有S个规则条件，当我改变了某个分析规则的某个规则条件的时候，所有其它无辜的分析规则和他们的规则条件也一起被重新render了。<br>如果我编辑了某条规则，我不想让其它无辜分析规则也render呢？</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">shouldComponentUpdate(nextProps) &#123;</div><div class=\"line\"><span class=\"keyword\">return</span> !is(fromJS(nextProps.data), fromJS(<span class=\"keyword\">this</span>.props.data)) || <span class=\"keyword\">this</span>.props.disabled !== nextProps.disabled;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>因为当父组件的状态state发生变化时，传入state的子组件都会进行重新渲染的前提下。<br>这段代码，就实现了只在这个规则的数据发生变化，不影响其它实际一动也不动的分析规则进行生成虚拟DOM并且对比balabla。</p>\n<p>所以在AnalyseRule和ConditionItem重载组件的shouldComponentUpdate后，再用性能分析工具检测一下成果：<br><strong>同样的操作（一个分析模块，两个分析规则，改变其中一个分析规则的规则条件的字段输入框），时间从143ms减少到69ms，影响的DOM操作从15个减少到6个，即只会让自身所在的分析规则发生虚拟DOMrender。</strong><br><a href=\"http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/d5d0376b3f838f21c77939d6d64fdbec/2017-03-31_144443.png\" target=\"_blank\" rel=\"external\"><img src=\"http://git.cn-hangzhou.oss-cdn.aliyun-inc.com/uploads/wps/wpsd-demo/d5d0376b3f838f21c77939d6d64fdbec/2017-03-31_144443.png\" alt=\"2017-03-31_144443\"></a>2017-03-31_144443</p>\n<p><strong>关于immutable</strong></p>\n<p>在上面的shouldComponentUpdate可以看到数据的对比是用了immutable，如果不用immutable会怎样？<br>js数据类型分为基本类型和引用类型。如果直接比较两个对象，实际比较的是他们的指向，即使我们改变了它们的内容，指向不发生改变，那么比较的结果就是没变，导致优化失效。所以这里的比较必须是深比较，但是deepCompare是非常消耗性能的。而immutable可以很好地解决这些问题。<br>immutable的实现原理是持久化数据结构（具体看<a href=\"https://github.com/camsong/blog/issues/3\" target=\"_blank\" rel=\"external\">immutable详解以及React中的事件</a>），减低了深比较的成本。另外immutable提高了简洁高效判断数据是否变化的方法<code>is</code>.</p>\n<p>以前除去SCU这里的场景，immutable在数据流的应用也起到了很大的作用。<br>虽然immutable是一个重型库，但是在大型应用中引入是有价值的，它可以除去了复杂应用中可变数据带来的隐患。</p>\n<p>总结-react比较好的实践：</p>\n<ul>\n<li>即使组件之后被复用的机会很小，也不要将复杂的组件在一个组件写完。</li>\n<li>props和state的数据尽可能简单扁平化。</li>\n<li>{…this.props}不滥用，只传组件需要的数据，减少shouldComponentUpdate进行数据比较的负担。</li>\n<li>map的组件要用key，刚刚才发现用可变的index对性能优化是没有半点作用的（WPS有几处是用index做key的，这个要改@-@），具体原因可以看下面两篇比较好的文章</li>\n<li><a href=\"http://taobaofed.org/blog/2016/08/24/react-key/\" target=\"_blank\" rel=\"external\">key属性的原理和用法</a></li>\n<li><a href=\"http://levy.work/2016-08-31-debug-react-key-with-performance-tool/\" target=\"_blank\" rel=\"external\">使用Perf工具研究React Key对渲染的影响</a></li>\n</ul>\n<h3 id=\"产品设计和用户体验\"><a href=\"#产品设计和用户体验\" class=\"headerlink\" title=\"产品设计和用户体验\"></a>产品设计和用户体验</h3><p>因为WPS是没有专门的产品的，研发就是产品经理。但开发过程习惯了从研发的角度去思考。</p>\n<h4 id=\"表单\"><a href=\"#表单\" class=\"headerlink\" title=\"表单\"></a>表单</h4><p>因为该项目类似与管理后台系统，多处都需要用户填写表单（创建分析模块，创建评估报告等等）。表单这一块是与用户交互最频繁的组件之一了。而表单的优化有几点：</p>\n<ul>\n<li>良好的用户提示和反馈，可以减少用户提交表单的成功率（placeholder,以及antd附带的hasFeedback功能）</li>\n<li>给输入项设置默认值，自动填充，自动补全，自动聚焦，可以减少用户输入的时间。</li>\n</ul>\n<p>其它与业务相关的：</p>\n<ul>\n<li>编辑分析模块的时候，有分析规则包含了关联规则，有些没有，区分两者的区别可以加快用户的编辑操作，从而提高用户体验。</li>\n</ul>\n<h4 id=\"任务等待\"><a href=\"#任务等待\" class=\"headerlink\" title=\"任务等待\"></a>任务等待</h4><p>除了创建和编辑表单，另外一个重要的使用场景就是查看评估报告。刚创建完评估报告后，需要用户等待分析服务分析完才能看到结果。最初的版本是需要用户手动刷新才能看到任务的最新状态，于是后来就提供了一个按钮，用户点击后发起异步请求，到后来按钮也不要，直接自动在一定时间间隔内发生请求，获取最新的状态信息。<br>优化的过程得到的教训：</p>\n<blockquote>\n<p>减少用户的非必要的主动操作。像F5重刷页面和提供刷新按钮进行局部刷新，也许技术上有点差异，但是从用户体验角度，其实毫无差异。</p>\n</blockquote>\n<p>另外，对于等待这件事，如果可以不断给予用户当前状态的反馈，会大大提升用户的体验。比如任务结果等待还可以进行的优化是，提供任务大概还要运行的时间..（即使技术上不能百分百确定还需等待的时间，但“欺骗”用户的交互设计窍门也是值得借鉴的）<a href=\"https://www.zhihu.com/question/20064203\" target=\"_blank\" rel=\"external\">用户体验设计中有哪些针对「等待」的设计的好例子？</a></p>\n<p>总结：<br>优化用户体验的核心尽量使得产品变得易用（易于上手，减少使用遇到的挫折），实用和使用过程保证用户的满意度（保证操作和使用的效率）。总而言之，学会从使用者的角度去考虑产品（这点说起来很简单，但因为是很主观性的东西，其实实际很难考虑全面，但是尽量做到“don’t make me think , don’t make me unconfortable”吧）。</p>\n<h3 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h3><p>项目开发中，多次因为测试不到位引发的事故。然而，测试真的并不是一件易事，但它也是有章法可循的。<br>而测试前应该要先明确测试用例。从慧贤那里学到了书写测试用例最常用的方法是将模块从上到下进行拆分，每个模块有自己单独的用例，模块与模块之间有连接的用例，页面和页面之间交互的用例等…</p>\n<p><strong>测试用例设计方法</strong></p>\n<ul>\n<li>黑盒测试用例设计（常用的是等价类划分和边界值分析）<a href=\"http://www.cnblogs.com/Carolinee/p/5531971.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Carolinee/p/5531971.html</a></li>\n<li>白盒测试用例设计（适用于开发人员，包括语句覆盖，判断覆盖，条件覆盖等..）<a href=\"http://www.cnblogs.com/Carolinee/p/5404675.html\" target=\"_blank\" rel=\"external\">http://www.cnblogs.com/Carolinee/p/5404675.html</a></li>\n</ul>\n<p>总结：<br>测试最主要还是要细心细致。而这个过程中还是觉得自己有点粗心大意。另外，手工测试依旧会有缺漏，学习下自动化测试还是很有必要的。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cj9e2jwme0000cgespnmuvpxs","tag_id":"cj9e2jwml0002cges3q3zffmo","_id":"cj9e2jwmt0007cgesjb21oebf"},{"post_id":"cj9e2jwmi0001cgesrfedfra6","tag_id":"cj9e2jwml0002cges3q3zffmo","_id":"cj9e2jwmx000bcgesxn9hu229"},{"post_id":"cj9e2jwmn0003cges3ye401n7","tag_id":"cj9e2jwml0002cges3q3zffmo","_id":"cj9e2jwmz000fcgesjq2vdcit"},{"post_id":"cj9e2jwmo0004cgesr1jqoky2","tag_id":"cj9e2jwmz000ecgesxje5i6mp","_id":"cj9e2jwn3000kcges2w87mtit"},{"post_id":"cj9e2jwn3000jcgesovs78shm","tag_id":"cj9e2jwml0002cges3q3zffmo","_id":"cj9e2jwn5000ncgespufdyrbk"},{"post_id":"cj9e2jwmp0005cgesj936udr4","tag_id":"cj9e2jwmz000ecgesxje5i6mp","_id":"cj9e2jwn8000pcges32ma3wo5"},{"post_id":"cj9e2jwmt0008cgeso670d0iv","tag_id":"cj9e2jwn5000mcgesb14mxlre","_id":"cj9e2jwnb000tcgessm0u45tn"},{"post_id":"cj9e2jwmv0009cgessqvfws2c","tag_id":"cj9e2jwn9000rcges5iby9nz5","_id":"cj9e2jwnf000xcgesmb2rur89"},{"post_id":"cj9e2jwne000wcgeshju7sfgt","tag_id":"cj9e2jwn9000rcges5iby9nz5","_id":"cj9e2jwng000zcgeskg8q7xnu"},{"post_id":"cj9e2jwmx000ccgesfztddltn","tag_id":"cj9e2jwn9000rcges5iby9nz5","_id":"cj9e2jwni0012cges0lbc5jyu"},{"post_id":"cj9e2jwnf000ycgeszxftby9k","tag_id":"cj9e2jwn5000mcgesb14mxlre","_id":"cj9e2jwnk0014cgesodb8s86m"},{"post_id":"cj9e2jwnh0011cgesq0m52pwj","tag_id":"cj9e2jwn9000rcges5iby9nz5","_id":"cj9e2jwnm0017cges933t1lqr"},{"post_id":"cj9e2jwmz000dcges64lktmjw","tag_id":"cj9e2jwn5000mcgesb14mxlre","_id":"cj9e2jwnp0019cgeswu308oa1"},{"post_id":"cj9e2jwnk0016cgesgf6ij9pa","tag_id":"cj9e2jwn9000rcges5iby9nz5","_id":"cj9e2jwnq001bcgesxmojw8i3"},{"post_id":"cj9e2jwn0000gcgesslcjuvsv","tag_id":"cj9e2jwnk0015cgesylxuxov8","_id":"cj9e2jwnr001ccges0nhwjm7e"},{"post_id":"cj9e2jwn1000hcges6redobeg","tag_id":"cj9e2jwn5000mcgesb14mxlre","_id":"cj9e2jwns001ecgesr3dsolrj"},{"post_id":"cj9e2jwn4000lcgesi4qf8yim","tag_id":"cj9e2jwn5000mcgesb14mxlre","_id":"cj9e2jwns001gcgess9ayuzha"},{"post_id":"cj9e2jwn6000ocges1pmrx3da","tag_id":"cj9e2jwnk0015cgesylxuxov8","_id":"cj9e2jwnt001icgesulmfdruf"},{"post_id":"cj9e2jwn8000qcgesrdf9hrti","tag_id":"cj9e2jwns001hcges1h59np4k","_id":"cj9e2jwnt001kcgesis7ku4t9"},{"post_id":"cj9e2jwna000scgesd5spzt67","tag_id":"cj9e2jwnt001jcges5bija287","_id":"cj9e2jwnt001mcgesn52b7d94"},{"post_id":"cj9e2jwnc000ucges3enxdwul","tag_id":"cj9e2jwnt001jcges5bija287","_id":"cj9e2jwnu001ocgesyyyaior6"},{"post_id":"cj9e2jwnj0013cgesf9cbh17j","tag_id":"cj9e2jwnk0015cgesylxuxov8","_id":"cj9e2jwnu001qcgesm8wtscsx"},{"post_id":"cj9e2jwnm0018cgessqtmy4vm","tag_id":"cj9e2jwns001hcges1h59np4k","_id":"cj9e2jwnu001rcgesjmaft9d8"}],"Tag":[{"name":"CSS","_id":"cj9e2jwml0002cges3q3zffmo"},{"name":"前端框架","_id":"cj9e2jwmz000ecgesxje5i6mp"},{"name":"前端工具","_id":"cj9e2jwn5000mcgesb14mxlre"},{"name":"设计模式","_id":"cj9e2jwn9000rcges5iby9nz5"},{"name":"杂谈","_id":"cj9e2jwnk0015cgesylxuxov8"},{"name":"实战总结","_id":"cj9e2jwns001hcges1h59np4k"},{"name":"前端性能","_id":"cj9e2jwnt001jcges5bija287"}]}}