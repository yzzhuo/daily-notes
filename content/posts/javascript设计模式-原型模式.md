---
title: javascript设计模式-原型模式
date: 2017-6-23 23:13:58
tags: 设计模式
---

之前对设计模式的学习和实践都是基于Java的。虽说设计模式其实无关语言，仅仅是对某一种问题的特定的一种解决方案和设计思想。但是最近看的曾探写的《Javascript设计模式与开发实践》深有体会。一是，认同作者认为设计模式说白了就是对某一种问题的解决方案和设计思路，只是后来被冠之以名。但学习设计模式是必要的，因为知道了有哪些设计模式，才能更清楚地知道自己的代码写得好不好，以及怎么使用适合的设计模式来改善自己的代码。

二是设计模式本质的一样的，但会随着不同语言，根据根据语言本身的特性的不同有不同的实现方式。好比针对Javascript，实现多态，继承和封装就和java不大一样。

通过阅读上面提到的书，整理了关于javaScript的几个设计模式。首先，是原型模式。

### 原型模式

#### 介绍

设计模式中，原型模式是用来创建对象的一种模式，我们可以用原型模式来创建一个一模一样的对象，但是通常目的只是为了更便捷地创建某个类型的对象。在Java中，创建对象的方法是先指定它的类型，然后后通过类的概念来创建对象。而对于Javascript这种没有类的语言，我们创建对象通常是找到一个对象，然后通过克隆它来创建一个对象。

虽然ES6中有了class来创建一个类，但是它本质上还是用原型来创建对象的。

#### 在js中的应用

ps：js中没有类的概念，只有对象的概念。但是为了区分不同对象充当的角色，通常用开头大学来标注它是一个“类”（抽象的对象），而开头小写来标注它是个具体的实例。

##### 创建对象，实现继承

- new创建对象，js的构造器其实是一个函数

  js没有类的概念，而函数是js的一等公民，js中的函数可以作为普通函数被调用，也可以作为构造器被调用。我们创建对象使用的new关键词实际上就是在调用一个作为构造器的函数。当我们用new调用一个构造器，其实就是在克隆一个对象的过程。


- 其实对象会记住它的原型，准确来说不是对象真的有一个原型，而是它的构造器有原型。对象把请求委托给它自己的原型其实更准确地说是对象把请求委托给它的构造器的原型。js给对象提供了一个名为*proto*的隐藏属性，chrome和firefox可以向外暴露对象的这个属性，这个属性默认会指向它的构造器的原型对象。

  ``` javascript
  new a = new Object();
  console.log(a._proto_ === Object.prototype); //输出true
  ```


- 因为_*proto*记住了构造器的原型，所以我们说对象记住了它的原型，并通过原型来实现了继承。
- 虽然js的对象最初都是由Object.proptype对象克隆来的，但对象构造器的原型可以动态地指向其他对象。当我们想创建一个继承B的对象A，只要把对象A的构造器的原型指向对象B，就能实现继承的效果。
- js最常见的继承方式：

``` javascript
var obj = { name: 'june'};
var A = function() {  }
A.proptype = obj;
var a = new A();
console.log(a.name); //输出：june
```

``` javascript
// 一个类继承另外一个类
var A = function() {}
A.prototype = { name: 'sven'};
var B = function() {}
B.prototype = new A();
var b = new B();
b.name; //=> sven
```

- 上面两端代码的目的是一样的，本质上也没有差别，区别只是一个将B.proptype直接指向一个字面量对象，一个是指向new A()，后者会比前者形成的原型链多了一层。

- Object.create方法：我通常用它来创建一个基于某个现有对象的对象，但准确来说它就是通过原型模式来实现了一个次原型继承。

  该方法实际等同于：

  ```javascript
  functionO(obj) {
    var F = function() {
      F.prototype = obj;
      return new F();
    }
  }
  var a = Object.create({}); //a.proptype为Object;
  var b = Object.create(null); //b.proptype为null;

  ```

  #### 思考题

  - prototype和constructor和*proto*傻傻分不清楚？

    - **prototype 属性是可读写的，该属性是函数所特有,但准确来说该属性是为构造函数所量身定造的。** 这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有此构造器实例化出来的实例所共享的属性和方法。
    - **被构造函数new 出来的对象是 实例对象，实例对象的属性 constructor 指向了构造函数。**对象的请求委托实际上是在对象自己无法应答请求的时候，将请求委托给构造器的原型。
    - **实例对象的 proto 指向了构造器的原型对象(prototype属性).**

    实践是唯一的真理：

    - [![img](http://ww1.sinaimg.cn/large/63739cabgy1fgpk7qyezxj20ck0ebdgm.jpg)](http://ww1.sinaimg.cn/large/63739cabgy1fgpk7qyezxj20ck0ebdgm.jpg)

      ​


    - 为什么说当前的javascript引擎下，通过Object.create来创建对象比通过构造函数创建对象要慢呢？

      待续…

    - javascript创建对象的其它方式有哪些呢？

      待续…

    #### 总结

    之前看红皮书和犀牛书，都不得不被对象继承和原型那一章节搞得晕乎乎。学习了原型模式后，其实现在看来，javascript其实就是依靠原型模式来搭建整个面向对象系统的，js连类的概念都没有，更别说继承了。实际上，为了实现js的继承，我们利用的是原型的机制，所有的js对象都是从某个对象克隆而来的。而原型这两个字其实就是它表面的意思，如果A对象是从B对象克隆而来的，那么B对象就是A对象的原型。